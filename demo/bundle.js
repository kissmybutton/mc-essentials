(() => {
  var t,
    e = {
      657: function (t, e, n) {
        t.exports = (function (t) {
          "use strict";
          const e = "--mc-player";
          var n = {
            play: '\x3c!-- Generated by IcoMoon.io --\x3e\n<svg id="play-svg" version="1.1" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32">\n<title>play</title>\n<path fill="#999" d="M27.558 13.624l-21.827-13.232c-0.402-0.248-0.89-0.395-1.411-0.395-1.502 0-2.72 1.218-2.72 2.72 0 0.002 0 0.004 0 0.006v-0 26.461c0 0.001 0 0.002 0 0.003 0 1.502 1.218 2.72 2.72 2.72 0.522 0 1.009-0.147 1.423-0.401l-0.012 0.007 21.827-13.232c0.792-0.485 1.313-1.346 1.313-2.328s-0.521-1.843-1.301-2.321l-0.012-0.007z"></path>\n</svg>',
            pause:
              '\x3c!-- Generated by IcoMoon.io --\x3e\n<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32">\n<title>pause</title>\n<path d="M6.059 4.639h8.521v22.722h-8.521zM18.84 4.639h8.521v22.722h-8.521z"></path>\n</svg>',
            "expand-full":
              '\x3c!-- Generated by IcoMoon.io --\x3e\n<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32">\n<title>expand-full</title>\n<path fill="#999" d="M31.667 3.271c-0.004-1.619-1.315-2.93-2.934-2.934h-7.642c-0.921 0-1.667 0.747-1.667 1.667s0.747 1.667 1.667 1.667h6.909c0.185 0 0.333 0.148 0.333 0.332v4.359c0 0.921 0.747 1.667 1.667 1.667s1.667-0.746 1.667-1.667v0-5.091zM0.333 8.362c0 0.921 0.746 1.667 1.667 1.667s1.667-0.746 1.667-1.667v0-4.362c0-0.001 0-0.001 0-0.002 0-0.184 0.148-0.333 0.332-0.333h6.909c0.898-0.029 1.614-0.764 1.614-1.667s-0.717-1.637-1.612-1.666l-0.003-0h-7.635c-1.619 0.005-2.931 1.315-2.934 2.936l-0.007 5.095zM31.667 28.726v-5.091c0-0.921-0.747-1.667-1.667-1.667s-1.667 0.747-1.667 1.667v0 4.365c0 0.185-0.148 0.333-0.332 0.333h-6.909c-0.921 0-1.667 0.747-1.667 1.667s0.747 1.667 1.667 1.667v0h7.635c1.624-0.002 2.941-1.319 2.941-2.942zM0.333 28.726c0.004 1.621 1.319 2.934 2.941 2.934 0 0 0 0 0 0h7.635c0.016 0.001 0.034 0.001 0.053 0.001 0.921 0 1.667-0.747 1.667-1.667s-0.746-1.667-1.667-1.667c-0.019 0-0.037 0-0.056 0.001l0.003-0h-6.909c-0 0-0 0-0 0-0.182 0-0.33-0.145-0.333-0.326v-4.366c0-0.921-0.747-1.667-1.667-1.667s-1.667 0.747-1.667 1.667v0 5.091z"></path>\n<path fill="#999" d="M10.321 10.848h11.357c1.818 0 3.291 1.473 3.291 3.291v3.72c0 1.818-1.473 3.291-3.291 3.291h-11.357c-1.818 0-3.291-1.473-3.291-3.291v-3.72c0-1.818 1.473-3.291 3.291-3.291z"></path>\n</svg>',
            "angle-left":
              '\x3c!-- Generated by IcoMoon.io --\x3e\n<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="16" height="32" viewBox="0 0 16 32">\n<title>angle-left</title>\n<path d="M1.981 14.938l8.5-8.5c0.588-0.588 1.537-0.588 2.119 0l1.412 1.412c0.588 0.588 0.588 1.537 0 2.119l-6.019 6.031 6.025 6.025c0.588 0.587 0.588 1.538 0 2.119l-1.412 1.419c-0.588 0.587-1.537 0.587-2.119 0l-8.5-8.5c-0.594-0.587-0.594-1.537-0.006-2.125z"></path>\n</svg>',
            "angle-right":
              '\x3c!-- Generated by IcoMoon.io --\x3e\n<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="16" height="32" viewBox="0 0 16 32">\n<title>angle-right</title>\n<path d="M14.019 17.063l-8.5 8.5c-0.588 0.587-1.538 0.587-2.119 0l-1.413-1.413c-0.587-0.587-0.587-1.538 0-2.119l6.019-6.031-6.025-6.025c-0.587-0.588-0.587-1.537 0-2.119l1.413-1.419c0.587-0.588 1.538-0.588 2.119 0l8.5 8.5c0.594 0.588 0.594 1.538 0.006 2.125z"></path>\n</svg>',
            settings:
              '\x3c!-- Generated by IcoMoon.io --\x3e\n<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32">\n<title>settings</title>\n<path fill="#999" d="M29.999 12.665h-2.483c-0.275-0.938-0.621-1.751-1.048-2.512l0.031 0.060 1.757-1.755c0.362-0.362 0.587-0.862 0.587-1.415s-0.224-1.053-0.587-1.415l-1.886-1.883c-0.362-0.362-0.862-0.586-1.415-0.586s-1.053 0.224-1.415 0.586l-1.757 1.755c-0.701-0.397-1.514-0.743-2.366-0.996l-0.084-0.021v-2.483c0.002-1.107-0.894-2.001-1.999-2.001h-2.668c-1.105 0-1.999 0.896-1.999 2.001v2.483c-0.938 0.275-1.751 0.621-2.513 1.048l0.060-0.031-1.757-1.755c-0.362-0.362-0.862-0.587-1.415-0.587s-1.053 0.224-1.415 0.587l-1.886 1.886c-0.362 0.362-0.586 0.862-0.586 1.415s0.224 1.053 0.586 1.415v0l1.758 1.755c-0.431 0.775-0.771 1.598-1.017 2.451h-2.483c-1.107-0.002-2.001 0.894-2.001 1.999v2.668c0 1.105 0.896 1.999 2.001 1.999h2.483c0.246 0.854 0.586 1.676 1.017 2.452l-1.762 1.758c-0.362 0.362-0.586 0.862-0.586 1.415s0.224 1.053 0.586 1.415v0l1.886 1.885c0.368 0.348 0.866 0.563 1.415 0.563s1.047-0.214 1.416-0.564l-0.001 0.001 1.757-1.757c0.778 0.429 1.6 0.771 2.454 1.019v2.479c0 1.105 0.894 2.001 1.999 2.001h2.668c1.105 0 1.999-0.896 1.999-2.001v-2.479c0.852-0.248 1.676-0.589 2.452-1.017l1.757 1.757c0.362 0.362 0.862 0.586 1.415 0.586s1.053-0.224 1.415-0.586v0l1.885-1.886c0.362-0.362 0.586-0.862 0.586-1.414s-0.224-1.052-0.586-1.414l-1.757-1.757c0.431-0.776 0.771-1.6 1.017-2.452h2.483c0 0 0.001 0 0.002 0 1.105 0 2.001-0.896 2.001-2.001 0-0.002 0-0.004 0-0.005v0-2.663c0-1.105-0.896-1.999-2.001-1.999zM16 22.668c-3.682 0-6.666-2.985-6.666-6.666s2.985-6.666 6.666-6.666v0c3.682 0 6.666 2.985 6.666 6.666s-2.985 6.666-6.666 6.666v0z"></path>\n</svg>',
            loop: '\x3c!-- Generated by IcoMoon.io --\x3e\n<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32">\n<title>loop</title>\n<path fill="#999" d="M22.364 21.968h-0.631c-0.92 0-1.667 0.746-1.667 1.667s0.746 1.667 1.667 1.667h0.637c0.013 0 0.028 0 0.044 0 5.113 0 9.259-4.145 9.259-9.259 0-4.668-3.454-8.529-7.946-9.166l-0.049-0.006c-0.158-0.028-0.276-0.164-0.277-0.328v-2.636c-0-0.92-0.746-1.666-1.667-1.666-0.357 0-0.689 0.112-0.96 0.304l0.005-0.003-6.371 4.455c-0.432 0.305-0.711 0.803-0.711 1.365 0 0.92 0.746 1.667 1.667 1.667 0 0 0 0 0 0h6.352c3.772 0 6.617 2.567 6.617 5.971-0.004 3.295-2.674 5.966-5.969 5.969h-0zM8.329 25.127c0.16 0.027 0.277 0.165 0.277 0.328v2.635c0 0.001 0 0.001 0 0.002 0 0.92 0.746 1.665 1.665 1.665 0.358 0 0.69-0.113 0.961-0.305l-0.005 0.003 6.364-4.453c0.432-0.306 0.71-0.803 0.71-1.365 0-0.92-0.746-1.667-1.666-1.668h-6.352c-3.772 0-6.617-2.567-6.617-5.968 0.002-3.296 2.673-5.968 5.969-5.972h0.638c0.92 0 1.667-0.746 1.667-1.667s-0.746-1.667-1.667-1.667v0h-0.637c-0.010-0-0.022-0-0.034-0-5.114 0-9.26 4.146-9.26 9.26 0 4.665 3.45 8.524 7.937 9.166l0.049 0.006z"></path>\n</svg>',
            "volume-on":
              '\x3c!-- Generated by IcoMoon.io --\x3e\n<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32">\n<title>volume-on</title>\n<path d="M26.107 2.991l-3.729 3.185c2.867 2.354 4.694 5.879 4.694 9.824s-1.827 7.47-4.694 9.824l3.729 3.185c3.612-3.226 5.893-7.852 5.893-13.009s-2.281-9.783-5.893-13.009zM19.861 8.326l-3.876 3.312c1.692 0.762 3.038 2.423 3.038 4.362s-1.346 3.6-3.038 4.362l3.876 3.312c2.379-1.756 4.028-4.535 4.028-7.674s-1.649-5.918-4.028-7.674zM12.143 5.399l-7.143 5.601h-3c-1.478 0-2 0.539-2 2v6c0 1.461 0.553 2 2 2h3l7.143 5.595c0.857 0.553 1.85 0.727 1.85-0.823v-19.55c0-1.55-0.993-1.376-1.85-0.823z"></path>\n</svg>',
            "volume-off":
              '\x3c!-- Generated by IcoMoon.io --\x3e\n<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32">\n<title>volume-off</title>\n<path d="M27.397 16.001l4.134-4.144c0.625-0.627 0.625-1.641 0-2.267l-1.132-1.134c-0.625-0.626-1.638-0.626-2.263 0l-4.134 4.144-4.133-4.141c-0.625-0.626-1.638-0.626-2.263 0l-1.132 1.134c-0.625 0.626-0.625 1.641 0 2.267l4.134 4.142-4.131 4.142c-0.625 0.626-0.625 1.641 0 2.267l1.132 1.134c0.625 0.626 1.638 0.626 2.263 0l4.131-4.141 4.133 4.14c0.625 0.627 1.638 0.627 2.263 0l1.132-1.134c0.625-0.626 0.625-1.641 0-2.267l-4.134-4.141zM12.148 5.399l-7.146 5.603h-3.001c-1.479 0-2.001 0.539-2.001 2.001l-0 2.951 0 3.051c0 1.461 0.553 2.001 2.001 2.001h3.001l7.146 5.597c0.857 0.553 1.851 0.727 1.851-0.823v-19.556c-0-1.55-0.994-1.376-1.851-0.823z"></path>\n</svg>',
            "donkeyclip-logo":
              '\x3c!-- Generated by IcoMoon.io --\x3e\n<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32">\n<title>DonkeyClip</title>\n<path fill="#777" d="M25.811 3.454v11.010h-3.479c-0.696-2.447-2.974-4.246-5.638-4.246-3.238 0-5.877 2.638-5.877 5.877s2.638 5.877 5.877 5.877c2.686 0 4.942-1.799 5.638-4.246h3.334c-0.767 4.246-4.485 7.509-8.972 7.509-5.014 0-9.115-4.078-9.115-9.115 0-5.014 4.078-9.115 9.115-9.115 2.231 0 4.294 0.815 5.877 2.159v-7.652c-1.992-0.912-4.222-1.415-6.572-1.415-8.779 0-15.904 7.125-15.904 15.904s7.125 15.904 15.904 15.904c8.779 0 15.904-7.125 15.904-15.904 0.024-5.109-2.375-9.644-6.093-12.546z"></path>\n</svg>',
            spinner:
              '<div class="lds-ring"><div></div><div></div><div></div><div></div></div>',
            "check-solid":
              '\x3c!-- Generated by IcoMoon.io --\x3e\n<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32">\n<title>check-solid</title>\n<path d="M10.869 27.463l-10.4-10.4c-0.625-0.625-0.625-1.638 0-2.263l2.263-2.263c0.625-0.625 1.638-0.625 2.263 0l7.006 7.006 15.006-15.006c0.625-0.625 1.638-0.625 2.263 0l2.263 2.263c0.625 0.625 0.625 1.638 0 2.263l-18.4 18.4c-0.625 0.625-1.638 0.625-2.263-0z"></path>\n</svg>',
          };
          const s = "volume-change",
            i = "mute-change",
            r = "speed-change",
            o = "loop-change",
            a = "scale-change",
            l = "show-volume-change",
            c = "state-change",
            u = "duration-change",
            p = "mouseup",
            h = "mousemove",
            d = "touchend",
            m = "touchmove";
          function f() {
            try {
              document.exitFullscreen
                ? document.exitFullscreen()
                : document.mozCancelFullScreen
                ? document.mozCancelFullScreen()
                : document.webkitExitFullscreen &&
                  document.webkitExitFullscreen();
            } catch (t) {
              console.error(t);
            }
          }
          function g(t) {
            try {
              t.requestFullscreen
                ? t.requestFullscreen()
                : t.mozRequestFullScreen
                ? t.mozRequestFullScreen()
                : t.webkitRequestFullscreen
                ? t.webkitRequestFullscreen()
                : t.msRequestFullscreen && t.msRequestFullscreen();
            } catch (t) {
              console.error(t);
            }
          }
          function y(t) {
            const e = t.clip.props.host.className.includes("full-screen");
            t.clip.props.host !== t.options.host &&
              (e
                ? t.options.host.appendChild(t.elements.mcPlayer)
                : t.clip.props.host.appendChild(t.elements.mcPlayer)),
              e ? f() : g(t.clip.props.host);
          }
          function v(t) {
            A(t, null, "play");
          }
          const b = new t.TimeCapsule();
          let x = setTimeout(() => {}, 0);
          function w(t, e) {
            return t.getElementsByClassName(e)[0];
          }
          function C(t) {
            for (
              var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), s = 1;
              s < e;
              s++
            )
              n[s - 1] = arguments[s];
            return t.addEventListener(...n);
          }
          document.removeEventListener.bind(document);
          const I = (t) => {
              clearTimeout(x),
                t.elements.playPausePanel.classList.remove("hide"),
                t.elements.playPausePanel.classList.remove(
                  "run-animation-play"
                ),
                t.elements.playPausePanel.classList.remove(
                  "run-animation-pause"
                ),
                t.elements.playPausePanel.classList.remove(
                  "run-animation-idle"
                ),
                "idle" === t.clip.runTimeInfo.state
                  ? (t.play(),
                    v(t.elements.playPausePanelContainer),
                    t.elements.playPausePanel.classList.add(
                      "run-animation-idle"
                    ))
                  : "playing" !== t.clip.runTimeInfo.state
                  ? (t.play(),
                    v(t.elements.playPausePanelContainer),
                    t.elements.playPausePanel.classList.add(
                      "run-animation-play"
                    ))
                  : (t.pause(),
                    A(t.elements.playPausePanelContainer, null, "pause"),
                    t.elements.playPausePanel.classList.add(
                      "run-animation-pause"
                    )),
                (x = setTimeout(() => {
                  t.elements.playPausePanel.classList.add("hide");
                }, 800));
            },
            P = /^[+-]?(\d+([.]\d*)?|[.]\d+)/gi;
          function E(t) {
            const e = t.match(P)[0],
              n = t.substring(e.length);
            if (
              "number" == typeof (s = Number(e)) &&
              isFinite(s) &&
              ("%" !== n || "px" !== n)
            )
              return { number: Number(e), unit: n };
            var s;
          }
          function k() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
              navigator.userAgent
            );
          }
          function S(t, e, n) {
            t.document.addEventListener(p, e, !1),
              t.document.addEventListener(d, e, !1),
              t.document.addEventListener(h, n, { passive: !1 }),
              t.document.addEventListener(m, n, { passive: !1 });
          }
          function O(t, e, n) {
            t.document.removeEventListener(p, e, !1),
              t.document.removeEventListener(d, e, !1),
              t.document.removeEventListener(h, n, { passive: !1 }),
              t.document.removeEventListener(m, n, { passive: !1 });
          }
          function M(t) {
            let e =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : document,
              n =
                arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            C(e, "mousedown", t, { passive: n }),
              C(e, "touchstart", t, { passive: n });
          }
          function A(t, e, s) {
            e && (t.classList.remove(`icon-${e}`), (t.innerHTML = "")),
              s && (t.classList.add(`icon-${s}`), (t.innerHTML = n[s]));
          }
          function _(t, e) {
            return t - e;
          }
          function T(t, e) {
            if (
              ((t.id ??= Date.now()),
              (t.showVolume ??= !!Object.keys(t.clip?.audioClip?.children || [])
                .length),
              (t.showIndicator ??= !1),
              (t.theme ??= "default"),
              (t.host ??= t.clip.props.host),
              (t.buttons ??= {}),
              (t.buttons.donkeyclip =
                !("undefined" == typeof window || !window.Donkeyclip?.clipId) &&
                t.buttons.donkeyclip),
              (t.timeFormat ??= "ss"),
              (t.backgroundColor ??= "black"),
              (t.fullscreen ??= !1),
              (t.scaleToFit ??= !0),
              (t.sectionsEasing ??= "easeOutQuart"),
              (t.pointerEvents ??= !1),
              (t.scrollAnimation ??= !1),
              (t.onMillisecondChange ??= null),
              (t.speedValues ??= [-1, 0, 0.5, 1, 2]),
              (t.speed ??= 1),
              (t.muted ??= !1),
              (t.maxScrollStorage ??= 50),
              (t.controls ??= !0),
              (t.loop ??= !1),
              (t.volume ??= 1),
              (t.currentScript ??= null),
              t.millisecond)
            ) {
              const n = e.clip;
              t.millisecond > n.duration && (t.millisecond = n.duration),
                (t.millisecond < 0 || !isFinite(t.millisecond)) &&
                  (t.millisecond = 0),
                e.goToMillisecond(t.millisecond);
            }
            for (const e in t.speedValues)
              isFinite(t.speedValues[e]) || t.speedValues.splice(e, 1);
            return t.speedValues.sort(_), t;
          }
          var D = (t) => {
            B(t);
            const { mcPlayer: e } = t.elements;
            var s;
            (t.elements.pointerEventPanel = w(e, "--mcp-pointer-events-panel")),
              (t.elements.playPausePanel = w(e, "--mcp-play-pause-panel")),
              (t.elements.playPausePanelContainer = w(
                e,
                "--mcp-play-pause-panel-container"
              )),
              (t.elements.listenerHelper = w(e, "--mcp-listener-helper")),
              (t.elements.loopBar = w(e, "--mcp-loopbar")),
              (t.elements.totalBar = w(e, "--mcp-totalbar")),
              (t.elements.indicator = w(e, "--mcp-indicator")),
              (t.elements.loopButton = w(e, "--mcp-loop-btn")),
              (t.elements.volumeBar = w(e, "--mcp-volumebar")),
              (t.elements.totalTime = w(e, "--mcp-time-total")),
              (t.elements.volumeControl = w(e, "--mcp-volume")),
              (t.elements.volumeBtn = w(e, "--mcp-volume-btn")),
              (t.elements.runningBar = w(e, "--mcp-runningbar")),
              (t.elements.loopBarEnd = w(e, "--mcp-loopbar-end")),
              (t.elements.statusButton = w(e, "--mcp-status-btn")),
              (t.elements.speedBar = w(e, "--mcp-speed-values")),
              (t.elements.currentTime = w(e, "--mcp-time-current")),
              (t.elements.timeDisplay = w(e, "--mcp-time-display")),
              (t.elements.speedButtonShow = w(e, "--mcp-speed-btn-show")),
              (t.elements.speedButtonHide = w(e, "--mcp-speed-btn-hide")),
              (t.elements.speedCurrent = w(e, "--mcp-speed-current")),
              (t.elements.loopBarStart = w(e, "--mcp-loopbar-start")),
              (t.elements.volumeCursor = w(e, "--mcp-volume-cursor")),
              (t.elements.settingsButton = w(e, "--mcp-settings-btn")),
              (t.elements.donkeyclipButton = w(e, "--mcp-dc-btn")),
              (t.elements.timeSeparator = w(e, "--mcp-time-separator")),
              (t.elements.settingsPanel = w(e, "--mcp-settings-panel")),
              (t.elements.background = w(e, "--mcp-background")),
              (t.elements.settingsMainPanel = w(e, "--mcp-main-settings")),
              (t.elements.fullScreenButton = w(e, "--mcp-full-screen-btn")),
              (t.elements.context = w(e, "--mcp-context")),
              (t.elements.volumeBarHelper = w(e, "--mcp-volumebar")),
              (t.elements.volumeBarActive = w(
                e,
                "--mcp-volumebar-color-active"
              )),
              (t.elements.settingsSpeedPanel = w(e, "--mcp-speed-settings")),
              (t.elements.settingsShowVolume = w(e, "--mcp-settings-volume")),
              (t.elements.settingsPointerEvents = w(
                e,
                "--mcp-settings-pointer-events"
              )),
              (t.elements.settingsSpeedButtonShow = w(
                e,
                "--mcp-settings-speed-show"
              )),
              (t.elements.settingsSpeedButtonHide = w(
                e,
                "--mcp-settings-speed-hide"
              )),
              (t.elements.controls = w(e, "--mcp-controls")),
              (t.elements.volumeCheckbox = w(e, "--mcp-show-volume-checkbox")),
              (t.elements.showVolumeCheckbox = w(
                e,
                "--mcp-show-volume-checkbox"
              )),
              (t.elements.showPointerEventsCheckbox = w(
                e,
                "--mcp-show-pointer-events-checkbox"
              )),
              (t.elements.leftButtons = w(e, "--mcp-left-buttons")),
              ((s = t.elements).loopButton.innerHTML = n.loop),
              (s.volumeBtn.innerHTML = n["volume-on"]),
              (s.statusButton.innerHTML = n.play),
              (s.settingsButton.innerHTML = n.settings),
              (s.donkeyclipButton.innerHTML = n["donkeyclip-logo"]),
              (s.fullScreenButton.innerHTML = n["expand-full"]),
              (s.speedButtonShow.innerHTML = n["angle-right"]),
              (s.speedButtonHide.innerHTML = n["angle-left"]),
              L(t),
              j(t),
              V(t);
          };
          const B = (t) => {
              const e = t.clip.props.host;
              if (
                (e.offsetWidth ||
                  (e.style.width = t.clip.props.containerParams.width),
                e.offsetHeight ||
                  (e.style.height = t.clip.props.containerParams.height),
                (e.style.display = "flex"),
                (e.style.justifyContent = "center"),
                (e.style.alignItems = "center"),
                (e.style.overflow = "hidden"),
                (t.clip.props.host.style.position = "relative"),
                (t.clip.props.host.style.zIndex = 0),
                (t.elements.mcPlayer = t.document.createElement("div")),
                (t.elements.mcPlayer.id = `${t.name}`),
                (t.elements.mcPlayer.className = `${t.className}`),
                (t.elements.mcPlayer.innerHTML =
                  '<div class="--mcp-background"></div> <div class="--mcp-context" tabindex="0"> <div class="--mcp-pointer-events-panel"></div> <div class="--mcp-play-pause-panel"> <div class="--mcp-play-pause-panel-container"></div> </div> <div class="--mcp-listener-helper"></div> <div class="--mcp-controls"> <div class="--mcp-grad"></div> <div class="--mcp-progressbar"> <div class="--mcp-totalbar"> <div class="--mcp-loopbar"> <div class="--mcp-loopbar-color"></div> <div class="--mcp-loop-boundaries --mcp-loopbar-start"> <span></span> </div> <div class="--mcp-loop-boundaries --mcp-loopbar-end"> <span></span> </div> <div class="--mcp-runningbar"> <div class="--mcp-cursor"></div> </div> </div> </div> </div> <div class="--mcp-buttons"> <div class="--mcp-left-buttons"> <div class="--mcp-status"> <span class="--mcp-btn --mcp-status-btn icon-play"></span> <span class="--mcp-indicator">i</span> </div> <div class="--mcp-volume"> <div class="--mcp-btn --mcp-volume-btn icon-volume-on"></div> <div class="--mcp-volumebar"> <div class="--mcp-volumebar-color"> <div class="--mcp-volumebar-color-active"> <div class="--mcp-volume-cursor"></div> </div> </div> </div> </div> <div class="--mcp-time-display"> <span class="--mcp-time-current">00:00</span> <span class="--mcp-time-separator">/</span> <span class="--mcp-time-total">00:00</span> </div> </div> <div class="--mcp-right-buttons"> <div class="--mcp-loop-btn-container"> <div class="--mcp-btn --mcp-loop-btn icon-loop"></div> </div> <div class="--mcp-btn --mcp-settings-btn icon-settings"></div> <div class="--mcp-btn --mcp-dc-btn icon-donkeyclip-logo"></div> <div class="--mcp-btn --mcp-full-screen-btn icon-expand-full"></div> </div> </div> </div> <div class="--mcp-settings-panel" tabindex="0"> <ul class="--mcp-main-settings"> <li class="--mcp-settings-pointer-events"> <p>Pointer events</p> <div> <div class="switch settings-switch"> <input class="--mcp-show-pointer-events-checkbox" type="checkbox"> <span class="slider round"></span> </div> </div> </li> <li class="--mcp-settings-volume"> <p>Show volume</p> <div> <div class="switch settings-switch"> <input class="--mcp-show-volume-checkbox" type="checkbox"> <span class="slider round"></span> </div> </div> </li> <li class="--mcp-settings-speed-show"> <p>Playback speed</p> <div> <span class="--mcp-speed-current"></span> <div class="--mcp-btn --mcp-speed-btn --mcp-speed-btn-show icon-angle-right"></div> </div> </li> </ul> <ul class="--mcp-speed-settings"> <li class="--mcp-settings-speed-hide"> <div class="--mcp-btn --mcp-speed-btn --mcp-speed-btn-hide icon-angle-left"></div> <p class="--mcp-speed-runtime">Playback speed</p> </li> <li class="--mcp-no-hover"> <ul class="--mcp-speed-values"></ul> </li> </ul> </div> </div> '),
                "string" == typeof t.options.host)
              ) {
                const e = t.document.querySelectorAll(t.options.host);
                for (const n in e)
                  isNaN(n) || e[n].appendChild(t.elements.mcPlayer);
              } else t.options.host.appendChild(t.elements.mcPlayer);
            },
            L = (t) => {
              (t.elements.volumeBarActive.style.width =
                100 * t.settings.volume + "%"),
                (t.elements.currentTime.innerHTML = t.timeFormat(0)),
                (t.elements.totalTime.innerHTML = t.timeFormat(
                  t.clip.duration
                )),
                (t.elements.timeSeparator.innerHTML = "/"),
                t.elements.settingsPanel.classList.add(
                  "m-fadeOut",
                  `${t.name}-hide`
                ),
                t.options.backgroundColor &&
                  (t.elements.background.style.background =
                    t.options.backgroundColor),
                "scroller" === t.options.type &&
                  (window.document.body.style.overscrollBehaviorY = "contain"),
                t.options.showIndicator
                  ? ((t.elements.indicator.style.display = void 0),
                    (t.elements.statusButton.style.width = "35px"),
                    (t.elements.statusButton.style.height = "20px"),
                    (t.elements.statusButton.style.bottom = "5px"))
                  : (t.elements.indicator.style.display = "none"),
                (t.elements.indicator.innerHTML = t.clip.runTimeInfo.state),
                (t.elements.settingsSpeedPanel.style.display = "none"),
                t.elements.loopBarStart.classList.add(
                  "m-fadeOut",
                  `${t.name}-hide`
                ),
                t.elements.loopBarEnd.classList.add(
                  "m-fadeOut",
                  `${t.name}-hide`
                ),
                (t.elements.volumeCheckbox.checked = t.options.showVolume),
                (t.elements.showPointerEventsCheckbox.checked =
                  t.options.pointerEvents),
                t.options.pointerEvents
                  ? (t.elements.pointerEventPanel.style.pointerEvents = "none")
                  : (t.elements.pointerEventPanel.style.pointerEvents = "auto"),
                t.options.showVolume ||
                  t.elements.volumeControl.classList.toggle("m-fadeOut");
            },
            j = (t) => {
              for (const e in t.options.speedValues) {
                if (0 == t.options.speedValues[e]) continue;
                const n = "check-solid",
                  s = "--mcp-selected",
                  i = t.document.createElement("li");
                (i.className = "--mcp-speed-value"),
                  (i.dataset.speedValue = t.options.speedValues[e]);
                const r = t.document.createElement("span");
                i.append(r);
                const o = t.document.createElement("p"),
                  a = 1 == t.options.speedValues[e];
                (o.innerHTML = a ? "Normal" : t.options.speedValues[e]),
                  (o.dataset.zone = e),
                  o.classList.add("--mcp-speed-value-item"),
                  (t.options.speedValues[e] == t.options.speed ??
                    t.clip.speed) &&
                    (A(r, null, n), o.classList.add(s)),
                  i.append(o),
                  t.elements.speedBar.append(i),
                  (i.onclick = function () {
                    (t.options.speed = t.options.speedValues[e]),
                      (t.clip.speed = t.options.speedValues[e]),
                      (t.elements.speedCurrent.innerHTML =
                        1 == t.clip.speed ? "Normal" : t.clip.speed),
                      A(w(t.elements.mcPlayer, "icon-check-solid"), n),
                      A(r, null, n),
                      w(t.elements.mcPlayer, s).classList.remove(s),
                      o.classList.add(s);
                  });
              }
            },
            V = (t) => {
              !1 === t.options.buttons.fullScreen &&
                t.elements.fullScreenButton.remove(),
                !1 === t.options.buttons.settings &&
                  t.elements.settingsButton.remove(),
                t.options.buttons.donkeyclip ||
                  t.elements.donkeyclipButton.remove(),
                !1 === t.options.buttons.loop && t.elements.loopButton.remove();
            },
            N = "--mcp-force-show-controls",
            $ = "playing",
            R = "volume-off",
            F = "volume-on";
          var z =
            '.--mc-player.theme-default{--activeColor:136,136,136;--defaultColor:255,255,255;--backgroundColor:29,31,37,1;--backgroundSettingsColor:rgba(29,31,37,0.9);--loopBarColor:rgba(var(--activeColor),0.2);--grad-display:none;--grad-color:0,0,0}.--mc-player.theme-yellow{--activeColor:255,235,59;--defaultColor:255,255,255;--backgroundColor:29,31,37,1;--backgroundSettingsColor:rgba(29,31,37,0.9);--loopBarColor:rgba(var(--activeColor),0.2);--grad-display:none;--grad-color:0,0,0}.--mc-player.theme-dark{--activeColor:136,136,136;--defaultColor:136,136,136;--backgroundColor:0,0,0,1;--backgroundSettingsColor:rgba(0,0,0,0.9);--loopBarColor:rgba(var(--activeColor),0.2);--grad-display:none;--grad-color:0,0,0}.--mc-player.theme-whiteGold{--activeColor:161,127,26;--defaultColor:136,136,136;--backgroundColor:245,245,245,1;--backgroundSettingsColor:hsla(0,0%,96%,0.9);--loopBarColor:rgba(var(--activeColor),0.2);--grad-display:none;--grad-color:0,0,0}.--mc-player.theme-darkGold{--activeColor:161,127,26;--defaultColor:136,136,136;--backgroundColor:0,0,0,1;--backgroundSettingsColor:rgba(0,0,0,0.9);--loopBarColor:rgba(var(--activeColor),0.2);--grad-display:none;--grad-color:0,0,0}.--mc-player.theme-transparent{--activeColor:255,0,0;--defaultColor:239,238,236;--backgroundColor:0,0,0,0;--backgroundSettingsColor:rgba(0,0,0,0.9);--loopBarColor:rgba(var(--defaultColor),0.2);--grad-display:block;--grad-color:0,0,0}.--mc-player.theme-green{--activeColor:0,184,139;--defaultColor:255,255,255;--backgroundColor:29,31,37,1;--backgroundSettingsColor:rgba(29,31,37,0.9);--loopBarColor:rgba(var(--activeColor),0.2);--grad-display:none;--grad-color:0,0,0}.--mc-player.theme-blue{--activeColor:0,153,225;--defaultColor:255,255,255;--backgroundColor:29,31,37,1;--backgroundSettingsColor:rgba(29,31,37,0.9);--loopBarColor:rgba(var(--activeColor),0.2);--grad-display:none;--grad-color:0,0,0}.--mc-player.theme-donkeyclip{--activeColor:0,153,225;--defaultColor:255,255,255;--backgroundColor:0,0,0,0;--backgroundSettingsColor:rgba(29,31,37,0.9);--loopBarColor:rgba(var(--activeColor),0.2);--grad-display:block;--grad-color:24,25,29}.--mc-player.theme-donkeyclipDark{--activeColor:0,153,225;--defaultColor:255,255,255;--backgroundColor:0,0,0,0;--backgroundSettingsColor:rgba(29,31,37,0.9);--loopBarColor:rgba(var(--activeColor),0.2);--grad-display:block;--grad-color:22,22,26}.--mc-player,.--mc-player *{user-select:none!important;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none}.--mc-player *{box-sizing:border-box;color:rgb(var(--defaultColor));cursor:default;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol;font-size:13px}.--mc-player svg{width:22px}.--mcp-settings-panel:focus{outline:none}.--mc-player *{outline:none!important}.--mcp-settings-panel svg{width:10px}.--mc-player svg,.--mc-player svg *{fill:rgb(var(--defaultColor))!important}.--mc-player{left:0;overscroll-behavior:none;top:0}.--mc-player,.--mcp-background,.--mcp-context{height:100%;pointer-events:none;position:absolute;width:100%}.--mcp-background,.--mcp-context{display:flex;flex-direction:column}.--mcp-background{background:#000;z-index:-1000}.--mcp-pointer-events-panel.initial{min-height:100%;width:100%;z-index:100}.--mcp-pointer-events-panel{min-height:calc(100% - 50px);width:100%}.--mcp-pointer-events-panel.loading{align-items:center;background:rgba(0,0,0,.8);display:flex;justify-content:center}.--mcp-grad{background-image:linear-gradient(rgba(var(--grad-color),.001),rgba(var(--grad-color),.004),rgba(var(--grad-color),.007),rgba(var(--grad-color),.01),rgba(var(--grad-color),.04),rgba(var(--grad-color),.07),rgba(var(--grad-color),.1),rgba(var(--grad-color),.15),rgba(var(--grad-color),.2),rgba(var(--grad-color),.25),rgba(var(--grad-color),.3),rgba(var(--grad-color),.35),rgba(var(--grad-color),.4),rgba(var(--grad-color),.45),rgba(var(--grad-color),.5),rgba(var(--grad-color),.55),rgba(var(--grad-color),.6),rgba(var(--grad-color),.65),rgba(var(--grad-color),.7),rgba(var(--grad-color),.75),rgba(var(--grad-color),.8),rgba(var(--grad-color),.88));bottom:0;display:var(--grad-display);height:200px;left:0;pointer-events:none!important;position:absolute;width:100%;z-index:0}.--mc-player:hover .--mcp-controls,.--mcp-controls:active{opacity:1!important}.--mcp-controls{background:rgba(var(--backgroundColor));display:flex;flex-direction:column;height:50px;opacity:0;padding:0 15px;pointer-events:auto;position:relative;transition:all .2s ease;z-index:0}.--mcp-controls *{-webkit-user-select:none!important;-moz-user-select:none!important;user-select:none!important}.--mcp-play-pause-panel #play-svg{margin-left:4px}.--mcp-always-show-controls,.--mcp-force-show-controls{opacity:1!important}.--mcp-progressbar{align-items:center;display:flex;justify-content:center;position:relative}.--mcp-loopbar,.--mcp-runningbar,.--mcp-totalbar{height:5px;position:relative}.--mcp-cursor{background-color:rgb(var(--activeColor));border-radius:100%;height:14px;position:absolute;right:-8px;top:-5px;width:14px;z-index:10}.--mcp-totalbar{background-color:rgba(var(--defaultColor),.3);min-width:100%}.--mcp-loopbar{padding:10px 0;position:relative;top:-10px;width:100%}.--mcp-loopbar-color{background-color:var(--loopBarColor);bottom:5px;height:5px;left:0;position:absolute;width:100%}.--mcp-runningbar{background-color:rgb(var(--activeColor));width:0}.--mcp-buttons,.--mcp-left-buttons,.--mcp-left-buttons>div,.--mcp-right-buttons,.--mcp-right-buttons>div{align-items:center;display:flex;gap:5px;z-index:1}.--mcp-left-buttons{flex:1}.--mcp-buttons,.--mcp-left-buttons,.--mcp-right-buttons{gap:20px;height:100%}.--mcp-left-buttons{justify-content:flex-start}.--mcp-right-buttons{justify-content:flex-end}.--mcp-prevent-point-events{z-index:100}.--mcp-play-pause-panel,.--mcp-prevent-point-events{height:100%;left:0;position:absolute;top:0;width:100%}.--mcp-play-pause-panel{align-items:center;background-position:50%!important;background-repeat:no-repeat!important;background-size:contain!important;display:flex;justify-content:center;pointer-events:none;z-index:2}.--mcp-play-pause-panel.initial{background-color:#000}.--mcp-play-pause-panel.initial svg{height:32px;width:32px}.--mcp-play-pause-panel.initial .--mcp-play-pause-panel-container{height:80px;width:80px}.--mcp-play-pause-panel.hide{opacity:0}.run-animation-play{animation:scale-and-opaque .8s 1}.run-animation-pause{animation:scale-and-opaque1 .8s 1}.run-animation-idle{animation:scale-and-opaque2 .8s 1}.--mcp-play-pause-panel-container{align-items:center;background-color:#000000c7;border-radius:100%;display:flex;height:60px;justify-content:center;width:60px}.--mcp-play-pause-panel .--mcp-play-pause-panel-container{animation-duration:.8s;transform-origin:center center}@keyframes scale-and-opaque{0%{opacity:.5;transform:scale(1)}to{opacity:0;transform:scale(2)}}@keyframes scale-and-opaque1{0%{opacity:.5;transform:scale(1)}to{opacity:0;transform:scale(2)}}@keyframes scale-and-opaque2{0%{opacity:.5;transform:scale(1)}to{opacity:0;transform:scale(2)}}.--mcp-loop-boundaries{display:flex!important;position:relative}.--mcp-loop-boundaries span{background-color:#aeaeae;border-radius:100%;height:13px;left:-6px;position:absolute;top:-4px;width:13px;z-index:100}.--mcp-loopbar-start{left:0}.--mcp-loopbar-end{left:100%}.--mc-player svg,.--mc-player svg *,.--mcp-btn,.--mcp-cursor,.--mcp-loop-boundaries,.--mcp-loopbar,.--mcp-loopbar-color,.--mcp-runningbar,.--mcp-status-btn,.--mcp-volume *{cursor:pointer}.--mcp-btn{font-size:20px}.--mcp-btn,.--mcp-status-btn{align-items:center;display:flex;justify-content:center}.--mcp-status-btn{gap:3px}.--mcp-indicator{font-size:12px}.--mcp-listener-helper{pointer-events:none}.--mcp-volume-btn{font-size:15px}.--mcp-volumebar{align-items:center;display:flex;height:100%;justify-content:center;padding-left:0;padding-right:0;transition:all .2s ease;width:0}.--mcp-volume{height:100%}.--mcp-volume:hover{padding-right:10px}.--mcp-volume:active .--mcp-volumebar,.--mcp-volume:hover .--mcp-volumebar{padding-left:5px;width:52px}.--mcp-volume:active .--mcp-volume-cursor,.--mcp-volume:hover .--mcp-volume-cursor{display:block}.--mcp-btn:before{color:var(--defaultColor)!important}.--mcp-btn:before:hover{filter:brightness(40)}.--mcp-settings-speed-hide{border-bottom:1px solid hsla(0,0%,100%,.2)}ul.--mcp-speed-values{align-items:center;display:flex;justify-content:center;padding:0}ul.--mcp-speed-values li,ul.--mcp-speed-values li p{width:100%}.--mcp-settings-panel ul{display:flex;flex:1;flex-direction:column;list-style-type:none;margin:0;padding:5px 0}.--mcp-settings-panel ul li{align-items:center;cursor:pointer;display:flex;flex:1;min-height:40px;padding:0 21px}.--mcp-settings-panel ul li *{cursor:pointer}.--mcp-settings-panel ul li:not(.--mcp-no-hover):hover{background-color:rgba(var(--activeColor),.2)}.--mcp-settings-panel ul li>div{align-items:center;display:flex;flex:1;gap:10px;justify-content:flex-end;width:48px}.--mcp-settings-panel{background-color:var(--backgroundSettingsColor);bottom:60px;pointer-events:auto;position:absolute;right:15px;transition:all .2s ease;width:251px;z-index:1000}.--mcp-speed-values{padding:0}.--mcp-no-hover{padding:0!important}.--mcp-speed-value-item:not(.--mcp-selected){padding-left:15px}.--mcp-speed-value-item.--mcp-selected{padding-left:10px}.--mcp-speed-value .icon-check-solid{margin-left:-5px}.--mcp-settings-panel ul.--mcp-speed-settings li>div{flex:unset;justify-content:flex-start;width:20px}.--mcp-main-settings ul li>p{align-items:center;display:flex;flex:1;padding-left:10px}.--mc-player .switch{display:inline-block;height:14px;position:relative;width:36px}.--mc-player .switch input{display:none}.--mc-player .settings-switch:after{clear:both}.--mc-player .slider{background-color:#999;bottom:0;cursor:pointer;left:0;position:absolute;right:0;top:0;transition:.4s}.--mc-player .slider:before{background-color:#cfcfcf;bottom:-3px;content:"";height:20px;left:0;position:absolute;transition:.4s;width:20px}.--mc-player input:checked+.slider{background-color:rgb(var(--activeColor))}.--mc-player input:focus+.slider{box-shadow:0 0 1px rgb(var(--activeColor))}.--mc-player input:checked+.slider:before{background-color:#fff;transform:translateX(16px)}.--mc-player .slider.round{border-radius:34px}.--mc-player .slider.round:before{border-radius:50%}.--mc-player .m-fadeOut{display:none!important;opacity:0!important;visibility:hidden!important}.--mc-player .m-fadeIn{display:unset;opacity:1!important;visibility:visible!important}.--mcp-volume-cursor{background-color:rgb(var(--defaultColor));border-radius:100%;display:none;height:14px;position:absolute;right:-8px;width:14px}.--mcp-volumebar-color{background-color:rgba(var(--defaultColor),.3);height:3px;width:100%}.--mcp-volumebar-color-active{align-items:center;background-color:rgb(var(--defaultColor));display:flex;height:100%;justify-content:center;position:relative;width:100%}.lds-ring{aspect-ratio:1/1;display:inline-block;max-width:64px;position:relative;width:18%}.lds-ring div{animation:lds-ring 1.5s cubic-bezier(.5,.5,.5,.8) infinite;aspect-ratio:1/1;border:3px solid transparent;border-radius:50%;border-top-color:#fff;box-sizing:border-box;display:block;margin:3px;position:absolute;width:100%}.lds-ring div:first-child{animation-delay:-.3s}.lds-ring div:nth-child(2){animation-delay:-.2s}.lds-ring div:nth-child(3){animation-delay:-.1s}@keyframes lds-ring{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}';
          function X(t) {
            (t.settings.loopActivated = !t.settings.loopActivated),
              t.eventBroadcast(o, t.settings.loopActivated),
              t.elements.loopButton.classList.toggle("svg-selected"),
              t.elements.loopBarStart.classList.toggle("m-fadeOut"),
              t.elements.loopBarEnd.classList.toggle("m-fadeOut"),
              t.elements.loopBarStart.classList.toggle("m-fadeIn"),
              t.elements.loopBarStart.classList.toggle(`${t.name}-hide`),
              t.elements.loopBarEnd.classList.toggle("m-fadeIn"),
              t.elements.loopBarEnd.classList.toggle(`${t.name}-hide`),
              (t.settings.needsUpdate = !0),
              t.settings.loopActivated ||
                ((t.elements.loopBar.style.left = "0%"),
                (t.elements.loopBar.style.width = "100%"),
                (t.settings.loopStartMillisecond = 0),
                (t.settings.loopEndMillisecond = t.clip.duration),
                (t.settings.loopLastPositionXPxls = 0),
                (t.settings.loopLastPositionXPercentage = 0),
                (t.elements.runningBar.style.width =
                  (t.clip.runTimeInfo.currentMillisecond / t.clip.duration) *
                    100 +
                  "%"));
          }
          const H = (t) => {
              t.elements.showPointerEventsCheckbox.checked
                ? ((t.elements.showPointerEventsCheckbox.checked = !1),
                  (t.elements.mcPlayer.style.pointerEvents = "none"),
                  (t.elements.pointerEventPanel.style.pointerEvents = "auto"),
                  (t.elements.controls.style.pointerEvents = "auto"),
                  (t.elements.settingsPanel.style.pointerEvents = "auto"))
                : ((t.elements.showPointerEventsCheckbox.checked = !0),
                  (t.options.pointerEvents = !1),
                  (t.elements.mcPlayer.style.pointerEvents = "none"),
                  (t.elements.pointerEventPanel.style.pointerEvents = "none"),
                  (t.elements.controls.style.pointerEvents = "auto"),
                  (t.elements.settingsPanel.style.pointerEvents = "auto")),
                t.eventBroadcast(
                  "show-pointer-events-change",
                  t.elements.showPointerEventsCheckbox.checked
                );
            },
            Y = (t) => {
              t.elements.volumeControl.classList.toggle("m-fadeOut"),
                t.elements.showVolumeCheckbox.checked
                  ? (t.elements.showVolumeCheckbox.checked = !1)
                  : (t.elements.showVolumeCheckbox.checked = !0),
                t.eventBroadcast(l, t.elements.showVolumeCheckbox.checked);
            };
          function U(t, e, n) {
            const r = t.elements;
            void 0 !== n &&
              (!1 === n
                ? ((r.volumeBarActive.style.width =
                    100 * t.settings.volume + "%"),
                  t.clip.setVolume(t.settings.previousVolume),
                  (t.settings.volumeMute = !1),
                  A(r.volumeBtn, R, F))
                : !0 === n &&
                  ((t.settings.volumeMute = !0),
                  (r.volumeBarActive.style.width = "0%"),
                  t.clip.setVolume(0),
                  A(r.volumeBtn, F, R)),
              (t.options.muted = t.settings.volumeMute),
              t.eventBroadcast(i, t.settings.volumeMute)),
              void 0 !== e &&
                ((t.settings.volume = e),
                t.settings.volume > 0 && (t.settings.previousVolume = e),
                (r.volumeBarActive.style.width = 100 * t.settings.volume + "%"),
                t.clip.setVolume(t.settings.volume),
                t.settings.volume > 0
                  ? ((t.settings.volumeMute = !1), A(r.volumeBtn, R, F))
                  : 0 === t.settings.volume &&
                    ((t.settings.volumeMute = !0), A(r.volumeBtn, F, R)),
                (t.options.volume = t.settings.volume),
                t.eventBroadcast(s, t.settings.volume),
                t.eventBroadcast(i, t.settings.volumeMute));
          }
          const W = { passive: !0 };
          var q = (t) => {
            C(window, "wheel", (e) => {
              t.stepper(e.deltaY);
            }),
              C(
                window,
                "touchmove",
                (e) => {
                  const n = e.touches[0].clientY;
                  t.lastY ??= n;
                  const s = -(n - t.lastY);
                  t.stepper(s), (t.lastY = n);
                },
                W
              ),
              C(
                window,
                "touchend",
                () => {
                  t.lastY = null;
                },
                W
              ),
              C(
                window,
                "touchstart",
                () => {
                  t.cancelAnimation(), (t.lastY = null);
                },
                W
              );
          };
          const G = {
            default: "theme-default",
            transparent: "theme-transparent",
            whiteGold: "theme-whiteGold",
            darkGold: "theme-darkGold",
            green: "theme-green",
            blue: "theme-blue",
            dark: "theme-dark",
            yellow: "theme-yellow",
            donkeyclip: "theme-donkeyclip",
            donkeyclipDark: "theme-donkeyclipDark",
          };
          function Z(t) {
            A(t, "spinner", null), t.classList.remove("loading");
          }
          const K = [];
          return class {
            constructor(t) {
              (this.elements = {}),
                (this.clip = t.clip),
                (this.options = T(t, this)),
                (this.document = this.options.host.ownerDocument),
                (this.className = e),
                (this.id = this.options.id),
                (this.name = e),
                (this.clipClass = t.clipClass),
                (this.state = this.clip.runTimeInfo.state),
                (this.listeners = {}),
                (this.settings = {
                  volume: 1,
                  journey: null,
                  previousVolume: 1,
                  volumeMute: !1,
                  needsUpdate: !0,
                  resizeLoop: !1,
                  loopJourney: !1,
                  loopActivated: !1,
                  requestingLoop: !1,
                  playAfterResize: !1,
                  loopStartMillisecond: 0,
                  loopLastPositionXPxls: 0,
                  loopLastPositionXPercentage: 0,
                  loopEndMillisecond: this.clip.duration,
                  controls: !0,
                }),
                D(this),
                this.setTheme(),
                this.setSpeed(),
                this.subscribeToTimer(),
                this.subscribeToDurationChange(),
                this.addEventListeners(),
                this.scaleClipHost(),
                this.eventBroadcast(c, this.state),
                "scroller" === this.options.type &&
                  ((this.timeBucket = 0),
                  (this.timeProgress = 0),
                  this.options.sections?.sort(_));
              const n = new ResizeObserver(() => {
                window.innerWidth < 450
                  ? (this.elements.timeDisplay.style.display = "none")
                  : (this.elements.timeDisplay.style.display = "block"),
                  this.options.scaleToFit && this.scaleClipHost();
              });
              this.changeSettings(t, !0),
                n.observe(this.options.host),
                this.options.autoPlay && this.play(),
                (window.clip = this.clip);
            }
            play() {
              this.clip.play();
            }
            pause() {
              this.clip.pause();
            }
            enterFullScreen() {
              g(this.clip.props.host);
            }
            exitFullScreen() {
              f();
            }
            changeSettings(t, e) {
              (t = T(Object.assign({}, this.options, t), this)).clip !==
                this.options.clip &&
                ((e = !0), (this.clip = t.clip), (this.options.clip = t.clip)),
                !1 === t.controls
                  ? (this.elements.mcPlayer.style.display = "none")
                  : !0 === t.controls &&
                    (this.elements.mcPlayer.style.display = "block");
              const n = {
                  loop: () => X(this),
                  fullscreen: () => y(this),
                  muted: () => U(this, void 0, t.mute),
                  volume: () => U(this, t.volume),
                  speed: () =>
                    (function (t, e) {
                      (e = parseFloat(e) || 1), t.eventBroadcast(r, e);
                      const n = 1 == e ? "Normal" : e;
                      (t.clip.executionSpeed = e),
                        (t.elements.speedCurrent.innerHTML = n);
                    })(this, t.speed),
                  scaleToFit: () => {
                    (this.options.scaleToFit = t.scaleToFit),
                      this.scaleClipHost();
                  },
                  showVolume: () => (
                    this,
                    void ("showPointerEvents" == "showVolume"
                      ? H(this)
                      : Y(this))
                  ),
                  type: () => {
                    "scroller" === t.type && q(this);
                  },
                  theme: () => {
                    (this.options.theme = t.theme), this.setTheme();
                  },
                  overflow: () => {
                    this.clip.props.host.shadowRoot.children[0].style.overflow =
                      t.overflow;
                  },
                  outline: () => {
                    this.clip.props.host.shadowRoot.children[0].style.outline =
                      t.outline;
                  },
                  visible: () => {
                    "always" == t.visible
                      ? this.elements.controls.classList.add(
                          "--mcp-always-show-controls"
                        )
                      : "normal" == t.visible &&
                        this.elements.controls.classList.remove(
                          "--mcp-always-show-controls"
                        );
                  },
                },
                s = [
                  "fullscreen",
                  "muted",
                  "volume",
                  "speed",
                  "scaleToFit",
                  "loop",
                  "overflow",
                  "outline",
                  "visible",
                ];
              for (const i in n)
                void 0 !== t[i] &&
                  (this.options[i] !== t[i] ||
                    (e && !1 !== this.options[i] && s.includes(i))) &&
                  n[i]();
              this.options = Object.assign({}, this.options, t);
            }
            scaleClipHost() {
              if (this.options.scaleToFit) {
                const t = this.clip.props,
                  e = (function (t, e) {
                    let n,
                      s,
                      i =
                        arguments.length > 2 &&
                        void 0 !== arguments[2] &&
                        arguments[2];
                    if (!t) return { scale: 1, position: {} };
                    t.width && (n = E(t.width)), t.height && (s = E(t.height));
                    let r = 1,
                      o = 1;
                    "px" === n?.unit &&
                      n.number !== e.width &&
                      (r = e.width / n.number),
                      "px" === s?.unit &&
                        s.number !== e.height &&
                        (o = e.height / s.number);
                    const a = (i ? o > r : o <= r) ? o : r,
                      l = {};
                    if (null != n) {
                      let t = n.number * a;
                      "px" !== n.unit && (t *= e.width / 100);
                      const s = e.width - t;
                      l.left = s / 2;
                    }
                    if (null != s) {
                      let t = s.number * a;
                      "px" !== s.unit && (t *= e.height / 100);
                      const n = e.height - t;
                      l.top = n / 2;
                    }
                    return { scale: a, position: l };
                  })(
                    t.containerParams,
                    {
                      width: t.host.offsetWidth,
                      height:
                        t.host.offsetHeight -
                        ("always" == this.options.visible ? 50 : 0),
                    },
                    "cover" === this.options.scaleToFit
                  );
                (this.clip.realClip.rootElement.style.transform = `scale(${e.scale}`),
                  (this.clip.realClip.rootElement.style.left = `${e.position.left}px`),
                  (this.clip.realClip.rootElement.style.top = `${e.position.top}px`);
              } else
                (this.clip.realClip.rootElement.style.transform = "scale(1)"),
                  (this.clip.realClip.rootElement.style.left = "0px"),
                  (this.clip.realClip.rootElement.style.top = "0px");
              this.eventBroadcast(a, this.options.scaleToFit);
            }
            goToMillisecond(t) {
              let { before: e, after: n } =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : {};
              t > this.clip.duration
                ? (t = this.clip.duration)
                : t < 0 && (t = 0),
                setTimeout(() => {
                  const s = this.clip;
                  s.id &&
                    (e && s[e](),
                    (this.settings.journey = b.startJourney(s)),
                    this.settings.journey.station(t),
                    this.settings.journey.destination(),
                    n && s[n]());
                }, 0);
            }
            createLoop(t, e) {
              (this.settings.loopStartMillisecond = t),
                (this.settings.loopEndMillisecond = e),
                (this.elements.loopBar.style.left =
                  (t / this.clip.duration) * 100 + "%"),
                (this.elements.loopBar.style.width =
                  ((e - t) / this.clip.duration) * 100 + "%"),
                this.goToMillisecond(t),
                (this.elements.runningBar.style.width = "0%"),
                !this.settings.loopActivated && X(this);
            }
            calculateMinMaxOfTimeProgress() {
              this.timeProgress >= this.clip.duration &&
                (this.timeProgress = this.clip.duration),
                this.timeProgress <= 0 && (this.timeProgress = 0);
            }
            requestAnimation() {
              this.requestAnimationID = window.requestAnimationFrame(
                this.animateTimeBucket.bind(this)
              );
            }
            cancelAnimation() {
              window.cancelAnimationFrame(this.requestAnimationID),
                (this.requestAnimationID = null);
            }
            removeTimeFromBucket() {
              const t = Math.log(this.timeBucket),
                e = Math.pow(t, 2);
              return (
                (this.timeBucket -= this.options.scrollAnimation ? t : e), e
              );
            }
            addTimeToProgress(t) {
              this.timeProgress += t * this.multiplier * this.clip.speed;
            }
            checkIfBucketHasTime() {
              return !(
                this.timeBucket <= 0 && ((this.requestAnimationID = null), 1)
              );
            }
            calculateJourneyPosition(e) {
              const n = t.utils.easings[this.options.sectionsEasing](e);
              return (
                this.startPosition +
                n * this.options.speed * this.multiplier * this.endAnimationTime
              );
            }
            animateTimeBucket() {
              if (this.checkIfBucketHasTime) {
                if (
                  (this.addTimeToProgress(this.removeTimeFromBucket()),
                  this.calculateMinMaxOfTimeProgress(),
                  this.options.sections)
                ) {
                  const t =
                    (Date.now() - this.startAnimationTime) /
                    this.endAnimationTime;
                  if (t >= 1 || 0 === this.endAnimationTime)
                    return this.cancelAnimation();
                  const e = this.calculateJourneyPosition(t);
                  this.goToMillisecond(Math.ceil(e));
                } else this.goToMillisecond(this.timeProgress);
                this.requestAnimation();
              }
            }
            setUpTimeBucket(t) {
              const e = t > 0 ? 1 : -1;
              (t = Math.ceil(Math.abs(t)) * e),
                (this.timeBucket += Math.abs(t)),
                e != this.multiplier && (this.timeBucket = Math.abs(t)),
                this.timeBucket > this.options.maxScrollStorage &&
                  (this.timeBucket = this.options.maxScrollStorage),
                (this.multiplier = e);
            }
            getSectionTime(t) {
              let e;
              const n = this.options.sections;
              if (t > 0) {
                const t = this.startPosition + this.timeBucket;
                for (let s = 0; s < n.length; s++)
                  if (t < n[s]) {
                    e = s;
                    break;
                  }
                e ??= n.length - 1;
              } else {
                const t = this.startPosition - this.timeBucket;
                for (let s = n.length - 1; s >= 0; s--)
                  if (t > n[s]) {
                    e = s;
                    break;
                  }
                e ??= 0;
              }
              return e;
            }
            initializeSections() {
              (this.startAnimationTime = Date.now()),
                (this.startPosition = this.clip.runTimeInfo.currentMillisecond),
                (this.currentSectionIndex = this.getSectionTime(
                  this.multiplier
                )),
                (this.endAnimationTime = Math.abs(
                  this.startPosition -
                    this.options.sections[this.currentSectionIndex]
                ));
            }
            stepper(t) {
              this.setUpTimeBucket(t),
                this.options.sections && this.initializeSections(),
                this.requestAnimationID || this.animateTimeBucket();
            }
            millisecondChange(t, e, n, s) {
              let i =
                !(arguments.length > 4 && void 0 !== arguments[4]) ||
                arguments[4];
              const { totalBar: r, loopBar: o } = this.elements;
              if (
                (this.state !== e &&
                  ((this.state = e), this.eventBroadcast(c, e)),
                !this.settings.needsUpdate)
              )
                return this.clip.pause(), 1;
              this.settings.loopActivated &&
                this.clip.speed &&
                this.calculateJourney(t);
              const a = this.clip.duration,
                l = t - (a * o.offsetLeft) / r.offsetWidth,
                u = (a / r.offsetWidth) * o.offsetWidth;
              s &&
                this.goToMillisecond(t, {
                  after: this.settings.playAfterResize ? "play" : null,
                }),
                (this.elements.runningBar.style.width = (l / u) * 100 + "%");
              const p = this.timeFormat(t);
              this.elements.currentTime.innerHTML !== p &&
                (this.elements.currentTime.innerHTML = p),
                this.options.onMillisecondChange &&
                  i &&
                  this.options.onMillisecondChange(t);
            }
            calculateJourney(t) {
              const { loopEndMillisecond: e, loopStartMillisecond: n } =
                  this.settings,
                s = t > e || t === this.clip.duration,
                i = t < n || 0 === t,
                r = this.clip.speed > 0;
              if (this.clip.runTimeInfo.state === $) {
                if (r)
                  return (
                    !!s && (this.goToMillisecond(n + 1, { after: "play" }), !0)
                  );
                if (i)
                  return this.goToMillisecond(e - 1, { after: "play" }), !0;
              }
              return !1;
            }
            broadcastNotPlaying(t) {
              var e;
              this.elements.controls.classList.value.includes(N) ||
                this.elements.controls.classList.toggle(N),
                A(this.elements.statusButton, "pause", "play"),
                (this.elements.indicator.innerHTML = `${
                  t.charAt(0).toUpperCase() + t.slice(1)
                }`),
                "blocked" == t
                  ? (A((e = this.elements.pointerEventPanel), null, "spinner"),
                    e.classList.add("loading"))
                  : "idle" !== t && Z(this.elements.pointerEventPanel);
            }
            changeInitParams(e) {
              const n = { result: !0 };
              this.clip.pause();
              const s = this.clip?.exportLiveDefinition();
              s.props.host = this.clip.props.host;
              let i = this.clip.runTimeInfo.currentMillisecond;
              const r = this.clip.runTimeInfo.state === $,
                o = JSON.parse(JSON.stringify(s.props.initParams || {}));
              (s.props.initParams = e), this.clip.realClip.context.unmount();
              for (const t in this.clip) delete this.clip[t];
              let a;
              try {
                if (
                  ((a = t.utils.clipFromDefinition(s)),
                  a.nonBlockingErrorClip || a?.errors?.length)
                )
                  throw "Error: Params Error: Clip cannot be created!";
              } catch (e) {
                (n.result = !1),
                  (n.clip = a),
                  console.error(e),
                  (s.props.initParams = o),
                  (a = t.utils.clipFromDefinition(s));
              }
              return (
                (this.clip = a),
                (this.options.clip = this.clip),
                (this.elements.totalTime.innerHTML = this.timeFormat(
                  this.clip.duration
                )),
                this.changeSettings(this.options, !0),
                this.subscribeToTimer(),
                this.subscribeToDurationChange(),
                i > this.clip.duration && (i = this.clip.duration),
                this.goToMillisecond(i),
                r && this.clip.play(),
                n
              );
            }
            broadcastPlaying(t) {
              Z(this.elements.pointerEventPanel),
                this.elements.controls.classList.value.includes(N) &&
                  this.elements.controls.classList.toggle(N),
                (this.elements.indicator.innerHTML = "Playing"),
                A(this.elements.statusButton, "play", "pause"),
                t === $ &&
                  (this.clip.runTimeInfo.currentMillisecond ===
                    this.clip.duration && this.clip.speed >= 0
                    ? this.goToMillisecond(1, { after: "play" })
                    : (this.clip.runTimeInfo.currentMillisecond ===
                        this.clip.duration ||
                        0 === this.clip.runTimeInfo.currentMillisecond) &&
                      this.clip.speed < 0 &&
                      this.goToMillisecond(this.clip.duration - 1, {
                        after: "play",
                      }));
            }
            broadcastDurationChange() {
              (this.elements.totalTime.innerHTML = this.timeFormat(
                this.clip.duration
              )),
                (this.settings.loopEndMillisecond = this.clip.duration),
                (this.elements.pointerEventPanel.innerHTML = ""),
                this.millisecondChange(
                  this.clip.runTimeInfo.currentMillisecond
                );
            }
            broadcastVolumeChange(t) {
              (this.options.volume = t),
                (this.options.currentScript.dataset.volume = t);
            }
            broadcastSpeedChange(t) {
              (this.options.speed = t),
                (this.options.currentScript.dataset.speed = t);
            }
            broadcastMuteChange(t) {
              if (t)
                return (
                  (this.options.muted = !0),
                  void (this.options.currentScript.dataset.muted = "")
                );
              (this.options.muted = !1),
                delete this.options.currentScript.dataset.muted;
            }
            broadcastLoopChange(t) {
              if (t)
                return (
                  (this.options.loop = !0),
                  void (this.options.currentScript.dataset.loop = "")
                );
              (this.options.loop = !1),
                delete this.options.currentScript.dataset.loop;
            }
            broadcastScaleChange(t) {
              if (t)
                return (
                  (this.options.scaleToFit = t),
                  void (this.options.currentScript.dataset.scaleToFit = t)
                );
              (this.options.scaleToFit = !1),
                delete this.options.currentScript.dataset.scaleToFit;
            }
            broadcastShowVolumeChange(t) {
              if (t)
                return (
                  (this.options.showVolume = !0),
                  void (this.options.currentScript.dataset.showVolume = "")
                );
              (this.options.showVolume = !1),
                delete this.options.currentScript.dataset.showVolume;
            }
            broadcastToScript(t, e) {
              t === s
                ? this.broadcastVolumeChange(e)
                : t === r
                ? this.broadcastSpeedChange(e)
                : t === i
                ? this.broadcastMuteChange(e)
                : t === o
                ? this.broadcastLoopChange(e)
                : t === a
                ? this.broadcastScaleChange(e)
                : t === l && this.broadcastShowVolumeChange(e);
            }
            calculateThumbnail(t) {
              const e = this.options.thumbnail || this.options.thumbnailColor,
                n =
                  0 === this.clip.runTimeInfo.currentMillisecond &&
                  this.clip.speed > 0,
                s = this.options.autoPlay;
              if ("idle" === t) {
                if (s)
                  return void this.elements.playPausePanel.classList.add(
                    "hide"
                  );
                if (n)
                  return e
                    ? (v(this.elements.playPausePanelContainer),
                      (this.elements.playPausePanel.style.backgroundColor =
                        this.options.thumbnailColor || "black"),
                      (this.elements.playPausePanel.style.backgroundImage =
                        this.options.thumbnail &&
                        `url(${this.options.thumbnail})`),
                      this.elements.playPausePanel.classList.add("initial"),
                      void this.elements.pointerEventPanel.classList.add(
                        "initial"
                      ))
                    : void this.elements.playPausePanel.classList.add("hide");
              }
              (this.elements.playPausePanel.style.backgroundColor =
                "transparent"),
                (this.elements.playPausePanel.style.backgroundImage = "none"),
                this.elements.pointerEventPanel.classList.remove("initial"),
                this.elements.playPausePanel.classList.remove("initial");
            }
            eventBroadcast(t, e) {
              t === c
                ? (this.options.currentScript &&
                    (this.options.currentScript.dataset.status = e),
                  this.calculateThumbnail(e),
                  [
                    "paused",
                    "idle",
                    "transitional",
                    "armed",
                    "blocked",
                  ].includes(e)
                    ? this.broadcastNotPlaying(e)
                    : this.broadcastPlaying(e))
                : t === u
                ? this.broadcastDurationChange()
                : this.options.currentScript && this.broadcastToScript(t, e);
            }
            subscribeToDurationChange() {
              this.clip.subscribeToDurationChange(
                this.subscribeToDurationChangeCallback.bind(this)
              );
            }
            subscribeToDurationChangeCallback() {
              this.eventBroadcast(u);
            }
            subscribeToTimer() {
              this.clip.subscribe(this.id, this.millisecondChange.bind(this));
            }
            handleDragStart() {
              (this.settings.needsUpdate = !0),
                (this.settings.journey = b.startJourney(this.clip));
            }
            timeFormat(t) {
              if ("ss" !== this.options.timeFormat) return t;
              const e = t - K[0];
              if (0 < e && e < 1e3) return K[1];
              const n = t / 1e3 / 60 / 60,
                s = (n % 1) * 60,
                i = (s % 1) * 60,
                r = ("0" + parseInt(n.toFixed(5))).slice(-2),
                o = `${"00" === r ? "" : r + ":"}${(
                  "0" + parseInt(s.toFixed(5))
                ).slice(-2)}:${("0" + parseInt(i.toFixed(5))).slice(-2)}`;
              return (
                (null == K[0] || t - K[0] < 2e3) &&
                  ((K[0] = 1e3 * Math.floor(t / 1e3)), (K[1] = o)),
                o
              );
            }
            handleDrag(t) {
              let e =
                !(arguments.length > 1 && void 0 !== arguments[1]) ||
                arguments[1];
              isFinite(t) || (t = 0);
              const {
                  loopBar: n,
                  totalBar: s,
                  runningBar: i,
                  currentTime: r,
                } = this.elements,
                o = t + n.offsetLeft,
                a = Math.round((this.clip.duration * o) / s.offsetWidth);
              (r.innerHTML = this.timeFormat(a)),
                (i.style.width = (t / n.offsetWidth) * 100 + "%"),
                this.settings.journey.station(a),
                this.options.onMillisecondChange &&
                  e &&
                  this.options.onMillisecondChange(a);
            }
            handleDragEnd() {
              this.settings.journey.destination();
            }
            createProgressDrag(t) {
              this.handleDragStart(), this.handleDrag(t), this.handleDragEnd();
            }
            addEventListeners() {
              var t;
              ((t = this).listeners.onCursorMoveLoopEnd = (e) => {
                e.stopPropagation(), k() && e.preventDefault();
                let n =
                  (e.clientX || ((e.touches || [])[0] || {}).clientX) -
                  t.elements.totalBar.getBoundingClientRect().left;
                n < 0
                  ? (n = 0)
                  : n > t.elements.totalBar.offsetWidth &&
                    (n = t.elements.totalBar.offsetWidth),
                  t.elements.runningBar.offsetWidth >=
                    t.elements.loopBar.offsetWidth &&
                    (t.elements.runningBar.style.width =
                      t.elements.loopBar.offsetWidth + "px"),
                  t.settings.loopLastPositionXPxls - n < 0
                    ? (t.elements.loopBar.style.width =
                        Math.abs(t.settings.loopLastPositionXPxls - n) + "px")
                    : ((t.elements.loopBar.style.left = n + "px"),
                      (t.settings.loopLastPositionXPxls = n)),
                  (t.settings.loopEndMillisecond = Math.round(
                    (t.clip.duration *
                      ((parseFloat(t.elements.loopBar.style.left) || 0) +
                        parseFloat(t.elements.loopBar.style.width))) /
                      t.elements.totalBar.offsetWidth
                  )),
                  t.settings.loopEndMillisecond <
                    t.clip.runTimeInfo.currentMillisecond &&
                    (t.settings.loopJourney = !0),
                  t.settings.loopStartMillisecond >
                    t.settings.loopEndMillisecond &&
                    ((t.settings.loopStartMillisecond =
                      t.settings.loopEndMillisecond),
                    (t.settings.loopJourney = !0));
              }),
                (t.listeners.onMouseUpLoopEnd = () => {
                  (t.elements.listenerHelper.style.pointerEvents = "none"),
                    (t.settings.resizeLoop = !1);
                  const { loopBar: e, totalBar: n, runningBar: s } = t.elements;
                  if (
                    ((s.style.width =
                      (s.offsetWidth / e.offsetWidth) * 100 + "%"),
                    (e.style.left = (e.offsetLeft / n.offsetWidth) * 100 + "%"),
                    (e.style.width =
                      (e.offsetWidth / n.offsetWidth) * 100 + "%"),
                    t.settings.loopJourney &&
                      (t.createProgressDrag(s.offsetWidth),
                      (t.settings.loopJourney = !1)),
                    O(
                      t,
                      t.listeners.onMouseUpLoopEnd,
                      t.listeners.onCursorMoveLoopEnd
                    ),
                    M(t.listeners.onMouseDown, e, !0),
                    t.settings.playAfterResize)
                  ) {
                    if (
                      "idle" === t.clip.runTimeInfo.state ||
                      "completed" === t.clip.runTimeInfo.state
                    ) {
                      let e;
                      (e =
                        t.clip.speed >= 0
                          ? t.settings.loopStartMillisecond + 1
                          : t.settings.loopEndMillisecond - 1),
                        (t.settings.needsUpdate = !0),
                        t.goToMillisecond(e, {
                          before: "pause",
                          after: "play",
                        });
                    } else t.clip.play();
                    t.settings.playAfterResize = !1;
                  }
                }),
                (t.listeners.onMouseDownLoopEnd = (e) => {
                  e.stopPropagation(),
                    (t.elements.listenerHelper.style.pointerEvents = "auto"),
                    (t.settings.resizeLoop = !0),
                    (t.settings.needsUpdate = !0),
                    "playing" === t.clip.runTimeInfo.state &&
                      (t.clip.pause(), (t.settings.playAfterResize = !0)),
                    (t.elements.runningBar.style.width = `${t.elements.runningBar.offsetWidth}px`);
                  const n = t.elements.loopBar;
                  (n.style.left = `${n.offsetLeft}px`),
                    (n.style.width = `${n.offsetWidth}px`),
                    t.listeners.onCursorMoveLoopEnd(e),
                    S(
                      t,
                      t.listeners.onMouseUpLoopEnd,
                      t.listeners.onCursorMoveLoopEnd
                    );
                }),
                M(t.listeners.onMouseDownLoopEnd, t.elements.loopBarEnd, !1),
                ((t) => {
                  (t.listeners.onCursorMove = (e) => {
                    e.stopPropagation(), k() && e.preventDefault();
                    let n =
                      (e.clientX || ((e.touches || [])[0] || {}).clientX) -
                      t.elements.loopBar.getBoundingClientRect().left;
                    n < 0
                      ? (n = 0)
                      : n > t.elements.loopBar.offsetWidth &&
                        (n = t.elements.loopBar.offsetWidth),
                      t.handleDrag(n);
                  }),
                    (t.listeners.onMouseUp = () => {
                      (t.elements.listenerHelper.style.pointerEvents = "none"),
                        O(t, t.listeners.onMouseUp, t.listeners.onCursorMove),
                        t.handleDragEnd(t.settings);
                    }),
                    (t.listeners.onMouseDown = (e) => {
                      (t.elements.listenerHelper.style.pointerEvents = "auto"),
                        "playing" === t.clip.runTimeInfo.state &&
                          (t.settings.playAfterResize = !0),
                        t.handleDragStart(t.clip),
                        t.listeners.onCursorMove(e),
                        S(t, t.listeners.onMouseUp, t.listeners.onCursorMove);
                    }),
                    M(t.listeners.onMouseDown, t.elements.loopBar);
                })(this),
                ((t) => {
                  (t.listeners.onCursorMoveLoopStart = (e) => {
                    e.stopPropagation(), k() && e.preventDefault();
                    const n = e.clientX || ((e.touches || [])[0] || {}).clientX,
                      s = t.elements.totalBar.getBoundingClientRect();
                    let i = Math.round(n - s.left);
                    const r = Math.round(
                      (t.settings.loopEndMillisecond / t.clip.duration) *
                        t.elements.totalBar.offsetWidth
                    );
                    i < 0
                      ? (i = 0)
                      : i > t.elements.totalBar.offsetWidth &&
                        (i = t.elements.totalBar.offsetWidth);
                    const o =
                      (t.clip.runTimeInfo.currentMillisecond /
                        t.clip.duration) *
                        t.elements.totalBar.offsetWidth -
                      i;
                    (t.elements.loopBar.style.left = i + "px"),
                      (t.elements.loopBar.style.width = r - i + "px"),
                      (t.elements.runningBar.style.width = o + "px"),
                      (t.settings.loopLastPositionXPxls = i),
                      (t.settings.loopStartMillisecond = Math.round(
                        (t.clip.duration * t.elements.loopBar.offsetLeft) /
                          t.elements.totalBar.offsetWidth
                      )),
                      t.settings.loopEndMillisecond <
                        t.settings.loopStartMillisecond &&
                        ((t.settings.loopEndMillisecond =
                          t.settings.loopStartMillisecond),
                        (t.elements.loopBar.style.width = "0px"),
                        (t.elements.runningBar.style.width = "0px")),
                      t.settings.loopStartMillisecond >
                        t.clip.runTimeInfo.currentMillisecond &&
                        (t.settings.loopJourney = !0);
                  }),
                    (t.listeners.onMouseUpLoopStart = () => {
                      if (
                        ((t.elements.listenerHelper.style.pointerEvents =
                          "none"),
                        (t.settings.resizeLoop = !1),
                        t.settings.loopJourney &&
                          (t.createProgressDrag(
                            t.elements.runningBar.offsetWidth
                          ),
                          (t.settings.loopJourney = !1)),
                        (t.elements.loopBar.style.left =
                          (t.elements.loopBar.offsetLeft /
                            t.elements.totalBar.offsetWidth) *
                            100 +
                          "%"),
                        (t.elements.loopBar.style.width =
                          (t.elements.loopBar.offsetWidth /
                            t.elements.totalBar.offsetWidth) *
                            100 +
                          "%"),
                        (t.settings.loopStartMillisecond = Math.round(
                          (t.clip.duration * t.elements.loopBar.offsetLeft) /
                            t.elements.totalBar.offsetWidth
                        )),
                        (t.elements.runningBar.style.width =
                          (t.elements.runningBar.offsetWidth /
                            t.elements.loopBar.offsetWidth) *
                            100 +
                          "%"),
                        O(
                          t,
                          t.listeners.onMouseUpLoopStart,
                          t.listeners.onCursorMoveLoopStart
                        ),
                        M(t.listeners.onMouseDown, t.elements.loopBar, !0),
                        t.settings.playAfterResize)
                      ) {
                        if ("idle" === t.clip.runTimeInfo.state) {
                          let e;
                          (e =
                            t.clip.speed >= 0
                              ? t.settings.loopStartMillisecond + 1
                              : t.settings.loopEndMillisecond - 1),
                            (t.settings.needsUpdate = !0),
                            t.goToMillisecond(e, {
                              before: "pause",
                              after: "play",
                            });
                        } else t.clip.play();
                        t.settings.playAfterResize = !1;
                      }
                    }),
                    (t.listeners.onMouseDownLoopStart = (e) => {
                      e.stopPropagation(),
                        (t.elements.listenerHelper.style.pointerEvents =
                          "auto"),
                        (t.settings.resizeLoop = !0),
                        (t.settings.needsUpdate = !0),
                        "playing" === t.clip.runTimeInfo.state &&
                          (t.clip.pause(), (t.settings.playAfterResize = !0)),
                        t.listeners.onCursorMoveLoopStart(e),
                        S(
                          t,
                          t.listeners.onMouseUpLoopStart,
                          t.listeners.onCursorMoveLoopStart
                        );
                    }),
                    M(
                      t.listeners.onMouseDownLoopStart,
                      t.elements.loopBarStart
                    );
                })(this),
                (function (t) {
                  t.elements.context.onkeydown = (e) => {
                    switch (e.code) {
                      case "Space":
                        I(t);
                        break;
                      case "ArrowRight":
                        t.goToMillisecond(
                          t.clip.runTimeInfo.currentMillisecond + 5e3
                        );
                        break;
                      case "ArrowLeft":
                        t.goToMillisecond(
                          t.clip.runTimeInfo.currentMillisecond - 5e3
                        );
                    }
                  };
                })(this),
                (function (t) {
                  const e = t.elements;
                  let n = !1;
                  e.volumeBtn.onclick = () => {
                    t.settings.volumeMute
                      ? ((e.volumeBarActive.style.width =
                          100 * t.settings.volume + "%"),
                        t.clip.setVolume(t.settings.previousVolume),
                        (e.volumeBarActive.style.width =
                          100 * t.settings.previousVolume + "%"),
                        (t.settings.volumeMute = !1),
                        A(e.volumeBtn, R, F))
                      : ((t.settings.volumeMute = !0),
                        A(e.volumeBtn, F, R),
                        (e.volumeBarActive.style.width = "0%"),
                        t.clip.setVolume(0)),
                      t.eventBroadcast(s, t.settings.previousVolume),
                      t.eventBroadcast(i, t.settings.volumeMute);
                  };
                  let r = !1;
                  (e.volumeBtn.onmouseover = () => {
                    r = !0;
                  }),
                    (t.elements.leftButtons.onmouseout = () => {
                      if (!r || n) return;
                      const e =
                        event.toElement || event.relatedTarget || event.target;
                      e === t.elements.leftButtons ||
                        (function (t, e) {
                          let n = e.parentNode;
                          for (; null != n; ) {
                            if (n == t) return !0;
                            n = n.parentNode;
                          }
                          return !1;
                        })(t.elements.leftButtons, e) ||
                        (r = !1);
                    });
                  const o = t.listeners;
                  (o.onCursorMoveVolumeBar = (n) => {
                    let r =
                      (n.clientX || ((n.touches || [])[0] || {}).clientX) -
                      e.volumeBarHelper.getBoundingClientRect().left;
                    if (
                      (r < 0
                        ? (r = 0)
                        : r > e.volumeBarHelper.offsetWidth &&
                          (r = e.volumeBarHelper.offsetWidth),
                      (t.settings.volume = Number(
                        (r / e.volumeBarHelper.offsetWidth).toFixed(2)
                      )),
                      (e.volumeBarActive.style.width =
                        100 * t.settings.volume + "%"),
                      t.clip.setVolume(t.settings.volume),
                      t.settings.volume >= 0)
                    ) {
                      const n = 0 === t.settings.volume;
                      (t.settings.volumeMute = n),
                        n ? A(e.volumeBtn, F, R) : A(e.volumeBtn, R, F);
                    }
                    t.eventBroadcast(s, t.settings.volume),
                      t.eventBroadcast(i, t.settings.volumeMute);
                  }),
                    (o.onMouseUpVolumeBar = () => {
                      (n = !1),
                        (e.listenerHelper.style.pointerEvents = "none"),
                        t.settings.volume > 0 &&
                          (t.settings.previousVolume = t.settings.volume),
                        O(t, o.onMouseUpVolumeBar, o.onCursorMoveVolumeBar);
                    }),
                    (o.onMouseDownVolumeBar = (s) => {
                      (n = !0),
                        (e.listenerHelper.style.pointerEvents = "auto"),
                        o.onCursorMoveVolumeBar(s),
                        S(t, o.onMouseUpVolumeBar, o.onCursorMoveVolumeBar);
                    }),
                    M(o.onMouseDownVolumeBar, e.volumeBarHelper),
                    M(o.onMouseDownVolumeBar, e.volumeCursor);
                })(this),
                ((t) => {
                  t.elements.statusButton.onclick = () => {
                    switch (t.clip.runTimeInfo.state) {
                      case "playing":
                        t.clip.pause();
                        break;
                      case "paused":
                      case "idle":
                      case "transitional":
                      case "armed":
                        t.clip.play();
                    }
                    return !1;
                  };
                })(this),
                (function (t) {
                  (t.elements.settingsPanel.onblur = () => {
                    t.elements.settingsButton.click();
                  }),
                    (t.elements.settingsPointerEvents.onclick = () => H(t)),
                    (t.elements.settingsShowVolume.onclick = () => Y(t)),
                    (t.elements.settingsButton.onclick = () => {
                      const e = (n) => {
                        if (t.elements.settingsPanel.contains(n.target))
                          return !0;
                        t.elements.settingsPanel.classList.toggle(
                          `${t.name}-hide`
                        ),
                          t.elements.settingsPanel.classList.toggle(
                            "m-fadeOut"
                          ),
                          t.elements.settingsPanel.classList.toggle("m-fadeIn"),
                          t.elements.settingsPanel.className.includes(
                            "m-fadeOut"
                          )
                            ? (t.document.removeEventListener("click", e, !1),
                              t.eventBroadcast(c, t.state))
                            : t.elements.settingsPanel.focus();
                      };
                      t.elements.settingsPanel.className.includes("m-fadeOut")
                        ? (t.elements.controls.classList.value.includes(
                            "--mcp-force-show-controls"
                          ) ||
                            t.elements.controls.classList.toggle(
                              "--mcp-force-show-controls"
                            ),
                          t.document.addEventListener("click", e, !1))
                        : t.document.removeEventListener("click", e, !1);
                    });
                })(this),
                (function (t) {
                  t.elements.settingsSpeedButtonShow.onclick =
                    t.elements.settingsSpeedButtonHide.onclick = () => {
                      t.elements.settingsPanel.classList.toggle(
                        `${t.name}-settings-speed-panel`
                      ),
                        t.elements.settingsPanel.className.includes(
                          `${t.name}-settings-speed-panel`
                        )
                          ? ((t.elements.settingsMainPanel.style.display =
                              "none"),
                            (t.elements.settingsSpeedPanel.style.display =
                              "block"))
                          : ((t.elements.settingsSpeedPanel.style.display =
                              "none"),
                            (t.elements.settingsMainPanel.style.display =
                              "block"));
                    };
                })(this),
                (function (t) {
                  t.elements.loopButton.onclick = () => X(t);
                })(this),
                (function (t) {
                  t.elements.fullScreenButton.onclick = () => y(t);
                })(this),
                (function (t) {
                  (t.elements.pointerEventPanel.onclick = () =>
                    (function (t) {
                      I(t);
                    })(t)),
                    (t.elements.pointerEventPanel.ondblclick = () => y(t));
                })(this),
                ((t) => {
                  this.elements.donkeyclipButton.addEventListener(
                    "click",
                    () => {
                      const t = window.DonkeyClip?.clipId,
                        e = window.location.host.includes("staging")
                          ? "staging."
                          : "";
                      window.open(
                        `https://${e}donkeyclip.com/${
                          t ? `explore/donkeyclips/${t}` : ""
                        }`
                      );
                    }
                  );
                })(),
                ((t) => {
                  function e() {
                    t.elements.mcPlayer.classList.toggle("full-screen"),
                      t.clip.props.host.classList.toggle("full-screen");
                  }
                  t.document.addEventListener("fullscreenchange", e),
                    t.document.addEventListener("webkitfullscreenchange", e),
                    t.document.addEventListener("mozfullscreenchange", e),
                    t.document.addEventListener("MSFullscreenChange", e);
                })(this),
                "scroller" === this.options.type && q(this);
            }
            setTheme() {
              this.options.theme.replace(/\s\s+/g, " "),
                this.options.theme.trim();
              const t = G[this.options.theme];
              if (t) this.elements.mcPlayer.classList.add(t);
              else if (
                this.options.themeCSS &&
                !this.document.getElementById("--mc-player-style-custom")
              ) {
                this.options.themeCSS = this.options.themeCSS.replace(
                  /(behaviour|javascript|expression)/gm,
                  ""
                );
                const t = this.document.createElement("style");
                (t.id = "--mc-player-style-custom"),
                  t.styleSheet
                    ? (t.styleSheet.cssText = this.options.themeCSS)
                    : t.appendChild(
                        document.createTextNode(this.options.themeCSS)
                      ),
                  this.document.querySelector("head").appendChild(t),
                  this.elements.mcPlayer.classList.add(this.options.theme);
              }
              if (!this.document.getElementById("--mc-player-style")) {
                const t = this.document.createElement("style");
                (t.id = "--mc-player-style"),
                  t.styleSheet
                    ? (t.styleSheet.cssText = z)
                    : t.appendChild(document.createTextNode(z)),
                  this.document.querySelector("head").appendChild(t);
              }
              this.eventBroadcast("theme-change", this.options.theme);
            }
            setSpeed() {
              const t = 1 == this.clip.speed ? "Normal" : this.clip.speed;
              this.elements.speedCurrent.innerHTML = t;
            }
          };
        })(n(584));
      },
      604: (t, e, n) => {
        "use strict";
        var s = n(584),
          i = n(657),
          r = n.n(i);
        const o = {
          pulse: {
            0: { transform: { scaleX: 1, scaleY: 1, scaleZ: 1 } },
            50: { transform: { scaleX: 1.05, scaleY: 1.05, scaleZ: 1.05 } },
            100: { transform: { scaleX: 1, scaleY: 1, scaleZ: 1 } },
          },
          bounce: {
            0: {
              easing: [0.215, 0.61, 0.355, 1],
              transform: { translateX: 0, translateY: 0, translateZ: 0 },
            },
            20: {
              easing: [0.215, 0.61, 0.355, 1],
              transform: { translateX: 0, translateY: 0, translateZ: 0 },
            },
            53: {
              easing: [0.215, 0.61, 0.355, 1],
              transform: { translateX: 0, translateY: 0, translateZ: 0 },
            },
            100: {
              easing: [0.215, 0.61, 0.355, 1],
              transform: { translateX: 0, translateY: 0, translateZ: 0 },
            },
            40: {
              easing: [0.755, 0.05, 0.855, 0.06],
              transform: {
                translateX: 0,
                translateY: "-30px",
                translateZ: 0,
                scaleY: 1.1,
              },
            },
            43: {
              easing: [0.755, 0.05, 0.855, 0.06],
              transform: {
                translateX: 0,
                translateY: "-30px",
                translateZ: 0,
                scaleY: 1.1,
              },
            },
            70: {
              easing: [0.755, 0.05, 0.855, 0.06],
              transform: {
                translateX: 0,
                translateY: "-15px",
                translateZ: 0,
                scaleY: 1.05,
              },
            },
            80: {
              easing: [0.215, 0.61, 0.355, 1],
              transform: {
                translateX: 0,
                translateY: 0,
                translateZ: 0,
                scaleY: 0.95,
              },
            },
            90: {
              transform: {
                translateX: 0,
                translateY: "-4px",
                translateZ: 0,
                scaleY: 1.02,
              },
            },
          },
          flash: {
            0: { opacity: 1 },
            50: { opacity: 1 },
            100: { opacity: 1 },
            25: { opacity: 0 },
            75: { opacity: 0 },
          },
          heartBeat: {
            0: { transform: { scale: 1 } },
            14: { transform: { scale: 1.3 } },
            28: { transform: { scale: 1 } },
            42: { transform: { scale: 1.3 } },
            70: { transform: { scale: 1 } },
          },
          jello: {
            0: {
              transform: { translateX: 0, translateY: 0, translateZ: 0 },
              transformOrigin: "center",
            },
            100: {
              transform: { translateX: 0, translateY: 0, translateZ: 0 },
              transformOrigin: "center",
            },
            22: { transform: { skewX: "-12.5deg", skewY: "-12.5deg" } },
            33: { transform: { skewX: "6.25deg", skewY: "6.25deg" } },
            44: { transform: { skewX: "-3.125deg", skewY: "-3.125deg" } },
            55: { transform: { skewX: "1.5625deg", skewY: "1.5625deg" } },
            66: { transform: { skewX: "-0.78125deg", skewY: "-0.78125deg" } },
            77: { transform: { skewX: "0.390625deg", skewY: "0.390625deg" } },
            88: {
              transform: { skewX: "-0.1953125deg", skewY: "-0.1953125deg" },
            },
          },
          backInDown: {
            0: {
              transform: { translateY: "-1200px", scale: 0.7 },
              opacity: 0.7,
            },
            80: { transform: { translateY: "0px", scale: 0.7 }, opacity: 0.7 },
            100: { transform: { scale: 1 }, opacity: 1 },
          },
          backInLeft: {
            0: {
              transform: { translateX: "-2000px", scale: 0.7 },
              opacity: 0.7,
            },
            80: { transform: { translateX: "0px", scale: 0.7 }, opacity: 0.7 },
            100: { transform: { scale: 1 }, opacity: 1 },
          },
          backInRight: {
            0: {
              transform: { translateX: "2000px", scale: 0.7 },
              opacity: 0.7,
            },
            80: { transform: { translateX: "0px", scale: 0.7 }, opacity: 0.7 },
            100: { transform: { scale: 1 }, opacity: 1 },
          },
          backInUp: {
            0: {
              transform: { translateY: "1200px", scale: 0.7 },
              opacity: 0.7,
            },
            80: { transform: { translateY: "0px", scale: 0.7 }, opacity: 0.7 },
            100: { transform: { scale: 1 }, opacity: 1 },
          },
          backOutDown: {
            0: { transform: { scale: 1 }, opacity: 1 },
            20: { transform: { translateY: "0px", scale: 0.7 }, opacity: 0.7 },
            100: {
              transform: { translateY: "700px", scale: 0.7 },
              opacity: 0.7,
            },
          },
          backOutLeft: {
            0: { transform: { scale: 1 }, opacity: 1 },
            20: { transform: { translateX: "0px", scale: 0.7 }, opacity: 0.7 },
            100: {
              transform: { translateX: "-2000px", scale: 0.7 },
              opacity: 0.7,
            },
          },
          backOutRight: {
            0: { transform: { scale: 1 }, opacity: 1 },
            20: { transform: { translateX: "0px", scale: 0.7 }, opacity: 0.7 },
            100: {
              transform: { translateX: "2000px", scale: 0.7 },
              opacity: 0.7,
            },
          },
          backOutUp: {
            0: { transform: { scale: 1 }, opacity: 1 },
            20: { transform: { translateY: "0px", scale: 0.7 }, opacity: 0.7 },
            100: {
              transform: { translateY: "-700px", scale: 0.7 },
              opacity: 0.7,
            },
          },
          bounceIn: {
            0: {
              opacity: 0,
              transform: { scaleX: 0.3, scaleY: 0.3, scaleZ: 0.3 },
              easing: [0.215, 0.61, 0.355, 1],
            },
            20: {
              transform: { scaleX: 1.1, scaleY: 1.1, scaleZ: 1.1 },
              easing: [0.215, 0.61, 0.355, 1],
            },
            40: {
              transform: { scaleX: 0.9, scaleY: 0.9, scaleZ: 0.9 },
              easing: [0.215, 0.61, 0.355, 1],
            },
            60: {
              opacity: 1,
              transform: { scaleX: 1.03, scaleY: 1.03, scaleZ: 1.03 },
              easing: [0.215, 0.61, 0.355, 1],
            },
            80: {
              transform: { scaleX: 0.97, scaleY: 0.97, scaleZ: 0.97 },
              easing: [0.215, 0.61, 0.355, 1],
            },
            100: {
              opacity: 1,
              transform: { scaleX: 1, scaleY: 1, scaleZ: 1 },
              easing: [0.215, 0.61, 0.355, 1],
            },
          },
          bounceInDown: {
            0: {
              opacity: 0,
              transform: {
                translateX: 0,
                translateY: "-3000px",
                translateZ: 0,
                scaleY: 3,
              },
              easing: [0.215, 0.61, 0.355, 1],
            },
            60: {
              opacity: 1,
              transform: {
                translateX: 0,
                translateY: "25px",
                translateZ: 0,
                scaleY: 0.9,
              },
              easing: [0.215, 0.61, 0.355, 1],
            },
            75: {
              transform: {
                translateX: 0,
                translateY: "-10px",
                translateZ: 0,
                scaleY: 0.95,
              },
              easing: [0.215, 0.61, 0.355, 1],
            },
            90: {
              transform: {
                translateX: 0,
                translateY: "5px",
                translateZ: 0,
                scaleY: 0.985,
              },
              easing: [0.215, 0.61, 0.355, 1],
            },
            100: {
              transform: { translateX: 0, translateY: 0, translateZ: 0 },
              easing: [0.215, 0.61, 0.355, 1],
            },
          },
          bounceInLeft: {
            0: {
              opacity: 0,
              transform: { translateX: "-3000px", scaleX: 3 },
              easing: [0.215, 0.61, 0.355, 1],
            },
            60: {
              opacity: 1,
              transform: { translateX: "25px", scaleX: 1 },
              easing: [0.215, 0.61, 0.355, 1],
            },
            75: {
              transform: { translateX: "-10px", scaleX: 0.98 },
              easing: [0.215, 0.61, 0.355, 1],
            },
            90: {
              transform: { translateX: "5px", scaleX: 0.995 },
              easing: [0.215, 0.61, 0.355, 1],
            },
            100: {
              transform: { translateX: 0 },
              easing: [0.215, 0.61, 0.355, 1],
            },
          },
          bounceInRight: {
            0: {
              opacity: 0,
              transform: { translateX: "3000px", scaleX: 3 },
              easing: [0.215, 0.61, 0.355, 1],
            },
            60: {
              opacity: 1,
              transform: { translateX: "-25px", scaleX: 1 },
              easing: [0.215, 0.61, 0.355, 1],
            },
            75: {
              transform: { translateX: "10px", scaleX: 0.98 },
              easing: [0.215, 0.61, 0.355, 1],
            },
            90: {
              transform: { translateX: "-5px", scaleX: 0.995 },
              easing: [0.215, 0.61, 0.355, 1],
            },
            100: {
              transform: { translateX: 0 },
              easing: [0.215, 0.61, 0.355, 1],
            },
          },
          bounceOut: {
            20: { transform: { scaleX: 0.9, scaleY: 0.9, scaleZ: 0.9 } },
            50: {
              opacity: 1,
              transform: { scaleX: 1.1, scaleY: 1.1, scaleZ: 1.1 },
            },
            55: {
              opacity: 1,
              transform: { scaleX: 1.1, scaleY: 1.1, scaleZ: 1.1 },
            },
            100: {
              opacity: 0,
              transform: { scaleX: 0.3, scaleY: 0.3, scaleZ: 0.3 },
            },
          },
          bounceOutDown: {
            20: { transform: { translateY: "10px", scaleY: 0.985 } },
            40: { opacity: 1, transform: { translateY: "-20px", scaleY: 0.9 } },
            45: { opacity: 1, transform: { translateY: "-20px", scaleY: 0.9 } },
            100: { opacity: 0, transform: { translateY: "2000px", scaleY: 3 } },
          },
          bounceOutLeft: {
            20: { opacity: 1, transform: { translateX: "20px", scaleX: 0.9 } },
            100: {
              opacity: 0,
              transform: { translateX: "-2000px", scaleX: 2 },
            },
          },
          bounceOutRight: {
            20: { opacity: 1, transform: { translateX: "-20px", scaleX: 0.9 } },
            100: { opacity: 0, transform: { translateX: "2000px", scaleX: 2 } },
          },
          bounceOutUp: {
            20: { transform: { translateY: "-10px", scaleY: 0.985 } },
            40: { opacity: 1, transform: { translateY: "20px", scaleY: 0.9 } },
            45: { opacity: 1, transform: { translateY: "20px", scaleY: 0.9 } },
            100: {
              opacity: 0,
              transform: { translateY: "-2000px", scaleY: 3 },
            },
          },
          fadeInDown: {
            0: { opacity: 0, transform: { translateY: "-100%" } },
            100: { opacity: 1, transform: { translateY: 0 } },
          },
          fadeInLeft: {
            0: { opacity: 0, transform: { translateX: "-100%" } },
            100: { opacity: 1, transform: { translateX: 0 } },
          },
          fadeInRight: {
            0: { opacity: 0, transform: { translateX: "100%" } },
            100: { opacity: 1, transform: { translateX: 0 } },
          },
          fadeInUp: {
            0: { opacity: 0, transform: { translateY: "100%" } },
            100: { opacity: 1, transform: { translateY: 0 } },
          },
          fadeOutDown: {
            0: { opacity: 1 },
            100: {
              opacity: 0,
              transform: { translateX: 0, translateY: "100%", translateZ: 0 },
            },
          },
          fadeOutLeft: {
            0: { opacity: 1 },
            100: { opacity: 0, transform: { translateX: "-100%" } },
          },
          fadeOutRight: {
            0: { opacity: 1 },
            100: { opacity: 0, transform: { translateX: "100%" } },
          },
          fadeOutUp: {
            0: { opacity: 1 },
            100: { opacity: 0, transform: { translateY: "-100%" } },
          },
          flipInX: {
            0: {
              transform: { rotateX: "90deg" },
              easing: "easeInQuad",
              opacity: 0,
            },
            40: { transform: { rotateX: "-20deg" }, easing: "easeInQuad" },
            60: { transform: { rotateX: "10deg" }, opacity: 1 },
            80: { transform: { perspective: "400px", rotateX: "-5deg" } },
            100: { transform: { perspective: "400px" } },
          },
          headShake: {
            0: { transform: { translateX: 0 } },
            6.5: { transform: { translateX: "-6px", rotateY: "-9deg" } },
            18.5: { transform: { translateX: "5px", rotateY: "7deg" } },
            31.5: { transform: { translateX: "-3px", rotateY: "-5deg" } },
            43.5: { transform: { translateX: "2px", rotateY: "3deg" } },
            50: { transform: { translateX: 0 } },
          },
          rubberBand: {
            0: { transform: { scaleX: 1, scaleY: 1, scaleZ: 1 } },
            30: { transform: { scaleX: 1.25, scaleY: 0.75, scaleZ: 1 } },
            40: { transform: { scaleX: 0.75, scaleY: 1.25, scaleZ: 1 } },
            50: { transform: { scaleX: 1.15, scaleY: 0.85, scaleZ: 1 } },
            65: { transform: { scaleX: 0.95, scaleY: 1.05, scaleZ: 1 } },
            75: { transform: { scaleX: 1.05, scaleY: 0.95, scaleZ: 1 } },
            100: { transform: { scaleX: 1, scaleY: 1, scaleZ: 1 } },
          },
          shakeX: {
            0: { transform: { translateX: 0 } },
            10: { transform: { translateX: "-10px" } },
            20: { transform: { translateX: "10px" } },
            30: { transform: { translateX: "-10px" } },
            40: { transform: { translateX: "10px" } },
            50: { transform: { translateX: "-10px" } },
            60: { transform: { translateX: "10px" } },
            70: { transform: { translateX: "-10px" } },
            80: { transform: { translateX: "10px" } },
            90: { transform: { translateX: "-10px" } },
            100: { transform: { translateX: 0 } },
          },
          shakeY: {
            0: { transform: { translateY: 0 } },
            10: { transform: { translateY: "-10px" } },
            20: { transform: { translateY: "10px" } },
            30: { transform: { translateY: "-10px" } },
            40: { transform: { translateY: "10px" } },
            50: { transform: { translateY: "-10px" } },
            60: { transform: { translateY: "10px" } },
            70: { transform: { translateY: "-10px" } },
            80: { transform: { translateY: "10px" } },
            90: { transform: { translateY: "-10px" } },
            100: { transform: { translateY: 0 } },
          },
          tada: {
            0: { transform: { scaleX: 1, scaleY: 1, scaleZ: 1, rotateZ: 0 } },
            10: {
              transform: {
                scaleX: 0.9,
                scaleY: 0.9,
                scaleZ: 0.9,
                rotateZ: "-3deg",
              },
            },
            20: {
              transform: {
                scaleX: 0.9,
                scaleY: 0.9,
                scaleZ: 0.9,
                rotateZ: "-3deg",
              },
            },
            30: {
              transform: {
                scaleX: 1.1,
                scaleY: 1.1,
                scaleZ: 1.1,
                rotateZ: "3deg",
              },
            },
            40: {
              transform: {
                scaleX: 1.1,
                scaleY: 1.1,
                scaleZ: 1.1,
                rotateZ: "-3deg",
              },
            },
            50: {
              transform: {
                scaleX: 1.1,
                scaleY: 1.1,
                scaleZ: 1.1,
                rotateZ: "3deg",
              },
            },
            60: {
              transform: {
                scaleX: 1.1,
                scaleY: 1.1,
                scaleZ: 1.1,
                rotateZ: "-3deg",
              },
            },
            70: {
              transform: {
                scaleX: 1.1,
                scaleY: 1.1,
                scaleZ: 1.1,
                rotateZ: "3deg",
              },
            },
            80: {
              transform: {
                scaleX: 1.1,
                scaleY: 1.1,
                scaleZ: 1.1,
                rotateZ: "-3deg",
              },
            },
            90: {
              transform: {
                scaleX: 1.1,
                scaleY: 1.1,
                scaleZ: 1.1,
                rotateZ: "3deg",
              },
            },
            100: { transform: { scaleX: 1, scaleY: 1, scaleZ: 1, rotateZ: 0 } },
          },
        };
        class a extends s.Combo {
          get incidents() {
            let t = this.attrs.keyframes;
            this.attrs.animation && (t = o[this.attrs.animation]);
            const e = (function (t, e) {
              const n = [];
              let i = 0;
              const r = { ...t[0] };
              return (
                Object.keys(t).forEach((o) => {
                  const a = parseFloat(o);
                  if (0 !== a) {
                    const l = Math.floor((a / 100) * e - (i / 100) * e),
                      c = Math.floor((i / 100) * e),
                      u = { ...t[o] },
                      p = {},
                      h = u.easing || "linear";
                    delete u.easing,
                      Object.keys(u).forEach((t) => {
                        void 0 !== r[t] && (p[t] = r[t]);
                      }),
                      n.push({
                        incidentClass: s.CSSEffect,
                        attrs: { animatedAttrs: u, initialValues: p },
                        props: { duration: l, easing: h },
                        position: c,
                      }),
                      Object.assign(r, u),
                      (i = a);
                  }
                }),
                n
              );
            })(t, this.props.duration);
            return e;
          }
        }
        var l = {
          npm_name: "mc-essentials",
          version: "0.0.1",
          incidents: [{ exportable: a, name: "Animation" }],
        };
        const c = (0, s.loadPlugin)(l),
          u = new URL(window.location.href).searchParams.get("animation"),
          p = new s.HTMLClip({
            html: '<div class="container">\n        <div id="effect"></div>\n        <div id="htmlclip"></div>\n        <div class="combo" id="combo">MC Essentials</div>\n        <div id="myclip"></div>\n    </div>',
            css: "\n        .container{\n            background: #252525;\n            width: 700px;\n            height: 700px;\n        }\n        .combo {\n          position: absolute;\n          color: yellow;\n          font-size: 60px;\n          font-weight: bold;\n          height: 40px;\n          top: 300px;\n          left: 177px;\n        }\n    ",
            host: document.getElementById("clip"),
            containerParams: { width: "700px", height: "700px" },
          }),
          h = new c.Animation(
            { animation: u || "bounce" },
            { selector: "#combo", duration: 1500, easing: "easeInCubic" }
          );
        p.addIncident(h, 0);
        const d = new (r())({ clip: p, controls: !1 });
        (document.getElementById("clip").style.opacity = 1),
          setTimeout(d.play, 200);
      },
      584: (t, e, n) => {
        "use strict";
        n.r(e),
          n.d(e, {
            AudioClip: () => aa,
            AudioEffect: () => _l,
            AudioPlayback: () => Tl,
            BrowserClip: () => oo,
            CSSEffect: () => hl,
            Combo: () => kl,
            CoreAudioClip: () => Dl,
            Effect: () => it,
            ExtendableCSSEffect: () => Qa,
            Group: () => Pr,
            HTMLClip: () => oa,
            MediaPlayback: () => da,
            TimeCapsule: () => Ol,
            loadPlugin: () => qa,
            setCSSCore: () => pl,
            utils: () => Ml,
            version: () => xr,
          });
        const s = [
            {
              key: "info",
              style: "color:#666;",
              level: 5,
              consoleMethod: "log",
            },
            {
              key: "notice",
              style: "background:rgba(0,0,0,0.8);color:white;padding:8px;",
              level: 4,
              consoleMethod: "log",
            },
            {
              key: "warning",
              style: "color:black;background:orange;",
              level: 2,
              consoleMethod: "warn",
            },
            {
              key: "error",
              style: "color:black;background:red;",
              level: 1,
              consoleMethod: "error",
            },
          ],
          i = "data-motorcortex2-id",
          r = "MotorCortex",
          o = "total",
          a = "index",
          l = "initParams",
          c = ["object", "array", "any", "boolean", "class", "tuple"],
          u = "motor-cortex-js",
          p = `${u}-attribute`;
        var h = Object.defineProperty,
          d = (t, e, n) => (
            ((t, e, n) => {
              e in t
                ? h(t, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: n,
                  })
                : (t[e] = n);
            })(t, "symbol" != typeof e ? e + "" : e, n),
            n
          );
        window.AudioContext ||
          (window.AudioContext = window.webkitAudioContext);
        const m = new window.AudioContext();
        function f(t) {
          return t === parseInt(t, 10);
        }
        function g(t) {
          return !isNaN(parseFloat(t)) && isFinite(t);
        }
        function y(t) {
          return "string" == typeof t || t instanceof String;
        }
        function v(t) {
          return "object" == typeof t;
        }
        function b(t) {
          return t && "[object Function]" === {}.toString.call(t);
        }
        function x(t, e) {
          return (
            !(null == e || !v(t)) && Object.prototype.hasOwnProperty.call(t, e)
          );
        }
        function w(t) {
          return JSON.parse(JSON.stringify(t));
        }
        const C = /^[+-]?(\d+([.]\d*)?|[.]\d+)/gi;
        function I(t, e) {
          const n = null == t ? void 0 : t[e];
          if (!y(n)) return null;
          let s = n.match(C)[0];
          const i = n.substring(s.length);
          return (
            (s = Number(s)),
            !(function (t) {
              return "number" == typeof t && isFinite(t);
            })(s) ||
            ("%" !== i && "px" !== i)
              ? null
              : { number: s, unit: i }
          );
        }
        const P = [
          'originalDims should be an object containing both the "width" and "height" keys',
        ];
        function E(t) {
          return null == t
            ? { result: !0, analysis: { width: null, height: null } }
            : v(t) && x(t, "width") && x(t, "height")
            ? null == I(t, "width")
              ? {
                  result: !1,
                  errors: [
                    "originalDims.width should be defined either on px or %.",
                  ],
                }
              : null == I(t, "height")
              ? {
                  result: !1,
                  errors: [
                    "originalDims.height should be defined either on px or %.",
                  ],
                }
              : { result: !0, analysis: k(t) }
            : { result: !1, errors: P };
        }
        function k(t) {
          return v(t) && null != t
            ? { width: I(t, "width"), height: I(t, "height") }
            : { width: null, height: null };
        }
        function S(t) {
          var e;
          const n = R(t),
            s = null == (e = /.*\((.*)\).*/.exec(n)) ? void 0 : e[1];
          return null == s ? void 0 : s.split(",");
        }
        function O(t) {
          const e = t.split("___");
          return { mcid: e[0], attribute: e[1] };
        }
        function M() {
          return Math.floor(65536 * (1 + Math.random()))
            .toString(16)
            .substring(1);
        }
        function A(t = !1) {
          const e = t ? "_" : "-";
          return `${M()}${M()}${e}${M()}${e}${M()}`;
        }
        function _(t, e) {
          return `${t}___${e}`;
        }
        function T(t, e) {
          return !1;
        }
        function D(t, e) {
          return { result: !1 };
        }
        function B(t, e, n) {
          const s = e.split(".");
          let i = t;
          for (let t = 0; t < s.length - 1; t++) {
            if (!x(i, s[t])) return !1;
            i = i[s[t]];
          }
          return !!x(i, s[s.length - 1]) && ((i[s[s.length - 1]] = n), !0);
        }
        function L() {}
        const j = new (class {
          constructor(t) {
            d(this, "log"),
              d(this, "info"),
              d(this, "notice"),
              d(this, "warning"),
              d(this, "error");
            let e = 2;
            x(t, "logLevel") && (e = t.logLevel);
            for (let t = 0; t < s.length; t++) {
              const n = s[t];
              e >= n.level
                ? (this[n.key] = window.console[n.consoleMethod].bind(
                    window.console,
                    `MotorCortex - ${n.key}: `
                  ))
                : (this[n.key] = L);
            }
            this.log =
              e >= 3
                ? window.console.log.bind(window.console, "MotorCortex - ")
                : L;
          }
        })();
        function V(t, e, n) {
          const s = e(t);
          if (s.length > 0) {
            let t = `Error on plugin's "${n.plugin_npm_name}" "${n.ClassName}" instantiation. Errors (op props):`;
            for (let e = 0; e < s.length; e++)
              t += `\n - ${s[e].message}. ${s[e].actual} provided`;
            return j.error(t), { result: !1, errors: s };
          }
          return { result: !0 };
        }
        function N(t) {
          const e = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#x27;",
            "/": "&#x2F;",
          };
          return `${t}`.replace(/[&<>"'/]/g, function (t) {
            return e[t];
          });
        }
        function $(t, e, n) {
          const s = [];
          for (let i = 0; i < t.length; i++) {
            const r = t[i];
            let o = r.parentMillisecond - n;
            (o = o * e + n),
              1 !== e &&
                s.push({
                  id: r.incident.id,
                  start: o,
                  end: o + r.incident.duration * e,
                  startDelta: o - r.millisecond,
                });
          }
          return s;
        }
        function R(t) {
          return t.replace(/\s/g, "");
        }
        var F = Object.defineProperty,
          z = (t, e, n) => (
            ((t, e, n) => {
              e in t
                ? F(t, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: n,
                  })
                : (t[e] = n);
            })(t, "symbol" != typeof e ? e + "" : e, n),
            n
          );
        function X(t) {
          return t.result
            ? { result: !0, execute: t.execute }
            : { result: !1, errors: t.errors };
        }
        const H = { result: !0, execute: function () {} };
        class Y {
          constructor(t) {
            z(this, "context"),
              z(this, "getIncidentById"),
              z(this, "runTimeInfo"),
              (this.runTimeInfo = t.runTimeInfo || {}),
              (this.context = t.context),
              this.onInitialise(),
              (this.getIncidentById = t.getIncidentById);
          }
          static get type() {
            return "plain";
          }
          static set type(t) {}
          onInitialise() {}
          _resize(t) {
            j.log("Please overwite the _resize method of the Channel");
          }
          addIncidents(t) {
            return X(this.checkAddition(t));
          }
          editIncidents(t, e) {
            return X(this.checkEdit(t, e));
          }
          removeIncidents(t, e = {}) {
            return X(this.checkDelete(t, e));
          }
          recalcScratchValues(t) {}
          checkAddition(t) {
            return H;
          }
          checkEdit(t, e) {
            return H;
          }
          checkDelete(t, e) {
            return H;
          }
          checkResizedIncidents(t) {
            return H;
          }
          moveTo(t, e, n, s) {}
        }
        var U = Object.defineProperty,
          W = (t, e, n) => (
            ((t, e, n) => {
              e in t
                ? U(t, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: n,
                  })
                : (t[e] = n);
            })(t, "symbol" != typeof e ? e + "" : e, n),
            n
          );
        class q extends Y {
          constructor() {
            super(...arguments),
              W(this, "incidents", []),
              W(this, "incidentsById", {});
          }
          onInitialise() {
            (this.incidents = []), (this.incidentsById = {});
          }
          _incidentById(t) {
            return this.incidentsById[t];
          }
          _resize(t) {
            for (let e = 0; e < this.incidents.length; e++)
              this.incidents[e].millisecond *= t;
          }
          checkAddition(t) {
            const e = [],
              n = {},
              s = [];
            for (let i = 0; i < t.length; i++)
              (n[t[i].id] = t[i].incident),
                s.push({ id: t[i].id, millisecond: t[i].millisecond }),
                x(this.incidentsById, t[i].id) &&
                  (j.error(
                    `Incident with the id ${t[i].id} already exists. Addition is rejected.`
                  ),
                  e.push({
                    type: "Already existing id",
                    meta: { id: t[i].id },
                  }));
            return e.length > 0
              ? { result: !1, errors: e }
              : {
                  result: !0,
                  execute: () => {
                    (this.incidentsById = Object.assign(this.incidentsById, n)),
                      this.incidents || (this.incidents = []),
                      this.incidents.push(...s),
                      this.incidents.sort(
                        (t, e) => t.millisecond - e.millisecond
                      );
                    for (let e = 0; e < t.length; e++)
                      this._incidentById(t[e].id)._onGetContextOnce(
                        this.context
                      );
                  },
                };
          }
          checkEdit(t, e) {
            const n = this.incidents;
            return {
              result: !0,
              execute: function () {
                let s;
                for (let i = 0; i < t.length; i++) {
                  s = t[i].id;
                  for (let t = 0; t < n.length; t++)
                    if (n[t].id === s) {
                      n[t].millisecond += e;
                      break;
                    }
                }
                n.sort((t, e) => t.millisecond - e.millisecond);
              },
            };
          }
          checkDelete(t) {
            const e = this,
              n = [];
            for (let e = 0; e < t.length; e++) n.push(t[e].id);
            return {
              result: !0,
              execute: function () {
                const t = e.incidents.filter((t) => !n.includes(t.id));
                e.incidents = t;
                for (let t = 0; t < n.length; t++) delete e.incidentsById[n[t]];
              },
            };
          }
          checkResizedIncidents(t) {
            const e = this.incidents;
            return {
              result: !0,
              execute: function () {
                let n;
                for (let s = 0; s < t.length; s++) {
                  n = t[s].id;
                  for (let i = 0; i < e.length; i++)
                    if (e[i].id === n) {
                      e[i].millisecond += t[s].startDelta;
                      break;
                    }
                }
                e.sort((t, e) => t.millisecond - e.millisecond);
              },
            };
          }
          moveTo(t, e, n, s = !1) {
            if (s)
              for (let t = 0; t < this.incidents.length; t++) {
                const s = this.incidents[t],
                  i = this._incidentById(s.id);
                e < s.millisecond
                  ? i.onProgress(0, 0, n, !0)
                  : e > s.millisecond + i.duration
                  ? i.onProgress(1, i.duration, n, !0)
                  : i.onProgress(
                      (e - s.millisecond) / i.duration,
                      e - s.millisecond,
                      n,
                      !0
                    );
              }
            else
              for (let t = 0; t < this.incidents.length; t++) {
                const s = this.incidents[t],
                  r = this._incidentById(s.id);
                let o = s.millisecond;
                if (!i(r.duration, o)) continue;
                const a = (e - o) / r.duration,
                  l = a >= 1 ? 1 : a;
                (o = a >= 1 ? r.duration : e - o), r.onProgress(l, o, n, !1);
              }
            function i(n, s) {
              let i = e,
                r = t;
              return (
                e > t && ((i = r), (r = e)),
                (s + n >= i && s + n <= r) || (n + s >= r && s <= r)
              );
            }
          }
        }
        function G(t) {
          const e = new t.Class(t.attrs, t.props);
          if (!1 === e.result) return e;
          if (x(t, "incidents"))
            for (const n in t.incidents) {
              const s = t.incidents[n],
                i = G(s.leaf);
              if (!1 === i.result) return i;
              const r = e.addIncident(i, s.position);
              if (!1 === r.result) return r;
            }
          return e;
        }
        var Z = ((t) => ((t._UP = "up"), (t._DOWN = "down"), t))(Z || {}),
          K = ((t) => ((t._ROOTOFTREE = "native.tree.rootoftree"), t))(K || {});
        const J = "native.tree.bypass";
        var Q = Object.defineProperty,
          tt = (t, e, n) => (
            ((t, e, n) => {
              e in t
                ? Q(t, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: n,
                  })
                : (t[e] = n);
            })(t, "symbol" != typeof e ? e + "" : e, n),
            n
          );
        class et {
          constructor() {
            tt(this, "DescriptiveIncident"),
              tt(this, "blockID"),
              tt(this, "mc_plugin_npm_name"),
              tt(this, "id");
          }
          getIncidentsByChannel(t = 0, e = 0) {
            return {
              [this.mc_plugin_npm_name]: [
                {
                  millisecond: t,
                  parentMillisecond: e,
                  incident: this,
                  id: this.id,
                },
              ],
            };
          }
          setBlock(t, e = {}) {
            null != this.blockID || e.blockId || (this.blockID = A()),
              this.DescriptiveIncident
                ? this.DescriptiveIncident.putMessageOnPipe(
                    "setBlock",
                    {
                      id: this.blockID || e.blockId,
                      description: t,
                      incidentId: this.DescriptiveIncident.id,
                      realIncidentId: this.id,
                      options: e,
                    },
                    "rootClip",
                    { selfExecute: !0, direction: Z._UP }
                  )
                : j.error(
                    "Descriptive incident doesn't exist, failed to block"
                  );
          }
          unblock(t = null) {
            this.DescriptiveIncident
              ? this.DescriptiveIncident.putMessageOnPipe(
                  "unBlock",
                  { id: null != t ? t : this.blockID },
                  "rootClip",
                  { selfExecute: !0, direction: Z._UP }
                )
              : j.error(
                  "Descriptive incident doesn't exist, failed to unblock"
                );
          }
        }
        var nt = Object.defineProperty,
          st = (t, e, n) => (
            ((t, e, n) => {
              e in t
                ? nt(t, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: n,
                  })
                : (t[e] = n);
            })(t, "symbol" != typeof e ? e + "" : e, n),
            n
          );
        class it extends et {
          constructor(t = { animatedAttrs: {} }, e = {}, n) {
            var s;
            super(),
              st(this, "attributeKey"),
              st(this, "attrs"),
              st(this, "autoGenerated"),
              st(this, "context", {}),
              st(this, "dna"),
              st(this, "gotContext"),
              st(this, "hasIncidents"),
              st(this, "initialValues", {}),
              st(this, "mcid"),
              st(this, "modelId"),
              st(this, "plugin_channel_class"),
              st(this, "props"),
              st(this, "pureInitialValues"),
              st(this, "userDefinedInitialValues"),
              st(this, "runTimeInfo"),
              (this.attrs = t),
              (this.props = e),
              (this.dna = n),
              (this.context = (null == n ? void 0 : n.context) || {}),
              (this.mcid = null == n ? void 0 : n.mcid),
              (this.id = e.id || A()),
              (this.modelId = e.modelId),
              (this.gotContext = !1),
              (this.plugin_channel_class = Y),
              (this.mc_plugin_npm_name = u),
              x(e, "plugin_channel_class") &&
                (this.plugin_channel_class = e.plugin_channel_class),
              x(e, "mc_plugin_npm_name") &&
                (this.mc_plugin_npm_name = e.mc_plugin_npm_name),
              (this.hasIncidents = !1),
              (this.initialValues = {}),
              (this.userDefinedInitialValues = t.initialValues || {}),
              (this.pureInitialValues = null),
              (this.autoGenerated = !1),
              x(this.attrs, "animatedAttrs") &&
                (this.attributeKey = Object.keys(
                  null != (s = this.attrs.animatedAttrs) ? s : {}
                )[0]),
              this.onInitialise();
          }
          get duration() {}
          set duration(t) {}
          get selector() {
            return this.props.selector;
          }
          get animAttributes() {
            return this.attrs.animatedAttrs;
          }
          set animAttributes(t) {
            this.attrs.animatedAttrs[this.attributeKey] = t;
          }
          getScratchValue() {
            return 0;
          }
          get element() {
            return null === this.context
              ? []
              : this.context.getElementByMCID
              ? this.context.getElementByMCID(this.mcid)
              : this.context.getElements(this.selector)[0];
          }
          get targetValue() {
            return this.animAttributes[this.attributeKey];
          }
          getElementAttribute(t) {
            return this.element.getAttribute(t);
          }
          getFraction(t) {
            return t / this.props.duration;
          }
          hasUserDefinedInitialValue() {
            return x(this.userDefinedInitialValues, this.attributeKey);
          }
          setInitialValue(t, e = !0) {
            if (
              (e && (this.pureInitialValues = w(t)),
              this.hasUserDefinedInitialValue())
            )
              if (v(this.targetValue)) {
                for (const e in this.userDefinedInitialValues[
                  this.attributeKey
                ])
                  t[e] = this.userDefinedInitialValues[this.attributeKey][e];
                this.initialValues[this.attributeKey] = t;
              } else
                this.initialValues[this.attributeKey] =
                  this.userDefinedInitialValues[this.attributeKey];
            else this.initialValues[this.attributeKey] = t;
          }
          get initialValue() {
            return this.initialValues[this.attributeKey];
          }
          _onGetContextOnce(t) {
            try {
              if (this.context.fragment) return;
              this.gotContext || (this.onGetContext(), (this.gotContext = !0));
            } catch (t) {
              j.error(t, this.mcid);
            }
          }
          onGetContext() {
            j.info(
              'Overwrite the "onGetContext" method with the code you want to get executed',
              "info"
            );
          }
          lastWish() {}
          onInitialise() {
            j.info(
              'Overwrite the "onInialise" method with the code you want to get executed',
              "info"
            );
          }
          onProgress(t, e, n, s) {}
        }
        var rt = Object.defineProperty,
          ot = Object.defineProperties,
          at = Object.getOwnPropertyDescriptors,
          lt = Object.getOwnPropertySymbols,
          ct = Object.prototype.hasOwnProperty,
          ut = Object.prototype.propertyIsEnumerable,
          pt = (t, e, n) =>
            e in t
              ? rt(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (t[e] = n);
        class ht extends it {
          constructor(t, e, n) {
            var s;
            super(t, e, n),
              pt(this, "symbol" != typeof (s = "ownClip") ? s + "" : s, void 0),
              (this.runTimeInfo = { currentMillisecond: 0 });
          }
          get duration() {
            return this.DescriptiveIncident.realClip.duration;
          }
          lastWish() {
            this.ownClip && this.ownClip.context.unmount();
          }
          onGetContext() {
            const t =
                this.DescriptiveIncident.realClip.exportConstructionArguments(),
              e =
                ((n = this.context),
                (s = this.mcid),
                n.rootElement.querySelectorAll(`[${i}="${s}"]`)[0]);
            var n, s;
            const r = this.DescriptiveIncident.constructor,
              o =
                ((a = ((t, e) => {
                  for (var n in e || (e = {})) ct.call(e, n) && pt(t, n, e[n]);
                  if (lt) for (var n of lt(e)) ut.call(e, n) && pt(t, n, e[n]);
                  return t;
                })({}, t.props)),
                (l = {
                  selector: void 0,
                  host: e,
                  containerParams:
                    this.DescriptiveIncident.props.containerParams || {},
                  originalDims: r.originalDims || {},
                }),
                ot(a, at(l)));
            var a, l;
            (this.ownClip = new r.Incident(
              t.attrs,
              o,
              this.DescriptiveIncident
            )),
              (this.ownClip.clipCopyId = this.id),
              this.DescriptiveIncident.realClip.addContext(
                { clipId: this.id, context: this.ownClip.context },
                !0
              );
          }
          onProgress(t, e = !1) {
            if (!1 !== this.ownClip.ownContext.contextLoaded) {
              for (const n in this.DescriptiveIncident.realClip
                .instantiatedChannels)
                this.DescriptiveIncident.realClip.instantiatedChannels[
                  n
                ].moveTo(this.runTimeInfo.currentMillisecond, t, this.id, e);
              this.runTimeInfo.currentMillisecond = t;
            } else this.setBlock("context loading", { blockId: this.id });
          }
        }
        var dt = Object.defineProperty,
          mt = Object.defineProperties,
          ft = Object.getOwnPropertyDescriptors,
          gt = Object.getOwnPropertySymbols,
          yt = Object.prototype.hasOwnProperty,
          vt = Object.prototype.propertyIsEnumerable,
          bt = (t, e, n) =>
            e in t
              ? dt(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (t[e] = n),
          xt = (t, e) => {
            for (var n in e || (e = {})) yt.call(e, n) && bt(t, n, e[n]);
            if (gt) for (var n of gt(e)) vt.call(e, n) && bt(t, n, e[n]);
            return t;
          },
          wt = (t, e) => mt(t, ft(e));
        function Ct(t, e = !1) {
          const n = e
              ? t.DescriptiveIncident
              : { context: t.context, mcid: t.mcid },
            s = new t.Incident(
              t.attrs,
              wt(xt({}, t.props), { id: t.id || A() }),
              n
            );
          return (
            (s.mc_plugin_npm_name = t.plugin_npm_name),
            (s.plugin_channel_class = t.Channel),
            (s.DescriptiveIncident = t.DescriptiveIncident),
            s
          );
        }
        const It =
          "Incidents with dynamic duration can't be resized. Once the Incident enters a Clip it'll become resizable";
        var Pt = Object.defineProperty;
        const Et = {
            supportedTypes: [
              "amount",
              "color",
              "date",
              "email",
              "measurement",
              "number",
              "string",
            ],
            preface: "attribute",
          },
          kt = new RegExp(`^@${Et.preface}\\([_A-z0-9-]*\\)$`),
          St = {
            Handler: class {
              constructor(t) {
                var e;
                ((t, e, n) => {
                  ((t, e, n) => {
                    e in t
                      ? Pt(t, e, {
                          enumerable: !0,
                          configurable: !0,
                          writable: !0,
                          value: n,
                        })
                      : (t[e] = n);
                  })(this, e + "", void 0);
                })(0, "expressionProps"),
                  (this.expressionProps = {
                    attribute:
                      null == (e = /\(([^)]+)\)/.exec(t.value)) ? void 0 : e[1],
                  });
              }
              calculateValues(t) {
                const e = [];
                for (let n = 0; n < t.length; n++) {
                  let s = t[n].getAttribute(this.expressionProps.attribute);
                  g(s) && (s = parseFloat(s)), e.push(s);
                }
                return e;
              }
            },
            validation: function (t, e, n) {
              return kt.test(t);
            },
            preface: Et.preface,
            supportedTypes: Et.supportedTypes,
          },
          Ot = {
            supportedTypes: ["amount", "measurement", "number"],
            preface: "expression",
          };
        var Mt = Object.getOwnPropertyNames,
          At = (t, e) =>
            function () {
              return (
                e || (0, t[Mt(t)[0]])((e = { exports: {} }).exports, e),
                e.exports
              );
            },
          _t = "INUMBER",
          Tt = "IOP1",
          Dt = "IOP2",
          Bt = "IOP3",
          Lt = "IVAR",
          jt = "IVARNAME",
          Vt = "IFUNCALL",
          Nt = "IFUNDEF",
          $t = "IEXPR",
          Rt = "IEXPREVAL",
          Ft = "IMEMBER",
          zt = "IENDSTATEMENT",
          Xt = "IARRAY";
        function Ht(t, e) {
          (this.type = t), (this.value = null != e ? e : 0);
        }
        function Yt(t) {
          return new Ht(Tt, t);
        }
        function Ut(t) {
          return new Ht(Dt, t);
        }
        function Wt(t) {
          return new Ht(Bt, t);
        }
        function qt(t, e, n, s, i) {
          for (var r, o, a, l, c = [], u = [], p = 0; p < t.length; p++) {
            var h = t[p],
              d = h.type;
            if (d === _t || d === jt)
              Array.isArray(h.value)
                ? c.push.apply(
                    c,
                    qt(
                      h.value
                        .map(function (t) {
                          return new Ht(_t, t);
                        })
                        .concat(new Ht(Xt, h.value.length)),
                      e,
                      n,
                      s,
                      i
                    )
                  )
                : c.push(h);
            else if (d === Lt && i.hasOwnProperty(h.value))
              (h = new Ht(_t, i[h.value])), c.push(h);
            else if (d === Dt && c.length > 1)
              (o = c.pop()),
                (r = c.pop()),
                (l = n[h.value]),
                (h = new Ht(_t, l(r.value, o.value))),
                c.push(h);
            else if (d === Bt && c.length > 2)
              (a = c.pop()),
                (o = c.pop()),
                (r = c.pop()),
                "?" === h.value
                  ? c.push(r.value ? o.value : a.value)
                  : ((l = s[h.value]),
                    (h = new Ht(_t, l(r.value, o.value, a.value))),
                    c.push(h));
            else if (d === Tt && c.length > 0)
              (r = c.pop()),
                (l = e[h.value]),
                (h = new Ht(_t, l(r.value))),
                c.push(h);
            else if (d === $t) {
              for (; c.length > 0; ) u.push(c.shift());
              u.push(new Ht($t, qt(h.value, e, n, s, i)));
            } else if (d === Ft && c.length > 0)
              (r = c.pop()), c.push(new Ht(_t, r.value[h.value]));
            else {
              for (; c.length > 0; ) u.push(c.shift());
              u.push(h);
            }
          }
          for (; c.length > 0; ) u.push(c.shift());
          return u;
        }
        function Gt(t, e, n) {
          for (var s = [], i = 0; i < t.length; i++) {
            var r = t[i],
              o = r.type;
            if (o === Lt && r.value === e)
              for (var a = 0; a < n.tokens.length; a++) {
                var l,
                  c = n.tokens[a];
                (l =
                  c.type === Tt
                    ? Yt(c.value)
                    : c.type === Dt
                    ? Ut(c.value)
                    : c.type === Bt
                    ? Wt(c.value)
                    : new Ht(c.type, c.value)),
                  s.push(l);
              }
            else o === $t ? s.push(new Ht($t, Gt(r.value, e, n))) : s.push(r);
          }
          return s;
        }
        function Zt(t, e, n) {
          var s,
            i,
            r,
            o,
            a,
            l,
            c = [];
          if (Jt(t)) return Qt(t, n);
          for (var u = t.length, p = 0; p < u; p++) {
            var h = t[p],
              d = h.type;
            if (d === _t || d === jt) c.push(h.value);
            else if (d === Dt)
              (i = c.pop()),
                (s = c.pop()),
                "and" === h.value
                  ? c.push(!!s && !!Zt(i, e, n))
                  : "or" === h.value
                  ? c.push(!!s || !!Zt(i, e, n))
                  : "=" === h.value
                  ? ((o = e.binaryOps[h.value]), c.push(o(s, Zt(i, e, n), n)))
                  : ((o = e.binaryOps[h.value]), c.push(o(Qt(s, n), Qt(i, n))));
            else if (d === Bt)
              (r = c.pop()),
                (i = c.pop()),
                (s = c.pop()),
                "?" === h.value
                  ? c.push(Zt(s ? i : r, e, n))
                  : ((o = e.ternaryOps[h.value]),
                    c.push(o(Qt(s, n), Qt(i, n), Qt(r, n))));
            else if (d === Lt)
              if (h.value in e.functions) c.push(e.functions[h.value]);
              else if (
                h.value in e.unaryOps &&
                e.parser.isOperatorEnabled(h.value)
              )
                c.push(e.unaryOps[h.value]);
              else {
                var m = n[h.value];
                if (void 0 === m)
                  throw new Error("undefined variable: " + h.value);
                c.push(m);
              }
            else if (d === Tt)
              (s = c.pop()), (o = e.unaryOps[h.value]), c.push(o(Qt(s, n)));
            else if (d === Vt) {
              for (l = h.value, a = []; l-- > 0; ) a.unshift(Qt(c.pop(), n));
              if (!(o = c.pop()).apply || !o.call)
                throw new Error(o + " is not a function");
              c.push(o.apply(void 0, a));
            } else if (d === Nt)
              c.push(
                (function () {
                  for (var t = c.pop(), s = [], i = h.value; i-- > 0; )
                    s.unshift(c.pop());
                  var r = c.pop(),
                    o = function () {
                      for (
                        var i = Object.assign({}, n), r = 0, o = s.length;
                        r < o;
                        r++
                      )
                        i[s[r]] = arguments[r];
                      return Zt(t, e, i);
                    };
                  return (
                    Object.defineProperty(o, "name", {
                      value: r,
                      writable: !1,
                    }),
                    (n[r] = o),
                    o
                  );
                })()
              );
            else if (d === $t) c.push(Kt(h, e));
            else if (d === Rt) c.push(h);
            else if (d === Ft) (s = c.pop()), c.push(s[h.value]);
            else if (d === zt) c.pop();
            else {
              if (d !== Xt) throw new Error("invalid Expression");
              for (l = h.value, a = []; l-- > 0; ) a.unshift(c.pop());
              c.push(a);
            }
          }
          if (c.length > 1) throw new Error("invalid Expression (parity)");
          return 0 === c[0] ? 0 : Qt(c[0], n);
        }
        function Kt(t, e, n) {
          return Jt(t)
            ? t
            : {
                type: Rt,
                value: function (n) {
                  return Zt(t.value, e, n);
                },
              };
        }
        function Jt(t) {
          return t && t.type === Rt;
        }
        function Qt(t, e) {
          return Jt(t) ? t.value(e) : t;
        }
        function te(t, e) {
          for (var n, s, i, r, o, a, l = [], c = 0; c < t.length; c++) {
            var u = t[c],
              p = u.type;
            if (p === _t)
              "number" == typeof u.value && u.value < 0
                ? l.push("(" + u.value + ")")
                : Array.isArray(u.value)
                ? l.push("[" + u.value.map(ee).join(", ") + "]")
                : l.push(ee(u.value));
            else if (p === Dt)
              (s = l.pop()),
                (n = l.pop()),
                (r = u.value),
                e
                  ? "^" === r
                    ? l.push("Math.pow(" + n + ", " + s + ")")
                    : "and" === r
                    ? l.push("(!!" + n + " && !!" + s + ")")
                    : "or" === r
                    ? l.push("(!!" + n + " || !!" + s + ")")
                    : "||" === r
                    ? l.push(
                        "(function(a,b){ return Array.isArray(a) && Array.isArray(b) ? a.concat(b) : String(a) + String(b); }((" +
                          n +
                          "),(" +
                          s +
                          ")))"
                      )
                    : "==" === r
                    ? l.push("(" + n + " === " + s + ")")
                    : "!=" === r
                    ? l.push("(" + n + " !== " + s + ")")
                    : "[" === r
                    ? l.push(n + "[(" + s + ") | 0]")
                    : l.push("(" + n + " " + r + " " + s + ")")
                  : "[" === r
                  ? l.push(n + "[" + s + "]")
                  : l.push("(" + n + " " + r + " " + s + ")");
            else if (p === Bt) {
              if (
                ((i = l.pop()),
                (s = l.pop()),
                (n = l.pop()),
                "?" !== (r = u.value))
              )
                throw new Error("invalid Expression");
              l.push("(" + n + " ? " + s + " : " + i + ")");
            } else if (p === Lt || p === jt) l.push(u.value);
            else if (p === Tt)
              (n = l.pop()),
                "-" === (r = u.value) || "+" === r
                  ? l.push("(" + r + n + ")")
                  : e
                  ? "not" === r
                    ? l.push("(!" + n + ")")
                    : "!" === r
                    ? l.push("fac(" + n + ")")
                    : l.push(r + "(" + n + ")")
                  : "!" === r
                  ? l.push("(" + n + "!)")
                  : l.push("(" + r + " " + n + ")");
            else if (p === Vt) {
              for (a = u.value, o = []; a-- > 0; ) o.unshift(l.pop());
              (r = l.pop()), l.push(r + "(" + o.join(", ") + ")");
            } else if (p === Nt) {
              for (s = l.pop(), a = u.value, o = []; a-- > 0; )
                o.unshift(l.pop());
              (n = l.pop()),
                e
                  ? l.push(
                      "(" +
                        n +
                        " = function(" +
                        o.join(", ") +
                        ") { return " +
                        s +
                        " })"
                    )
                  : l.push("(" + n + "(" + o.join(", ") + ") = " + s + ")");
            } else if (p === Ft) (n = l.pop()), l.push(n + "." + u.value);
            else if (p === Xt) {
              for (a = u.value, o = []; a-- > 0; ) o.unshift(l.pop());
              l.push("[" + o.join(", ") + "]");
            } else if (p === $t) l.push("(" + te(u.value, e) + ")");
            else if (p !== zt) throw new Error("invalid Expression");
          }
          return (
            l.length > 1 && (l = e ? [l.join(",")] : [l.join(";")]),
            String(l[0])
          );
        }
        function ee(t) {
          return "string" == typeof t
            ? JSON.stringify(t)
                .replace(/\u2028/g, "\\u2028")
                .replace(/\u2029/g, "\\u2029")
            : t;
        }
        function ne(t, e) {
          for (var n = 0; n < t.length; n++) if (t[n] === e) return !0;
          return !1;
        }
        function se(t, e, n) {
          for (
            var s = !!(n = n || {}).withMembers, i = null, r = 0;
            r < t.length;
            r++
          ) {
            var o = t[r];
            o.type === Lt || o.type === jt
              ? s || ne(e, o.value)
                ? null !== i
                  ? (ne(e, i) || e.push(i), (i = o.value))
                  : (i = o.value)
                : e.push(o.value)
              : o.type === Ft && s && null !== i
              ? (i += "." + o.value)
              : o.type === $t
              ? se(o.value, e, n)
              : null !== i && (ne(e, i) || e.push(i), (i = null));
          }
          null === i || ne(e, i) || e.push(i);
        }
        function ie(t, e) {
          (this.tokens = t),
            (this.parser = e),
            (this.unaryOps = e.unaryOps),
            (this.binaryOps = e.binaryOps),
            (this.ternaryOps = e.ternaryOps),
            (this.functions = e.functions);
        }
        (Ht.prototype.toString = function () {
          switch (this.type) {
            case _t:
            case Tt:
            case Dt:
            case Bt:
            case Lt:
            case jt:
            case zt:
              return this.value;
            case Vt:
              return "CALL " + this.value;
            case Nt:
              return "DEF " + this.value;
            case Xt:
              return "ARRAY " + this.value;
            case Ft:
              return "." + this.value;
            default:
              return "Invalid Instruction";
          }
        }),
          (ie.prototype.simplify = function (t) {
            return (
              (t = t || {}),
              new ie(
                qt(
                  this.tokens,
                  this.unaryOps,
                  this.binaryOps,
                  this.ternaryOps,
                  t
                ),
                this.parser
              )
            );
          }),
          (ie.prototype.substitute = function (t, e) {
            return (
              e instanceof ie || (e = this.parser.parse(String(e))),
              new ie(Gt(this.tokens, t, e), this.parser)
            );
          }),
          (ie.prototype.evaluate = function (t) {
            return (t = t || {}), Zt(this.tokens, this, t);
          }),
          (ie.prototype.toString = function () {
            return te(this.tokens, !1);
          }),
          (ie.prototype.symbols = function (t) {
            t = t || {};
            var e = [];
            return se(this.tokens, e, t), e;
          }),
          (ie.prototype.variables = function (t) {
            t = t || {};
            var e = [];
            se(this.tokens, e, t);
            var n = this.functions;
            return e.filter(function (t) {
              return !(t in n);
            });
          }),
          (ie.prototype.toJSFunction = function (t, e) {
            var n = this,
              s = new Function(
                t,
                "with(this.functions) with (this.ternaryOps) with (this.binaryOps) with (this.unaryOps) { return " +
                  te(this.simplify(e).tokens, !0) +
                  "; }"
              );
            return function () {
              return s.apply(n, arguments);
            };
          });
        var re = "TEOF",
          oe = "TOP",
          ae = "TNUMBER",
          le = "TSTRING",
          ce = "TPAREN",
          ue = "TBRACKET",
          pe = "TCOMMA",
          he = "TNAME",
          de = "TSEMICOLON";
        function me(t, e, n) {
          (this.type = t), (this.value = e), (this.index = n);
        }
        function fe(t, e) {
          (this.pos = 0),
            (this.current = null),
            (this.unaryOps = t.unaryOps),
            (this.binaryOps = t.binaryOps),
            (this.ternaryOps = t.ternaryOps),
            (this.consts = t.consts),
            (this.expression = e),
            (this.savedPosition = 0),
            (this.savedCurrent = null),
            (this.options = t.options),
            (this.parser = t);
        }
        (me.prototype.toString = function () {
          return this.type + ": " + this.value;
        }),
          (fe.prototype.newToken = function (t, e, n) {
            return new me(t, e, null != n ? n : this.pos);
          }),
          (fe.prototype.save = function () {
            (this.savedPosition = this.pos), (this.savedCurrent = this.current);
          }),
          (fe.prototype.restore = function () {
            (this.pos = this.savedPosition), (this.current = this.savedCurrent);
          }),
          (fe.prototype.next = function () {
            return this.pos >= this.expression.length
              ? this.newToken(re, "EOF")
              : this.isWhitespace() || this.isComment()
              ? this.next()
              : this.isRadixInteger() ||
                this.isNumber() ||
                this.isOperator() ||
                this.isString() ||
                this.isParen() ||
                this.isBracket() ||
                this.isComma() ||
                this.isSemicolon() ||
                this.isNamedOp() ||
                this.isConst() ||
                this.isName()
              ? this.current
              : void this.parseError(
                  'Unknown character "' + this.expression.charAt(this.pos) + '"'
                );
          }),
          (fe.prototype.isString = function () {
            var t = !1,
              e = this.pos,
              n = this.expression.charAt(e);
            if ("'" === n || '"' === n)
              for (
                var s = this.expression.indexOf(n, e + 1);
                s >= 0 && this.pos < this.expression.length;

              ) {
                if (
                  ((this.pos = s + 1), "\\" !== this.expression.charAt(s - 1))
                ) {
                  var i = this.expression.substring(e + 1, s);
                  (this.current = this.newToken(le, this.unescape(i), e)),
                    (t = !0);
                  break;
                }
                s = this.expression.indexOf(n, s + 1);
              }
            return t;
          }),
          (fe.prototype.isParen = function () {
            var t = this.expression.charAt(this.pos);
            return (
              ("(" === t || ")" === t) &&
              ((this.current = this.newToken(ce, t)), this.pos++, !0)
            );
          }),
          (fe.prototype.isBracket = function () {
            var t = this.expression.charAt(this.pos);
            return !(
              ("[" !== t && "]" !== t) ||
              !this.isOperatorEnabled("[") ||
              ((this.current = this.newToken(ue, t)), this.pos++, 0)
            );
          }),
          (fe.prototype.isComma = function () {
            return (
              "," === this.expression.charAt(this.pos) &&
              ((this.current = this.newToken(pe, ",")), this.pos++, !0)
            );
          }),
          (fe.prototype.isSemicolon = function () {
            return (
              ";" === this.expression.charAt(this.pos) &&
              ((this.current = this.newToken(de, ";")), this.pos++, !0)
            );
          }),
          (fe.prototype.isConst = function () {
            for (var t = this.pos, e = t; e < this.expression.length; e++) {
              var n = this.expression.charAt(e);
              if (
                n.toUpperCase() === n.toLowerCase() &&
                (e === this.pos ||
                  ("_" !== n && "." !== n && (n < "0" || n > "9")))
              )
                break;
            }
            if (e > t) {
              var s = this.expression.substring(t, e);
              if (s in this.consts)
                return (
                  (this.current = this.newToken(ae, this.consts[s])),
                  (this.pos += s.length),
                  !0
                );
            }
            return !1;
          }),
          (fe.prototype.isNamedOp = function () {
            for (var t = this.pos, e = t; e < this.expression.length; e++) {
              var n = this.expression.charAt(e);
              if (
                n.toUpperCase() === n.toLowerCase() &&
                (e === this.pos || ("_" !== n && (n < "0" || n > "9")))
              )
                break;
            }
            if (e > t) {
              var s = this.expression.substring(t, e);
              if (
                this.isOperatorEnabled(s) &&
                (s in this.binaryOps ||
                  s in this.unaryOps ||
                  s in this.ternaryOps)
              )
                return (
                  (this.current = this.newToken(oe, s)),
                  (this.pos += s.length),
                  !0
                );
            }
            return !1;
          }),
          (fe.prototype.isName = function () {
            for (
              var t = this.pos, e = t, n = !1;
              e < this.expression.length;
              e++
            ) {
              var s = this.expression.charAt(e);
              if (s.toUpperCase() === s.toLowerCase()) {
                if (e === this.pos && ("$" === s || "_" === s)) {
                  "_" === s && (n = !0);
                  continue;
                }
                if (e === this.pos || !n || ("_" !== s && (s < "0" || s > "9")))
                  break;
              } else n = !0;
            }
            if (n) {
              var i = this.expression.substring(t, e);
              return (
                (this.current = this.newToken(he, i)),
                (this.pos += i.length),
                !0
              );
            }
            return !1;
          }),
          (fe.prototype.isWhitespace = function () {
            for (
              var t = !1, e = this.expression.charAt(this.pos);
              !(
                (" " !== e && "\t" !== e && "\n" !== e && "\r" !== e) ||
                ((t = !0), this.pos++, this.pos >= this.expression.length)
              );

            )
              e = this.expression.charAt(this.pos);
            return t;
          });
        var ge = /^[0-9a-f]{4}$/i;
        function ye(t, e, n) {
          (this.parser = t),
            (this.tokens = e),
            (this.current = null),
            (this.nextToken = null),
            this.next(),
            (this.savedCurrent = null),
            (this.savedNextToken = null),
            (this.allowMemberAccess = !1 !== n.allowMemberAccess);
        }
        (fe.prototype.unescape = function (t) {
          var e = t.indexOf("\\");
          if (e < 0) return t;
          for (var n = t.substring(0, e); e >= 0; ) {
            var s = t.charAt(++e);
            switch (s) {
              case "'":
                n += "'";
                break;
              case '"':
                n += '"';
                break;
              case "\\":
                n += "\\";
                break;
              case "/":
                n += "/";
                break;
              case "b":
                n += "\b";
                break;
              case "f":
                n += "\f";
                break;
              case "n":
                n += "\n";
                break;
              case "r":
                n += "\r";
                break;
              case "t":
                n += "\t";
                break;
              case "u":
                var i = t.substring(e + 1, e + 5);
                ge.test(i) ||
                  this.parseError("Illegal escape sequence: \\u" + i),
                  (n += String.fromCharCode(parseInt(i, 16))),
                  (e += 4);
                break;
              default:
                throw this.parseError('Illegal escape sequence: "\\' + s + '"');
            }
            ++e;
            var r = t.indexOf("\\", e);
            (n += t.substring(e, r < 0 ? t.length : r)), (e = r);
          }
          return n;
        }),
          (fe.prototype.isComment = function () {
            return (
              "/" === this.expression.charAt(this.pos) &&
              "*" === this.expression.charAt(this.pos + 1) &&
              ((this.pos = this.expression.indexOf("*/", this.pos) + 2),
              1 === this.pos && (this.pos = this.expression.length),
              !0)
            );
          }),
          (fe.prototype.isRadixInteger = function () {
            var t,
              e,
              n = this.pos;
            if (
              n >= this.expression.length - 2 ||
              "0" !== this.expression.charAt(n)
            )
              return !1;
            if ((++n, "x" === this.expression.charAt(n)))
              (t = 16), (e = /^[0-9a-f]$/i), ++n;
            else {
              if ("b" !== this.expression.charAt(n)) return !1;
              (t = 2), (e = /^[01]$/i), ++n;
            }
            for (var s = !1, i = n; n < this.expression.length; ) {
              var r = this.expression.charAt(n);
              if (!e.test(r)) break;
              n++, (s = !0);
            }
            return (
              s &&
                ((this.current = this.newToken(
                  ae,
                  parseInt(this.expression.substring(i, n), t)
                )),
                (this.pos = n)),
              s
            );
          }),
          (fe.prototype.isNumber = function () {
            for (
              var t, e = !1, n = this.pos, s = n, i = n, r = !1, o = !1;
              n < this.expression.length &&
              (((t = this.expression.charAt(n)) >= "0" && t <= "9") ||
                (!r && "." === t));

            )
              "." === t ? (r = !0) : (o = !0), n++, (e = o);
            if ((e && (i = n), "e" === t || "E" === t)) {
              n++;
              for (var a = !0, l = !1; n < this.expression.length; ) {
                if (
                  ((t = this.expression.charAt(n)),
                  !a || ("+" !== t && "-" !== t))
                ) {
                  if (!(t >= "0" && t <= "9")) break;
                  (l = !0), (a = !1);
                } else a = !1;
                n++;
              }
              l || (n = i);
            }
            return (
              e
                ? ((this.current = this.newToken(
                    ae,
                    parseFloat(this.expression.substring(s, n))
                  )),
                  (this.pos = n))
                : (this.pos = i),
              e
            );
          }),
          (fe.prototype.isOperator = function () {
            var t = this.pos,
              e = this.expression.charAt(this.pos);
            if (
              "+" === e ||
              "-" === e ||
              "*" === e ||
              "/" === e ||
              "%" === e ||
              "^" === e ||
              "?" === e ||
              ":" === e ||
              "." === e
            )
              this.current = this.newToken(oe, e);
            else if ("" === e || "" === e)
              this.current = this.newToken(oe, "*");
            else if (">" === e)
              "=" === this.expression.charAt(this.pos + 1)
                ? ((this.current = this.newToken(oe, ">=")), this.pos++)
                : (this.current = this.newToken(oe, ">"));
            else if ("<" === e)
              "=" === this.expression.charAt(this.pos + 1)
                ? ((this.current = this.newToken(oe, "<=")), this.pos++)
                : (this.current = this.newToken(oe, "<"));
            else if ("|" === e) {
              if ("|" !== this.expression.charAt(this.pos + 1)) return !1;
              (this.current = this.newToken(oe, "||")), this.pos++;
            } else if ("=" === e)
              "=" === this.expression.charAt(this.pos + 1)
                ? ((this.current = this.newToken(oe, "==")), this.pos++)
                : (this.current = this.newToken(oe, e));
            else {
              if ("!" !== e) return !1;
              "=" === this.expression.charAt(this.pos + 1)
                ? ((this.current = this.newToken(oe, "!=")), this.pos++)
                : (this.current = this.newToken(oe, e));
            }
            return (
              this.pos++,
              !!this.isOperatorEnabled(this.current.value) ||
                ((this.pos = t), !1)
            );
          }),
          (fe.prototype.isOperatorEnabled = function (t) {
            return this.parser.isOperatorEnabled(t);
          }),
          (fe.prototype.getCoordinates = function () {
            var t,
              e = 0,
              n = -1;
            do {
              e++,
                (t = this.pos - n),
                (n = this.expression.indexOf("\n", n + 1));
            } while (n >= 0 && n < this.pos);
            return { line: e, column: t };
          }),
          (fe.prototype.parseError = function (t) {
            var e = this.getCoordinates();
            throw new Error(
              "parse error [" + e.line + ":" + e.column + "]: " + t
            );
          }),
          (ye.prototype.next = function () {
            return (
              (this.current = this.nextToken),
              (this.nextToken = this.tokens.next())
            );
          }),
          (ye.prototype.tokenMatches = function (t, e) {
            return (
              void 0 === e ||
              (Array.isArray(e)
                ? ne(e, t.value)
                : "function" == typeof e
                ? e(t)
                : t.value === e)
            );
          }),
          (ye.prototype.save = function () {
            (this.savedCurrent = this.current),
              (this.savedNextToken = this.nextToken),
              this.tokens.save();
          }),
          (ye.prototype.restore = function () {
            this.tokens.restore(),
              (this.current = this.savedCurrent),
              (this.nextToken = this.savedNextToken);
          }),
          (ye.prototype.accept = function (t, e) {
            return !(
              this.nextToken.type !== t ||
              !this.tokenMatches(this.nextToken, e) ||
              (this.next(), 0)
            );
          }),
          (ye.prototype.expect = function (t, e) {
            if (!this.accept(t, e)) {
              var n = this.tokens.getCoordinates();
              throw new Error(
                "parse error [" +
                  n.line +
                  ":" +
                  n.column +
                  "]: Expected " +
                  (e || t)
              );
            }
          }),
          (ye.prototype.parseAtom = function (t) {
            var e = this.tokens.unaryOps;
            if (
              this.accept(he) ||
              this.accept(oe, function (t) {
                return t.value in e;
              })
            )
              t.push(new Ht(Lt, this.current.value));
            else if (this.accept(ae)) t.push(new Ht(_t, this.current.value));
            else if (this.accept(le)) t.push(new Ht(_t, this.current.value));
            else if (this.accept(ce, "("))
              this.parseExpression(t), this.expect(ce, ")");
            else {
              if (!this.accept(ue, "["))
                throw new Error("unexpected " + this.nextToken);
              if (this.accept(ue, "]")) t.push(new Ht(Xt, 0));
              else {
                var n = this.parseArrayList(t);
                t.push(new Ht(Xt, n));
              }
            }
          }),
          (ye.prototype.parseExpression = function (t) {
            var e = [];
            this.parseUntilEndStatement(t, e) ||
              (this.parseVariableAssignmentExpression(e),
              this.parseUntilEndStatement(t, e) || this.pushExpression(t, e));
          }),
          (ye.prototype.pushExpression = function (t, e) {
            for (var n = 0, s = e.length; n < s; n++) t.push(e[n]);
          }),
          (ye.prototype.parseUntilEndStatement = function (t, e) {
            return (
              !!this.accept(de) &&
              (!this.nextToken ||
                this.nextToken.type === re ||
                (this.nextToken.type === ce && ")" === this.nextToken.value) ||
                e.push(new Ht(zt)),
              this.nextToken.type !== re && this.parseExpression(e),
              t.push(new Ht($t, e)),
              !0)
            );
          }),
          (ye.prototype.parseArrayList = function (t) {
            for (var e = 0; !this.accept(ue, "]"); )
              for (this.parseExpression(t), ++e; this.accept(pe); )
                this.parseExpression(t), ++e;
            return e;
          }),
          (ye.prototype.parseVariableAssignmentExpression = function (t) {
            for (this.parseConditionalExpression(t); this.accept(oe, "="); ) {
              var e = t.pop(),
                n = [],
                s = t.length - 1;
              if (e.type !== Vt) {
                if (e.type !== Lt && e.type !== Ft)
                  throw new Error("expected variable for assignment");
                this.parseVariableAssignmentExpression(n),
                  t.push(new Ht(jt, e.value)),
                  t.push(new Ht($t, n)),
                  t.push(Ut("="));
              } else {
                if (!this.tokens.isOperatorEnabled("()="))
                  throw new Error("function definition is not permitted");
                for (var i = 0, r = e.value + 1; i < r; i++) {
                  var o = s - i;
                  t[o].type === Lt && (t[o] = new Ht(jt, t[o].value));
                }
                this.parseVariableAssignmentExpression(n),
                  t.push(new Ht($t, n)),
                  t.push(new Ht(Nt, e.value));
              }
            }
          }),
          (ye.prototype.parseConditionalExpression = function (t) {
            for (this.parseOrExpression(t); this.accept(oe, "?"); ) {
              var e = [],
                n = [];
              this.parseConditionalExpression(e),
                this.expect(oe, ":"),
                this.parseConditionalExpression(n),
                t.push(new Ht($t, e)),
                t.push(new Ht($t, n)),
                t.push(Wt("?"));
            }
          }),
          (ye.prototype.parseOrExpression = function (t) {
            for (this.parseAndExpression(t); this.accept(oe, "or"); ) {
              var e = [];
              this.parseAndExpression(e),
                t.push(new Ht($t, e)),
                t.push(Ut("or"));
            }
          }),
          (ye.prototype.parseAndExpression = function (t) {
            for (this.parseComparison(t); this.accept(oe, "and"); ) {
              var e = [];
              this.parseComparison(e), t.push(new Ht($t, e)), t.push(Ut("and"));
            }
          });
        var ve = ["==", "!=", "<", "<=", ">=", ">", "in"];
        ye.prototype.parseComparison = function (t) {
          for (this.parseAddSub(t); this.accept(oe, ve); ) {
            var e = this.current;
            this.parseAddSub(t), t.push(Ut(e.value));
          }
        };
        var be = ["+", "-", "||"];
        ye.prototype.parseAddSub = function (t) {
          for (this.parseTerm(t); this.accept(oe, be); ) {
            var e = this.current;
            this.parseTerm(t), t.push(Ut(e.value));
          }
        };
        var xe = ["*", "/", "%"];
        function we(t, e) {
          return Number(t) + Number(e);
        }
        function Ce(t, e) {
          return t - e;
        }
        function Ie(t, e) {
          return t * e;
        }
        function Pe(t, e) {
          return t / e;
        }
        function Ee(t, e) {
          return t % e;
        }
        function ke(t, e) {
          return Array.isArray(t) && Array.isArray(e)
            ? t.concat(e)
            : "" + t + e;
        }
        function Se(t, e) {
          return t === e;
        }
        function Oe(t, e) {
          return t !== e;
        }
        function Me(t, e) {
          return t > e;
        }
        function Ae(t, e) {
          return t < e;
        }
        function _e(t, e) {
          return t >= e;
        }
        function Te(t, e) {
          return t <= e;
        }
        function De(t, e) {
          return Boolean(t && e);
        }
        function Be(t, e) {
          return Boolean(t || e);
        }
        function Le(t, e) {
          return ne(e, t);
        }
        function je(t) {
          return (Math.exp(t) - Math.exp(-t)) / 2;
        }
        function Ve(t) {
          return (Math.exp(t) + Math.exp(-t)) / 2;
        }
        function Ne(t) {
          return t === 1 / 0
            ? 1
            : t === -1 / 0
            ? -1
            : (Math.exp(t) - Math.exp(-t)) / (Math.exp(t) + Math.exp(-t));
        }
        function $e(t) {
          return t === -1 / 0 ? t : Math.log(t + Math.sqrt(t * t + 1));
        }
        function Re(t) {
          return Math.log(t + Math.sqrt(t * t - 1));
        }
        function Fe(t) {
          return Math.log((1 + t) / (1 - t)) / 2;
        }
        function ze(t) {
          return Math.log(t) * Math.LOG10E;
        }
        function Xe(t) {
          return -t;
        }
        function He(t) {
          return !t;
        }
        function Ye(t) {
          return t < 0 ? Math.ceil(t) : Math.floor(t);
        }
        function Ue(t) {
          return Math.random() * (t || 1);
        }
        function We(t) {
          return Ze(t + 1);
        }
        (ye.prototype.parseTerm = function (t) {
          for (this.parseFactor(t); this.accept(oe, xe); ) {
            var e = this.current;
            this.parseFactor(t), t.push(Ut(e.value));
          }
        }),
          (ye.prototype.parseFactor = function (t) {
            var e = this.tokens.unaryOps;
            if (
              (this.save(),
              this.accept(oe, function (t) {
                return t.value in e;
              }))
            ) {
              if ("-" !== this.current.value && "+" !== this.current.value) {
                if (this.nextToken.type === ce && "(" === this.nextToken.value)
                  return this.restore(), void this.parseExponential(t);
                if (
                  this.nextToken.type === de ||
                  this.nextToken.type === pe ||
                  this.nextToken.type === re ||
                  (this.nextToken.type === ce && ")" === this.nextToken.value)
                )
                  return this.restore(), void this.parseAtom(t);
              }
              var n = this.current;
              this.parseFactor(t), t.push(Yt(n.value));
            } else this.parseExponential(t);
          }),
          (ye.prototype.parseExponential = function (t) {
            for (this.parsePostfixExpression(t); this.accept(oe, "^"); )
              this.parseFactor(t), t.push(Ut("^"));
          }),
          (ye.prototype.parsePostfixExpression = function (t) {
            for (this.parseFunctionCall(t); this.accept(oe, "!"); )
              t.push(Yt("!"));
          }),
          (ye.prototype.parseFunctionCall = function (t) {
            var e = this.tokens.unaryOps;
            if (
              this.accept(oe, function (t) {
                return t.value in e;
              })
            ) {
              var n = this.current;
              this.parseAtom(t), t.push(Yt(n.value));
            } else
              for (this.parseMemberExpression(t); this.accept(ce, "("); )
                if (this.accept(ce, ")")) t.push(new Ht(Vt, 0));
                else {
                  var s = this.parseArgumentList(t);
                  t.push(new Ht(Vt, s));
                }
          }),
          (ye.prototype.parseArgumentList = function (t) {
            for (var e = 0; !this.accept(ce, ")"); )
              for (this.parseExpression(t), ++e; this.accept(pe); )
                this.parseExpression(t), ++e;
            return e;
          }),
          (ye.prototype.parseMemberExpression = function (t) {
            for (
              this.parseAtom(t);
              this.accept(oe, ".") || this.accept(ue, "[");

            ) {
              var e = this.current;
              if ("." === e.value) {
                if (!this.allowMemberAccess)
                  throw new Error(
                    'unexpected ".", member access is not permitted'
                  );
                this.expect(he), t.push(new Ht(Ft, this.current.value));
              } else {
                if ("[" !== e.value)
                  throw new Error("unexpected symbol: " + e.value);
                if (!this.tokens.isOperatorEnabled("["))
                  throw new Error('unexpected "[]", arrays are disabled');
                this.parseExpression(t), this.expect(ue, "]"), t.push(Ut("["));
              }
            }
          });
        var qe = 4.7421875,
          Ge = [
            0.9999999999999971, 57.15623566586292, -59.59796035547549,
            14.136097974741746, -0.4919138160976202, 3399464998481189e-20,
            4652362892704858e-20, -9837447530487956e-20, 0.0001580887032249125,
            -0.00021026444172410488, 0.00021743961811521265,
            -0.0001643181065367639, 8441822398385275e-20,
            -26190838401581408e-21, 36899182659531625e-22,
          ];
        function Ze(t) {
          var e, n;
          if (
            (function (t) {
              return isFinite(t) && t === Math.round(t);
            })(t)
          ) {
            if (t <= 0) return isFinite(t) ? 1 / 0 : NaN;
            if (t > 171) return 1 / 0;
            for (var s = t - 2, i = t - 1; s > 1; ) (i *= s), s--;
            return 0 === i && (i = 1), i;
          }
          if (t < 0.5) return Math.PI / (Math.sin(Math.PI * t) * Ze(1 - t));
          if (t >= 171.35) return 1 / 0;
          if (t > 85) {
            var r = t * t,
              o = r * t,
              a = o * t,
              l = a * t;
            return (
              Math.sqrt((2 * Math.PI) / t) *
              Math.pow(t / Math.E, t) *
              (1 +
                1 / (12 * t) +
                1 / (288 * r) -
                139 / (51840 * o) -
                571 / (2488320 * a) +
                163879 / (209018880 * l) +
                5246819 / (75246796800 * l * t))
            );
          }
          --t, (n = Ge[0]);
          for (var c = 1; c < Ge.length; ++c) n += Ge[c] / (t + c);
          return (
            (e = t + qe + 0.5),
            Math.sqrt(2 * Math.PI) * Math.pow(e, t + 0.5) * Math.exp(-e) * n
          );
        }
        function Ke(t) {
          return Array.isArray(t) ? t.length : String(t).length;
        }
        function Je() {
          for (var t = 0, e = 0, n = 0; n < arguments.length; n++) {
            var s,
              i = Math.abs(arguments[n]);
            e < i
              ? ((t = t * (s = e / i) * s + 1), (e = i))
              : (t += i > 0 ? (s = i / e) * s : i);
          }
          return e === 1 / 0 ? 1 / 0 : e * Math.sqrt(t);
        }
        function Qe(t, e, n) {
          return t ? e : n;
        }
        function tn(t, e) {
          return void 0 === e || 0 == +e
            ? Math.round(t)
            : ((t = +t),
              (e = -+e),
              isNaN(t) || "number" != typeof e || e % 1 != 0
                ? NaN
                : ((t = t.toString().split("e")),
                  +(
                    (t = (t = Math.round(
                      +(t[0] + "e" + (t[1] ? +t[1] - e : -e))
                    ))
                      .toString()
                      .split("e"))[0] +
                    "e" +
                    (t[1] ? +t[1] + e : e)
                  )));
        }
        function en(t, e, n) {
          return n && (n[t] = e), e;
        }
        function nn(t, e) {
          return t[0 | e];
        }
        function sn(t) {
          return 1 === arguments.length && Array.isArray(t)
            ? Math.max.apply(Math, t)
            : Math.max.apply(Math, arguments);
        }
        function rn(t) {
          return 1 === arguments.length && Array.isArray(t)
            ? Math.min.apply(Math, t)
            : Math.min.apply(Math, arguments);
        }
        function on(t, e) {
          if ("function" != typeof t)
            throw new Error("First argument to map is not a function");
          if (!Array.isArray(e))
            throw new Error("Second argument to map is not an array");
          return e.map(function (e, n) {
            return t(e, n);
          });
        }
        function an(t, e, n) {
          if ("function" != typeof t)
            throw new Error("First argument to fold is not a function");
          if (!Array.isArray(n))
            throw new Error("Second argument to fold is not an array");
          return n.reduce(function (e, n, s) {
            return t(e, n, s);
          }, e);
        }
        function ln(t, e) {
          if ("function" != typeof t)
            throw new Error("First argument to filter is not a function");
          if (!Array.isArray(e))
            throw new Error("Second argument to filter is not an array");
          return e.filter(function (e, n) {
            return t(e, n);
          });
        }
        function cn(t, e) {
          if (!Array.isArray(e) && "string" != typeof e)
            throw new Error(
              "Second argument to indexOf is not a string or array"
            );
          return e.indexOf(t);
        }
        function un(t, e) {
          if (!Array.isArray(e))
            throw new Error("Second argument to join is not an array");
          return e.join(t);
        }
        function pn(t) {
          return (t > 0) - (t < 0) || +t;
        }
        var hn = 1 / 3;
        function dn(t) {
          return t < 0 ? -Math.pow(-t, hn) : Math.pow(t, hn);
        }
        function mn(t) {
          return Math.exp(t) - 1;
        }
        function fn(t) {
          return Math.log(1 + t);
        }
        function gn(t) {
          return Math.log(t) / Math.LN2;
        }
        function yn(t) {
          (this.options = t || {}),
            (this.unaryOps = {
              sin: Math.sin,
              cos: Math.cos,
              tan: Math.tan,
              asin: Math.asin,
              acos: Math.acos,
              atan: Math.atan,
              sinh: Math.sinh || je,
              cosh: Math.cosh || Ve,
              tanh: Math.tanh || Ne,
              asinh: Math.asinh || $e,
              acosh: Math.acosh || Re,
              atanh: Math.atanh || Fe,
              sqrt: Math.sqrt,
              cbrt: Math.cbrt || dn,
              log: Math.log,
              log2: Math.log2 || gn,
              ln: Math.log,
              lg: Math.log10 || ze,
              log10: Math.log10 || ze,
              expm1: Math.expm1 || mn,
              log1p: Math.log1p || fn,
              abs: Math.abs,
              ceil: Math.ceil,
              floor: Math.floor,
              round: Math.round,
              trunc: Math.trunc || Ye,
              "-": Xe,
              "+": Number,
              exp: Math.exp,
              not: He,
              length: Ke,
              "!": We,
              sign: Math.sign || pn,
            }),
            (this.binaryOps = {
              "+": we,
              "-": Ce,
              "*": Ie,
              "/": Pe,
              "%": Ee,
              "^": Math.pow,
              "||": ke,
              "==": Se,
              "!=": Oe,
              ">": Me,
              "<": Ae,
              ">=": _e,
              "<=": Te,
              and: De,
              or: Be,
              in: Le,
              "=": en,
              "[": nn,
            }),
            (this.ternaryOps = { "?": Qe }),
            (this.functions = {
              random: Ue,
              fac: We,
              min: rn,
              max: sn,
              hypot: Math.hypot || Je,
              pyt: Math.hypot || Je,
              pow: Math.pow,
              atan2: Math.atan2,
              if: Qe,
              gamma: Ze,
              roundTo: tn,
              map: on,
              fold: an,
              filter: ln,
              indexOf: cn,
              join: un,
            }),
            (this.consts = { E: Math.E, PI: Math.PI, true: !0, false: !1 });
        }
        (yn.prototype.parse = function (t) {
          var e = [],
            n = new ye(this, new fe(this, t), {
              allowMemberAccess: this.options.allowMemberAccess,
            });
          return n.parseExpression(e), n.expect(re, "EOF"), new ie(e, this);
        }),
          (yn.prototype.evaluate = function (t, e) {
            return this.parse(t).evaluate(e);
          });
        var vn = new yn();
        (yn.parse = function (t) {
          return vn.parse(t);
        }),
          (yn.evaluate = function (t, e) {
            return vn.parse(t).evaluate(e);
          });
        var bn = {
          "+": "add",
          "-": "subtract",
          "*": "multiply",
          "/": "divide",
          "%": "remainder",
          "^": "power",
          "!": "factorial",
          "<": "comparison",
          ">": "comparison",
          "<=": "comparison",
          ">=": "comparison",
          "==": "comparison",
          "!=": "comparison",
          "||": "concatenate",
          and: "logical",
          or: "logical",
          not: "logical",
          "?": "conditional",
          ":": "conditional",
          "=": "assignment",
          "[": "array",
          "()=": "fndef",
        };
        yn.prototype.isOperatorEnabled = function (t) {
          var e = (function (t) {
              return bn.hasOwnProperty(t) ? bn[t] : t;
            })(t),
            n = this.options.operators || {};
          return !(e in n) || !!n[e];
        };
        const xn = new Set([
          "getValue",
          "setValue",
          "_getFromProxy",
          "__createPathProxies",
          "hasOwnProperty",
          "pushValue",
          "removePathKey",
          "removeKey",
          "restoreKey",
          "getKeys",
          "exportFlattened",
          "isArray",
          "push",
          "sortBy",
          "findIndex",
        ]);
        function wn(t) {
          const e = {},
            n = new Set(),
            s = Array.isArray(t);
          let i = s ? t.length : 0,
            r = null;
          return new Proxy(t, {
            get: function (o, a) {
              return "length" === a && s
                ? i
                : xn.has(a)
                ? this[a]
                : n.has(a)
                ? void 0
                : (s && null !== r && (a = r[a]), x(e, a) ? e[a] : t[a]);
            },
            isArray: () => s,
            _getFromProxy: (t) => (x(e, t) ? e[t] : void 0),
            set: T,
            sortBy(t) {
              return (
                (r = null),
                !!s &&
                  ((r = (function (t, e) {
                    const n = [];
                    for (let e = 0; e < t.length; e++) n.push([t[e], e]);
                    n.sort(function (t, n) {
                      return t[0][e] < n[0][e] ? -1 : 1;
                    });
                    const s = [];
                    for (const t in n) s.push(n[t][1]);
                    return s;
                  })(this, t)),
                  !0)
              );
            },
            __createPathProxies(n) {
              let i = e,
                o = t;
              for (let t = 0; t < n.length - 1; t++) {
                const e = s && null !== r ? r[n[t]] : n[t];
                if (0 === t ? void 0 === i[e] : void 0 === i._getFromProxy(e)) {
                  const n = wn((void 0 !== o && o[e]) || {});
                  0 === t ? (i[e] = n) : i.setValue(e, n);
                }
                (i = i[e]), (o = void 0 !== o ? o[e] : {});
              }
              return { currentObject: i, currentRealObect: o };
            },
            findIndex(t) {
              if (!s) return null;
              for (let e = 0; e < i; e++) if (t(this[e])) return e;
              return null;
            },
            setValue(t, e) {
              const s = t.split("."),
                i = this.__createPathProxies(s).currentObject;
              let r = e;
              return (
                v(e) && (r = wn(e)),
                1 === s.length
                  ? ((i[s[s.length - 1]] = r), n.delete(r))
                  : (i.setValue(s[s.length - 1], r),
                    i.restoreKey(s[s.length - 1])),
                !0
              );
            },
            pushValue(e, n) {
              const s = e.split("."),
                { currentObject: i, currentRealObect: r } =
                  this.__createPathProxies(s);
              if (void 0 === r) return !1;
              const o = s[s.length - 1];
              let a = i[o],
                l = t[o];
              if (("" === e && ((a = this), (l = t)), 1 !== s.length))
                return i.pushValue(o, n);
              let c = !1;
              if (void 0 !== a) {
                if (((c = !0), !a.isArray())) return !1;
              } else if (!Array.isArray(l)) return !1;
              if (!c) {
                const t = wn(l);
                (i[o] = t), (a = i[o]);
              }
              return a.push(n), !0;
            },
            push(t) {
              return (
                !!this.isArray() && ((e[i] = v(t) ? wn(t) : t), (i += 1), !0)
              );
            },
            removePathKey(t) {
              const e = t.split("."),
                { currentObject: n } = this.__createPathProxies(e);
              return n.removeKey(e[e.length - 1]), !0;
            },
            removeKey(t) {
              n.add(t);
            },
            restoreKey(t) {
              n.delete(t);
            },
            hasOwnProperty(t) {
              return !(n.has(t) || void 0 === this[t]);
            },
            getKeys() {
              if (s) return [];
              let i = Object.keys(t);
              return (
                i.push(...Object.keys(e)), (i = i.filter((t) => !n.has(t))), i
              );
            },
            exportFlattened() {
              let n;
              if (s)
                if (((n = []), null !== r))
                  for (let s = 0; s < r.length; s++) {
                    const i = r[s];
                    if (x(e, i)) {
                      const t = e[i];
                      if (v(t))
                        try {
                          n[s] = e[i].exportFlattened();
                        } catch (e) {
                          n[s] = t;
                        }
                      else n[s] = t;
                    } else n[s] = t[i];
                  }
                else {
                  n = [...t];
                  for (const [t, s] of Object.entries(e))
                    if (v(s))
                      try {
                        n[t] = e[t].exportFlattened();
                      } catch (e) {
                        n[t] = s;
                      }
                    else n[t] = s;
                }
              else {
                n = {};
                const s = this.getKeys();
                for (let i = 0; i < s.length; i++) {
                  const r = s[i];
                  void 0 !== e[r]
                    ? (n[r] = v(e[r]) ? e[r].exportFlattened() : e[r])
                    : (n[r] = t[r]);
                }
              }
              return n;
            },
          });
        }
        function Cn(t, e, n = !1, s = r, i = window) {
          x(i, s) || (i[s] = {});
          let o = i[s];
          const a = t.split(".");
          for (let t = 0; t < a.length - 1; t++)
            x(o, a[t]) || (o[a[t]] = {}), (o = o[a[t]]);
          return !(
            (!n && x(o, a[a.length - 1])) ||
            ((o[a[a.length - 1]] = e), 0)
          );
        }
        function In(t, e = r, n = window) {
          "" !== e && (t = `${e}.${t}`);
          const s = t.replaceAll(/\]/g, "").split(/[[.]/g);
          let i = n;
          for (let t = 0; t < s.length; t++) {
            if (!x(i, s[t]))
              return t === s.length - 1 &&
                "length" === s[t] &&
                (y(i) || Array.isArray(i))
                ? i.length
                : void 0;
            i = i[s[t]];
          }
          return i;
        }
        const Pn = /({{ *| *}})/g;
        function En(t, e = !1) {
          const n = Object.keys(t).join("|");
          if ("" === n) return !1;
          const s = `(\\b(${n})\\b)(((\\.[a-zA-Z_]\\w*)|(\\[\\d*\\]))*)(?![a-z,A-Z_0-9])`;
          return e ? s : new RegExp(s, "g");
        }
        const kn = /{{((?!}}).)*}}/g,
          Sn = /( *mc-if *= *" *)[^"]*(?=")/g,
          On = /'.*'/g,
          Mn = /^ *\d* *$/,
          An =
            /^ *([0-9.]+|('([^']|\\')*([^\\]')))( *\+ *([0-9.]+|('([^']|\\')*([^\\]'))))* *$/g,
          _n =
            /^( *([0-9.]+|('([^']|\\')*([^\\]')))( *\+ *([0-9.]+|('([^']|\\')*([^\\]'))))* *)(==|===)( *([0-9.]+|('([^']|\\')*([^\\]')))( *\+ *([0-9.]+|('([^']|\\')*([^\\]'))))* *)$/g,
          Tn = new yn(),
          Dn = / *mc-if *= *" */g;
        function Bn(t) {
          const e = t.split(/ *\+ */);
          for (let t = 0; t < e.length; t++)
            (e[t] = e[t].trim()),
              e[t].match(On) && (e[t] = e[t].substring(1, e[t].length - 1));
          return e.join("");
        }
        function Ln(t, e) {
          if (!t.hasAttribute("mc-for") || !t.hasAttribute("mc-of"))
            return (
              j.warning("Either mc-for and mc-of is missing from element"), !1
            );
          if (
            !t
              .getAttribute("mc-for")
              .match(/^ *[a-zA-Z_]\w* *, *[a-zA-Z_]\w* *$/)
          )
            return !1;
          const n = (function (t) {
              const e = `^ *${En(t, !0)} *$`;
              return new RegExp(e, "g");
            })(e),
            s = t.getAttribute("mc-of"),
            i = s.match(n),
            r = s.match(Mn);
          if (1 !== (null == i ? void 0 : i.length) && null === r)
            return j.warning("mc-of attribute is not a valid expression"), !1;
          if (null !== r) return new Array(parseInt(s)).fill("");
          const o = In(i[0].trim(), "", e);
          return void 0 === o
            ? (j.warning("mc-of value is undefined"), !1)
            : v(o) || y(o) || f(o)
            ? f(o)
              ? new Array(o).fill("")
              : o
            : (j.warning(
                "mc-of value should be either a string, an object or an array"
              ),
              !1);
        }
        function jn(t) {
          const e = [],
            n = wn(t.params);
          for (const s in t.items)
            n.setValue(`keys.${t.keys.key}`, s),
              n.setValue(`items.${t.keys.item}`, t.items[s]),
              e.push(Vn(t.template, n.exportFlattened(), !0));
          return e;
        }
        function Vn(t, e, n = !1) {
          if (
            ((t = (function (t, e, n) {
              function s(t) {
                const s = t.match(Dn),
                  i = Array.isArray(s);
                function r(t) {
                  return i && (t = ` mc-if="${t}`), t;
                }
                const o = (t = (t = t.replaceAll(
                  / *mc-if *= *" */g,
                  ""
                )).replaceAll(/ *mc-if *= *" */g, "")).match(Pn);
                let a = t.replaceAll(Pn, "");
                const l = En(e.items),
                  c = (function (t) {
                    if (!v(t)) return !1;
                    const e = Object.keys(t).join("|");
                    return (
                      !!e &&
                      new RegExp(`(\\b(${e}\\b))(?![a-z,A-Z_0-9.\\[])`, "g")
                    );
                  })(e.keys);
                if (
                  (!1 !== l &&
                    (a = a.replaceAll(l, (t) => {
                      if ("initParams" === t || "attrs" === t)
                        return r("undefined");
                      let s = In(t, "", e.items);
                      return y(s) && (s = `'${n ? N(s) : s}'`), s;
                    })),
                  !1 !== c &&
                    (a = a.replaceAll(c, (t) => {
                      let s = e.keys[t];
                      return y(s) && (s = `'${n ? N(s) : s}'`), s;
                    })),
                  a.match(_n))
                ) {
                  const t = a.split(/===|==/);
                  return (
                    (t[0] = Bn(t[0])),
                    (t[1] = Bn(t[1])),
                    r((t[0] === t[1]).toString())
                  );
                }
                try {
                  const t = Tn.parse(a),
                    n = Object.assign({}, e.keys, e.items),
                    s = t.evaluate(n);
                  if (void 0 !== s && !isNaN(s)) return r(s);
                } catch (t) {}
                if (a.match(An)) return r(Bn(a));
                const u = /===|==|>=|>|<=|<|!==|!=/g,
                  p = a.split(u);
                if (2 === p.length) {
                  const n = a.match(u)[0];
                  try {
                    const t = Tn.parse(p[0]),
                      s = Tn.parse(p[1]),
                      i = Object.assign({}, e.keys, e.items);
                    return r(
                      (function (t, e, n) {
                        switch (n) {
                          case "==":
                          case "===":
                            return t === e;
                          case "!=":
                          case "!==":
                            return t !== e;
                          case ">":
                            return t > e;
                          case ">=":
                            return t >= e;
                          case "<":
                            return t < e;
                          case "<=":
                            return t <= e;
                          default:
                            return (
                              j.error(
                                `template engine parser - not supported operator ${n}`
                              ),
                              !1
                            );
                        }
                      })(t.evaluate(i), s.evaluate(i), n).toString()
                    );
                  } catch (t) {}
                }
                return r(null !== o ? `{{${a}}}` : a);
              }
              return t.replaceAll(kn, s).replaceAll(Sn, s);
            })((t = t.replace(/^\s+|\s+$/g, "")), e, n)),
            !n)
          )
            return t;
          const s = document.createElement("div");
          return (
            (s.innerHTML = t),
            (function (t) {
              const e = t.querySelectorAll("[mc-if]");
              for (const t of e) {
                const e = t.getAttribute("mc-if");
                "true" === e
                  ? t.removeAttribute("mc-if")
                  : "false" === e && t.remove();
              }
            })(s),
            (function (t, e) {
              const n = t.querySelectorAll("[mc-for]");
              for (const t of n) {
                const n = Ln(t, e.items);
                if (!1 === n) {
                  t.remove();
                  continue;
                }
                const s = t.getAttribute("mc-for").split(","),
                  i = { key: s[0].trim(), item: s[1].trim() };
                t.removeAttribute("mc-for"), t.removeAttribute("mc-of");
                const r = jn({
                  template: t.outerHTML,
                  keys: i,
                  params: e,
                  items: n,
                });
                if (0 === r.length) {
                  t.remove();
                  continue;
                }
                let o = t;
                for (let t = 0; t < r.length; t++) {
                  const e = o.parentNode.insertBefore(r[t], o.nextSibling);
                  o = e;
                }
                t.remove();
              }
            })(s, e),
            1 !== s.childElementCount
              ? (j.warning(
                  "parser only accepts close Browser trees (always contained on a single element). The root element can not have mc-for applied to it. Returning empty div"
                ),
                document.createElement("div"))
              : s.firstChild
          );
        }
        const Nn = /\(([^()]|\(([^()]|\(([^()]|\(([^()])*\))*\))*\))*\)/;
        function $n(t) {
          t = R(t);
          const e = Nn.exec(t);
          if (null == e) return { result: !1 };
          const n = t.split(")");
          return { result: !0, unit: n[n.length - 1], expression: e[0] };
        }
        var Rn = Object.defineProperty;
        const Fn = Ot.preface,
          zn = {
            Handler: class {
              constructor(t) {
                ((t, e, n) => {
                  ((t, e, n) => {
                    e in t
                      ? Rn(t, e, {
                          enumerable: !0,
                          configurable: !0,
                          writable: !0,
                          value: n,
                        })
                      : (t[e] = n);
                  })(this, e + "", void 0);
                })(0, "expressionProps");
                const e = $n(t.value);
                this.expressionProps = {
                  unit: e.unit,
                  expression: e.expression,
                };
              }
              resize(t) {
                const e = `(${
                  $n(this.expressionProps.expression).expression
                }*${t})`;
                return `${Fn}(${e})${this.expressionProps.unit}`;
              }
              calculateValues(t, e) {
                const n = t.length,
                  s = [],
                  i = { [o]: n, [l]: e };
                for (let t = 0; t < n; t++) {
                  i[a] = t;
                  const e = Vn(
                    `{{${this.expressionProps.expression.substring(
                      1,
                      this.expressionProps.expression.length - 1
                    )}}}`,
                    { items: i }
                  );
                  if (null !== e.match(kn)) {
                    j.error(
                      `${this.expressionProps.expression} can not fully parsed. At least one of the provided parameters seem not to be valid. Returning 0`
                    ),
                      s.push(0);
                    continue;
                  }
                  const n = `${e}${this.expressionProps.unit}`;
                  s.push(g(n) ? parseFloat(n) : n);
                }
                return s;
              }
            },
            validation: function (t, e) {
              const n = $n(t);
              return (
                n.result || e(`Invalid ${Ot.preface} expression`), n.result
              );
            },
            preface: Ot.preface,
            supportedTypes: Ot.supportedTypes,
          },
          Xn = {
            supportedTypes: [
              "amount",
              "array",
              "boolean",
              "color",
              "currency",
              "date",
              "email",
              "enum",
              "measurement",
              "number",
              "object",
              "string",
              "tuple",
              "url",
            ],
            preface: "initParams",
          };
        var Hn = Object.defineProperty;
        const Yn = new RegExp(`^ *@${Xn.preface}.[_A-z0-9]* *$`),
          Un = {
            Handler: class {
              constructor(t) {
                ((t, e, n) => {
                  ((t, e, n) => {
                    e in t
                      ? Hn(t, e, {
                          enumerable: !0,
                          configurable: !0,
                          writable: !0,
                          value: n,
                        })
                      : (t[e] = n);
                  })(this, e + "", void 0);
                })(0, "expressionProps"),
                  (this.expressionProps = { expression: t.value });
              }
              calculateValues(t, e) {
                const n = t.length,
                  s = { [o]: n, [l]: e },
                  i = this.expressionProps.expression.substring(
                    this.expressionProps.expression.indexOf(".") + 1
                  ),
                  r = [];
                for (let n = 0; n < t.length; n++) {
                  s[a] = n;
                  const t = In(
                    i.replaceAll(/\[(.*?)\]/g, (t) =>
                      Vn(`[{{${t.substring(1, t.length - 1)}}}]`, { items: s })
                    ),
                    "",
                    e
                  );
                  r.push(t);
                }
                return r;
              }
            },
            validation: function (t, e) {
              return (
                !!Yn.test(t) || (e(`Invalid ${Xn.preface} expression`), !1)
              );
            },
            preface: Xn.preface,
            supportedTypes: Xn.supportedTypes,
          },
          Wn = {
            supportedTypes: [
              "amount",
              "array",
              "boolean",
              "color",
              "currency",
              "date",
              "email",
              "enum",
              "measurement",
              "number",
              "object",
              "string",
              "tuple",
              "url",
            ],
            preface: "pattern",
          },
          qn = new RegExp(
            `^@${Wn.preface}\\(( *#*[_A-z0-9.%-]+?( *, *#*[_A-z0-9.%-]+)*?)\\)$`
          ),
          Gn = {
            Handler: class {
              constructor(t) {
                let e = S(t.value) || [],
                  n = !0;
                const s = [];
                for (let t = 0; t < e.length; t++) {
                  if (!g(e[t])) {
                    n = !1;
                    break;
                  }
                  s.push(parseFloat(e[t]));
                }
                n && (e = s),
                  (this.patternProps = {
                    type: n ? "amount" : "measurement",
                    pattern: e,
                  });
              }
              calculateValues(t) {
                const e = this.patternProps.pattern.length,
                  n = [];
                for (let s = 0; s < t.length; s++)
                  n.push(this.patternProps.pattern[s % e]);
                return n;
              }
              resize(t) {
                if ("amount" !== this.patternProps.type)
                  return `${Wn.preface}(${this.patternProps.pattern.join()})`;
                const e = [];
                for (let n = 0; n < this.patternProps.pattern.length; n++)
                  e.push(t * this.patternProps.pattern[n]);
                return `${Wn.preface}(${e.join()})`;
              }
            },
            validation: function (t, e, n, s) {
              if (!qn.test(R(t)))
                return e(`The ${Wn.preface} expression is not valid`), !1;
              const i = S(t) || [];
              if ("number" === s.type)
                for (let t = 0; t < i.length; t++) {
                  if (!g(i[t]))
                    return (
                      e(`The @pattern value at index ${t} is not numeric`), !1
                    );
                  i[t] = parseFloat(i[t]);
                }
              return n(i);
            },
            preface: Wn.preface,
            supportedTypes: Wn.supportedTypes,
          },
          Zn = {
            supportedTypes: ["amount", "measurement", "number"],
            preface: "stagger",
          },
          Kn = 2 * Math.PI,
          Jn = {
            linear: (t) => t,
            easeInQuad: (t) => t * t,
            easeOutQuad: (t) => t * (2 - t),
            easeInOutQuad: (t) => (t < 0.5 ? 2 * t * t : (4 - 2 * t) * t - 1),
            easeInCubic: (t) => t * t * t,
            easeOutCubic: (t) => --t * t * t + 1,
            easeInOutCubic: (t) =>
              t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
            easeInQuart: (t) => t * t * t * t,
            easeOutQuart: (t) => 1 - --t * t * t * t,
            easeInOutQuart: (t) =>
              t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t,
            easeInQuint: (t) => t * t * t * t * t,
            easeOutQuint: (t) => 1 + --t * t * t * t * t,
            easeInOutQuint: (t) =>
              t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t,
            easeInSine: (t) => -1 * Math.cos(t * (Math.PI / 2)) + 1,
            easeOutSine: (t) => Math.sin(t * (Math.PI / 2)),
            easeInOutSine: (t) => -(Math.cos(Math.PI * t) - 1) / 2,
            easeInExpo: (t) => (0 == t ? 1 : 1 * Math.pow(2, 10 * (t - 1))),
            easeOutExpo: (t) => (1 == t ? 1 : 1 * (1 - Math.pow(2, -10 * t))),
            easeInOutExpo: (t) =>
              0 == t || 1 == t
                ? t
                : (t *= 2) < 1
                ? Math.pow(2, 10 * (t - 1)) / 2
                : (2 - Math.pow(2, -10 * --t)) / 2,
            easeInCirc: (t) => (t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1)),
            easeOutCirc: (t) => Math.sqrt(1 - (t = t / 1 - 1) * t),
            easeInOutCirc: (t) =>
              (t *= 2) < 1
                ? -(Math.sqrt(1 - t * t) - 1) / 2
                : (Math.sqrt(1 - (t -= 2) * t) + 1) / 2,
            easeInElastic(t) {
              if (0 == t || 1 == t) return t;
              const e = (0.3 / Kn) * Math.asin(1);
              return (
                -Math.pow(2, 10 * (t -= 1)) * Math.sin(((1 * t - e) * Kn) / 0.3)
              );
            },
            easeOutElastic(t) {
              if (0 == t || 1 == t) return t;
              const e = (0.3 / Kn) * Math.asin(1);
              return Math.pow(2, -10 * t) * Math.sin(((t - e) * Kn) / 0.3) + 1;
            },
            easeInOutElastic(t) {
              if (0 == t || 1 == t) return t;
              const e = 0.3 * 1.5,
                n = (e / Kn) * Math.asin(1);
              return t < 1
                ? (-Math.pow(2, 10 * (t -= 1)) * Math.sin(((t - n) * Kn) / e)) /
                    2
                : (Math.pow(2, -10 * (t -= 1)) * Math.sin(((t - n) * Kn) / e)) /
                    2 +
                    1;
            },
            easeInBack(t) {
              const e = 1.70158;
              return t * t * ((e + 1) * t - e);
            },
            easeOutBack(t) {
              const e = 1.70158;
              return (t -= -1) * t * ((e + 1) * t + e) + 1;
            },
            easeInOutBack(t) {
              let e = 1.70158;
              return (t *= 2) < 1
                ? (t * t * ((1 + (e *= 1.525)) * t - e)) / 2
                : ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2) / 2;
            },
            easeInBounce: (t) => 1 - Jn.easeOutBounce(1 - t),
            easeOutBounce: (t) =>
              t < 1 / 2.75
                ? 7.5625 * t * t * 1
                : t < 2 / 2.75
                ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75
                : t < 2.5 / 2.75
                ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375
                : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375,
            easeInOutBounce: (t) =>
              (t < 0.5
                ? Jn.easeInBounce(2 * t)
                : Jn.easeOutBounce(2 * t - 1) + 1) / 2,
          };
        var Qn = Object.defineProperty;
        function ts(t) {
          var e;
          t = R(t);
          const n = (
            (null == (e = /.*\((.*)\).*/.exec(t)) ? void 0 : e[1]) || ""
          ).split(",");
          return {
            start: n[0],
            end: n[1],
            startFraction: 1 * n[2] || 0,
            easing: n[3] || "linear",
            mode: n[4] || "linear",
            reverse: "true" === n[5],
          };
        }
        function es(t, e, n, s = "linear") {
          return Jn[s](n) * (e - t) + t;
        }
        const ns = Object.keys(Jn),
          ss = {
            Handler: class {
              constructor(t) {
                var e, n;
                ((t, e, n) => {
                  ((t, e, n) => {
                    e in t
                      ? Qn(t, e, {
                          enumerable: !0,
                          configurable: !0,
                          writable: !0,
                          value: n,
                        })
                      : (t[e] = n);
                  })(this, e + "", void 0);
                })(0, "staggerProps");
                const s = ts(t.value),
                  i = (null == (e = s.start.match(C)) ? void 0 : e[0]) || [],
                  r = null == (n = s.end.match(C)) ? void 0 : n[0],
                  o = s.start.toString().substring(i.length);
                this.staggerProps = {
                  from: 1 * i,
                  to: 1 * r,
                  mode: s.mode,
                  unit: o,
                  fraction: s.startFraction,
                  easing: s.easing,
                  reverse: s.reverse,
                  type: "" === o ? "amount" : "measurement",
                  integer: t.integer,
                };
              }
              resize(t) {
                return (
                  (this.staggerProps.from *= t),
                  (this.staggerProps.to *= t),
                  !0 === this.staggerProps.integer &&
                    ((this.staggerProps.from = Math.round(
                      this.staggerProps.from
                    )),
                    (this.staggerProps.to = Math.round(this.staggerProps.to))),
                  `@stagger(${this.staggerProps.from}${
                    this.staggerProps.unit
                  }, ${this.staggerProps.to}${this.staggerProps.unit}, ${
                    this.staggerProps.fraction || 0
                  }, ${this.staggerProps.easing || "linear"}, ${
                    this.staggerProps.mode || "linear"
                  }, ${this.staggerProps.reverse || !1})`
                );
              }
              calculateValues(t) {
                const e = t.length;
                if (e < 2) return [this.staggerProps.from];
                const n = (function (t, e = 0, n = "linear", s = !1) {
                    const i = [];
                    if ("linear" === n)
                      for (let n = 0; n < t; n++) {
                        const r = n / (t - 1);
                        let o = r < e ? r + 1 - e + 1 / (t - 1) : r - e;
                        s && (o = 1 - o), i.push(o);
                      }
                    else if ("omni" === n) {
                      const n = 1 - e;
                      for (let r = 0; r < t; r++) {
                        let o = Math.abs(r / (t - 1) - e) / n;
                        s && (o = 1 - o), i.push(o);
                      }
                    }
                    return i;
                  })(
                    e,
                    this.staggerProps.fraction,
                    this.staggerProps.mode,
                    this.staggerProps.reverse
                  ),
                  s = [];
                for (let t = 0; t < n.length; t++) {
                  let e = es(
                    this.staggerProps.from,
                    this.staggerProps.to,
                    n[t],
                    this.staggerProps.easing
                  );
                  !0 === this.staggerProps.integer && (e = Math.round(e)),
                    "measurement" === this.staggerProps.type &&
                      (e += this.staggerProps.unit),
                    s.push(e);
                }
                return s;
              }
            },
            validation: function (t, e, n, s) {
              if (
                ((t = R(t)),
                !/^@stagger\(([A-z0-9.%-]+?(,[A-z0-9.%-]+)?(,[A-z0-9.%-]+)?(,[A-z0-9.%-]+)?(,[A-z0-9.%-]+)?(,[A-z0-9.%-]+))\)$/.test(
                  t
                ))
              )
                return e("Invalid @stagger expression"), !1;
              const i = ts(t);
              if (i.startFraction < 0 || i.startFraction > 1)
                return (
                  e(`The ${Zn.preface} fraction must be a number >=0 and <=1`),
                  !1
                );
              if (!ns.includes(i.easing))
                return (
                  e(
                    `The ${Zn.preface} easing (${i.easing}) is not supported by the system`
                  ),
                  !1
                );
              if ("linear" !== i.mode && "omni" !== i.mode)
                return (
                  e(
                    `The ${Zn.preface} mode should be either "linear" or "omni"`
                  ),
                  !1
                );
              if (!0 !== i.reverse && !1 !== i.reverse)
                return (
                  e(`The ${Zn.preface} reverse should be either true or false`),
                  !1
                );
              const r = i.start.match(C),
                o = i.end.match(C);
              if (null === r || null === o)
                return (
                  e(
                    `The start and end units of a @stagger should always be the same. This doesn't stand for the couple ${i.start}, ${i.end}`
                  ),
                  !1
                );
              const a = r[0],
                l = o[0],
                c = i.start.toString().substring(a.length),
                u = i.end.toString().substring(l.length);
              return c !== u
                ? (e(
                    `The start and end units of a @stagger should always be the same. ${c}, ${u} provided`
                  ),
                  !1)
                : n([
                    "number" === s.type ? parseFloat(i.start) : i.start,
                    "number" === s.type ? parseFloat(i.end) : i.end,
                  ]);
            },
            preface: Zn.preface,
            supportedTypes: Zn.supportedTypes,
          },
          is = [];
        function rs(t) {
          is.push(t);
        }
        function os() {
          return is;
        }
        rs(St), rs(zn), rs(Un), rs(Gn), rs(ss);
        const as = os();
        function ls(t, e = "") {
          if (!t) return [];
          const n = [];
          for (const [s, i] of Object.entries(t)) {
            if (i instanceof Element) continue;
            if (v(i)) {
              const t = ls(i, `${e}${"" === e ? "" : "."}${s}`);
              n.push(...t);
              continue;
            }
            if (!y(i)) continue;
            const t = i.trim();
            for (let i = 0; i < as.length; i++) {
              const r = as[i];
              if (t.startsWith(`@${r.preface}`)) {
                const i = {
                  dynamicType: r.preface,
                  path: `${e}${"" === e ? "" : "."}${s}`,
                  Handler: r.Handler,
                  value: t,
                };
                n.push(i);
              }
            }
          }
          return n;
        }
        var cs = Object.defineProperty,
          us = (t, e, n) => (
            ((t, e, n) => {
              e in t
                ? cs(t, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: n,
                  })
                : (t[e] = n);
            })(t, "symbol" != typeof e ? e + "" : e, n),
            n
          );
        class ps extends et {
          constructor(t = { duration: 0 }) {
            super(),
              us(this, "constructionIngredients"),
              us(this, "mcid"),
              us(this, "easing"),
              us(this, "plugin_channel_class"),
              us(this, "attributesStaggers"),
              us(this, "propsStaggers"),
              us(this, "dynamicDurationValue"),
              us(this, "blockingWaitings"),
              us(this, "_duration"),
              us(this, "realClip"),
              us(this, "originalContextKey"),
              us(this, "contexts"),
              us(this, "attrs"),
              us(this, "_inheritedSelector", null),
              us(this, "isNode"),
              us(this, "passive"),
              us(this, "parentNode"),
              us(this, "props"),
              us(this, "children"),
              (this.parentNode = null),
              (this.isNode = !1),
              (this.id = x(t, "id") ? t.id : A()),
              (this.props = t),
              this.resetDuration();
          }
          get name() {
            var t;
            return null == (t = this.props) ? void 0 : t.name;
          }
          set name(t) {
            this.props.name = t;
          }
          get inheritedSelector() {
            return this._inheritedSelector;
          }
          set inheritedSelector(t) {
            this._inheritedSelector = t;
          }
          get delay() {
            return x(this.props, "delay") ? this.props.delay : 0;
          }
          set delay(t) {
            0 !== t && (this.props.delay = t), this.resetDuration();
          }
          get hiatus() {
            return x(this.props, "hiatus") ? this.props.hiatus : 0;
          }
          set hiatus(t) {
            0 !== t && (this.props.hiatus = t), this.resetDuration();
          }
          get repeats() {
            return x(this.props, "repeats") ? this.props.repeats : 1;
          }
          set repeats(t) {
            (this.props.repeats = t), this.resetDuration();
          }
          resetDuration(t = !1) {
            (this._duration =
              this.repeats * (this.delay + this.props.duration + this.hiatus)),
              t &&
                this.putMessageOnPipe("recalcDuration", {}, "Groups", {
                  selfExecute: !1,
                  direction: Z._UP,
                });
          }
          get duration() {
            return this._duration;
          }
          set duration(t) {
            const e = t / this.duration;
            (this.props.duration *= e),
              (this.hiatus *= e),
              (this.delay *= e),
              this.resetDuration();
          }
          setNewDuration(t) {
            (this.duration = t),
              this.putMessageOnPipe("recalcDuration", {}, "Groups", {
                selfExecute: !1,
                direction: Z._UP,
              });
          }
          systoleDiastole(t) {
            this.duration *= t;
          }
          get hasParent() {
            return null !== this.parentNode;
          }
          attachToNode(t) {
            this.parentNode = t;
          }
          detachFromParent() {
            (this.parentNode = null), (this.inheritedSelector = null);
          }
          putMessageOnPipe(t, e, n, s = {}) {
            if (
              (x(s, "direction") || (s.direction = Z._DOWN),
              s.direction !== Z._DOWN ||
                x(s, "positionDelta") ||
                (s.positionDelta = 0),
              s.selfExecute)
            ) {
              const r = `handle${
                ((i = t), i.charAt(0).toUpperCase() + i.slice(1))
              }`;
              if ("function" == typeof this[r]) {
                const t = this[r](n, e);
                if (t !== J) {
                  const e = { response: t, responder: this };
                  return s.direction === Z._UP
                    ? e
                    : ((e.positionDelta = s.positionDelta), [e]);
                }
              }
            }
            var i;
            return s.direction !== Z._UP
              ? []
              : this.hasParent
              ? this.parentNode.putMessageOnPipe(t, e, n, {
                  selfExecute: !0,
                  direction: Z._UP,
                })
              : { response: !1, responder: null };
          }
          bypass() {
            return J;
          }
          get positionOnPyramidion() {
            return this.getPositionOnPyramidion();
          }
          getPositionOnPyramidion(t = 0) {
            return this.hasParent
              ? this.putMessageOnPipe(
                  "getPositionOnPyramidion",
                  { delta: t, id: this.id },
                  "Parent",
                  { selfExecute: !1, direction: Z._UP }
                ).response
              : t;
          }
          editAttributes(t) {
            if (null !== this.constructor.attrsValidationRules) {
              const e = this.constructor.attrsValidationMethod(t);
              if (e.length > 0) return { result: !1, errors: e };
            }
            return this.putMessageOnPipe(
              "checkForClip",
              {},
              K._DECISIONAUTHORITY,
              { selfExecute: !0, direction: Z._UP }
            ).response
              ? this.manageEditAttrProps(t, "attrs")
              : ((this.attrs = t), { result: !0 });
          }
          editProperties(t) {
            const e = V(
              t,
              this.constructor.propsValidationRules,
              this.constructor
            );
            return e.result
              ? this.putMessageOnPipe(
                  "checkForClip",
                  {},
                  K._DECISIONAUTHORITY,
                  { selfExecute: !0, direction: Z._UP }
                ).response
                ? this.manageEditAttrProps(t, "props")
                : ((this.props = t), { result: !0 })
              : e;
          }
          resize(t, e = { check: !0 }) {
            var n;
            if ("dynamic" === this.duration) return { result: !1, reason: It };
            if (t === this.duration)
              return { result: !0, meta: { unprocessed: !0 } };
            if (t <= 0)
              return { result: !1, reason: "Size must always be > 0" };
            if (e.check && this.hasParent) {
              const e = this.putMessageOnPipe(
                "checkResize",
                { id: this.id, newSize: t, fraction: t / this.duration },
                K._DECISIONAUTHORITY,
                { selfExecute: !1, direction: Z._UP }
              );
              if (!(null == (n = e.response) ? void 0 : n.result))
                return e.response;
            }
            return this.setNewDuration(t), { result: !0 };
          }
          clone(t = {}, e = {}) {
            const n = this.exportLiveDefinition();
            for (const e in t) Cn(e, t[e], !0, "attrs", n);
            for (const t in e) Cn(t, e[t], !0, "props", n);
            return G(n);
          }
          selector() {
            var t;
            return null === this.inheritedSelector
              ? x(this.props, "selector")
                ? this.props.selector
                : null
              : x(this.props, "selector")
              ? (null == (t = this.props.selector) ? void 0 : t.startsWith("&"))
                ? this.inheritedSelector + this.props.selector.substring(1)
                : `${this.inheritedSelector} ${this.props.selector}`
              : this.inheritedSelector;
          }
          getElements(t) {
            return null != this.props.host
              ? [this.props.host]
              : this.hasParent &&
                this.putMessageOnPipe(
                  "checkForClip",
                  {},
                  K._DECISIONAUTHORITY,
                  { selfExecute: !0, direction: Z._UP }
                ).response
              ? this.putMessageOnPipe(
                  "getElements",
                  { selector: this.selector() },
                  K._DECISIONAUTHORITY,
                  { selfExecute: !1, direction: Z._UP }
                ).response
              : [];
          }
          setupDynamicValues() {
            const t = { attrs: {}, props: {} };
            for (const e of ["attrs", "props"]) {
              const n = ls(this[e]);
              for (const s of n) {
                const n = s.Handler,
                  i = { value: s.value, integer: s.integer };
                this[
                  ("attrs" === e ? "attributes" : "props") + "Staggers"
                ].push({ path: s.path, stagger: new n(i) }),
                  x(t[e], s.dynamicType)
                    ? (t[e][s.dynamicType] += 1)
                    : (t[e][s.dynamicType] = 1);
              }
            }
            return t;
          }
          _calculateDuration(t) {}
        }
        const hs = 0.1,
          ds = "function" == typeof Float32Array;
        function ms(t, e) {
          return 1 - 3 * e + 3 * t;
        }
        function fs(t, e) {
          return 3 * e - 6 * t;
        }
        function gs(t) {
          return 3 * t;
        }
        function ys(t, e, n) {
          return ((ms(e, n) * t + fs(e, n)) * t + gs(e)) * t;
        }
        function vs(t, e, n) {
          return 3 * ms(e, n) * t * t + 2 * fs(e, n) * t + gs(e);
        }
        function bs(t) {
          return t;
        }
        function xs(t, e, n, s) {
          if (!(0 <= t && t <= 1 && 0 <= n && n <= 1))
            throw new Error("bezier x values must be in [0, 1] range");
          if (t === e && n === s) return bs;
          const i = ds ? new Float32Array(11) : new Array(11);
          for (let e = 0; e < 11; ++e) i[e] = ys(e * hs, t, n);
          function r(e) {
            let s = 0,
              r = 1;
            for (; 10 !== r && i[r] <= e; ++r) s += hs;
            --r;
            const o = s + ((e - i[r]) / (i[r + 1] - i[r])) * hs,
              a = vs(o, t, n);
            return a >= 0.001
              ? (function (t, e, n, s) {
                  for (let i = 0; i < 4; ++i) {
                    const i = vs(e, n, s);
                    if (0 === i) return e;
                    e -= (ys(e, n, s) - t) / i;
                  }
                  return e;
                })(e, o, t, n)
              : 0 === a
              ? o
              : (function (t, e, n, s, i) {
                  let r,
                    o,
                    a = 0;
                  do {
                    (o = e + (n - e) / 2),
                      (r = ys(o, s, i) - t),
                      r > 0 ? (n = o) : (e = o);
                  } while (Math.abs(r) > 1e-7 && ++a < 10);
                  return o;
                })(e, s, s + hs, t, n);
          }
          return function (t) {
            return 0 === t || 1 === t ? t : ys(r(t), e, s);
          };
        }
        var ws = Object.defineProperty,
          Cs = Object.defineProperties,
          Is = Object.getOwnPropertyDescriptors,
          Ps = Object.getOwnPropertySymbols,
          Es = Object.prototype.hasOwnProperty,
          ks = Object.prototype.propertyIsEnumerable,
          Ss = (t, e, n) =>
            e in t
              ? ws(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (t[e] = n),
          Os = (t, e) => {
            for (var n in e || (e = {})) Es.call(e, n) && Ss(t, n, e[n]);
            if (Ps) for (var n of Ps(e)) ks.call(e, n) && Ss(t, n, e[n]);
            return t;
          },
          Ms = (t, e) => Cs(t, Is(e));
        class As extends ps {
          constructor(t, e, n, s) {
            var i;
            super(Ms(Os({}, t.props), { id: `${t.incidentId}_${n}` })),
              Ss(
                this,
                "symbol" != typeof (i = "timeScale") ? i + "" : i,
                void 0
              ),
              (this.contexts = {}),
              (this.constructionIngredients = t),
              (this.mcid = n),
              (this.DescriptiveIncident = s),
              (this.mc_plugin_npm_name = t.plugin_npm_name),
              (this.plugin_channel_class = t.Channel),
              this.addContext(e),
              (this.timeScale = 1),
              s.realClip.duration > 0 &&
                (this.timeScale = this.props.duration / s.realClip.duration),
              s.realClip.subscribeToDurationChange((t) => {
                (this.props.duration = this.timeScale * t),
                  this.resetDuration(),
                  this.putMessageOnPipe("recalcDuration", {}, "Groups", {
                    selfExecute: !1,
                    direction: Z._UP,
                  });
              }),
              x(this.props, "easing")
                ? (this.easing = Array.isArray(this.props.easing)
                    ? xs(
                        this.props.easing[0],
                        this.props.easing[1],
                        this.props.easing[2],
                        this.props.easing[3]
                      )
                    : Jn[this.props.easing])
                : (this.easing = Jn.linear);
          }
          get originalContext() {
            return this.contexts[this.originalContextKey];
          }
          onProgress(t, e, n, s = !1) {
            let i = e % (this.delay + this.props.duration + this.hiatus);
            0 !== e && 0 === i && (i = this.delay + this.props.duration);
            let r = i - this.delay;
            r < 0
              ? (r = 0)
              : r > this.props.duration && (r = this.props.duration);
            const o = 0 === this.props.duration ? 0 : r / this.props.duration,
              a = this.easing(o) * this.props.duration * (1 / this.timeScale);
            this.originalContext.context &&
              !1 !== this.originalContext.context.contextLoaded &&
              this.contexts[n].onProgress(a, s);
          }
          addContext(t, e = !1) {
            0 === Object.keys(this.contexts).length &&
              (this.originalContextKey = t.clipId);
            const n = Ms(Os({}, this.constructionIngredients), {
              context: t.context,
              mcid: this.mcid,
              Incident: ht,
              DescriptiveIncident: this.DescriptiveIncident,
            });
            (this.contexts[t.clipId] = Ct(n)),
              e && this.contexts[t.clipId]._onGetContextOnce();
          }
          handleAddContext(t, e) {
            return this.addContext(e, !0), !0;
          }
          handleContextLoaded(t, e) {
            this._onGetContextOnce();
          }
          gotContext() {
            for (const t in this.contexts) this.contexts[t].gotContext();
          }
          _onGetContextOnce() {
            if (!1 !== this.originalContext.contextLoaded)
              for (const t in this.contexts)
                this.contexts[t]._onGetContextOnce();
          }
          lastWish() {
            for (const t in this.contexts) this.contexts[t].lastWish();
          }
          onGetContext() {
            if (!1 !== this.originalContext.contextLoaded)
              for (const t in this.contexts) this.contexts[t].onGetContext();
          }
          exportLiveDefinition(t) {
            throw new Error("Method not implemented.");
          }
          manageEditAttrProps(t, e) {
            throw new Error("Method not implemented.");
          }
        }
        const _s = "Leaf has already been attached to another Node",
          Ts = "Negative positioning of childs on nodes is not allowed",
          Ds =
            "The Leaf with the requested id couldn't be found on the TimedTree";
        var Bs = Object.defineProperty,
          Ls = Object.defineProperties,
          js = Object.getOwnPropertyDescriptors,
          Vs = Object.getOwnPropertySymbols,
          Ns = Object.prototype.hasOwnProperty,
          $s = Object.prototype.propertyIsEnumerable,
          Rs = (t, e, n) =>
            e in t
              ? Bs(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (t[e] = n),
          Fs = (t, e) => {
            for (var n in e || (e = {})) Ns.call(e, n) && Rs(t, n, e[n]);
            if (Vs) for (var n of Vs(e)) $s.call(e, n) && Rs(t, n, e[n]);
            return t;
          },
          zs = (t, e, n) => (Rs(t, "symbol" != typeof e ? e + "" : e, n), n);
        class Xs extends ps {
          constructor(t) {
            super(t),
              zs(this, "calculatedDuration"),
              zs(this, "runTimeInfo"),
              (this.isNode = !0),
              (this.children = {}),
              (this.calculatedDuration = 0),
              this.resetDuration();
          }
          resetDuration() {
            this._duration =
              this.repeats *
              (this.delay + this.calculatedDuration + this.hiatus);
          }
          get duration() {
            return this._duration;
          }
          set duration(t) {
            if (0 === this.duration) return;
            const e = t / this.duration;
            (this.calculatedDuration *= e),
              (this.hiatus *= e),
              (this.delay *= e),
              this.resetDuration();
            for (const t in this.children) {
              const n = this.children[t];
              this.editPosition(n.id, n.position * e, !0),
                n.leaf.systoleDiastole(e);
            }
          }
          _calculateDuration(t) {
            if (!t || null != t.childId) {
              const e = this.children[null == t ? void 0 : t.childId],
                n = e.leaf.duration + e.position;
              return (
                n > this.calculatedDuration &&
                ((this.calculatedDuration = n), this.resetDuration(), !0)
              );
            }
            let e = 0;
            for (const t in this.children) {
              const n = this.children[t];
              n.position + n.leaf.duration > e &&
                (e = n.position + n.leaf.duration);
            }
            return (
              e !== this.calculatedDuration &&
              ((this.calculatedDuration = e), this.resetDuration(), !0)
            );
          }
          handleRecalcDuration(t, e) {
            return (
              !this._calculateDuration(e) ||
              this.putMessageOnPipe(
                "recalcDuration",
                e.childId ? { childId: this.id } : {},
                "Groups",
                { selfExecute: !1, direction: Z._UP }
              )
            );
          }
          getLeafById(t, e = !1) {
            if (x(this.children, t)) return this.children[t].leaf;
            if (!e)
              for (const e in this.children) {
                const n = this.children[e].leaf;
                if (n.isNode) {
                  const e = n.getLeafById(t);
                  if (null != e) return e;
                }
              }
            return null;
          }
          getLeafPosition(t) {
            if (x(this.children, t)) return this.children[t].position;
            const e = this.putMessageOnPipe(
              "getLeafPosition",
              { id: t },
              "Groups",
              { selfExecute: !1, direction: Z._DOWN }
            );
            return e.length > 0 ? e[0].positionDelta + e[0].response : void 0;
          }
          handleGetLeafPosition(t, e) {
            return this.getLeafPosition(e.id);
          }
          checkAddition(t, e) {
            return t.hasParent
              ? { result: !1, reason: _s }
              : e < 0
              ? { result: !1, reason: Ts }
              : { result: !0 };
          }
          addChild(t, e) {
            return t.hasParent
              ? { result: !1, reason: _s }
              : ((this.children[t.id] = { id: t.id, leaf: t, position: e }),
                t.attachToNode(this),
                this.putMsgOnPipeWithResult(
                  "recalcDuration",
                  { childId: t.id },
                  "Groups",
                  { selfExecute: !0, direction: Z._UP }
                ));
          }
          checkRemoveChild(t) {
            return x(this.children, t)
              ? { result: !0 }
              : { result: !1, reason: Ds };
          }
          removeChild(t) {
            return (
              this.children[t].leaf.detachFromParent(),
              delete this.children[t],
              this.putMsgOnPipeWithResult("recalcDuration", {}, "Groups", {
                selfExecute: !0,
                direction: Z._UP,
              })
            );
          }
          checkEditPosition(t, e) {
            return e < 0
              ? { result: !1, reason: Ts }
              : x(this.children, t)
              ? { result: !0 }
              : { result: !1, reason: Ds };
          }
          editPosition(t, e, n = !1) {
            if (x(this.children, t))
              return (
                (this.children[t].position = e),
                n ||
                  this.putMessageOnPipe("recalcDuration", {}, "Groups", {
                    selfExecute: !0,
                    direction: Z._UP,
                  }),
                { result: !0 }
              );
          }
          putMessageOnPipe(t, e, n, s = {}) {
            if (
              (x(s, "direction") || (s.direction = Z._DOWN),
              s.direction !== Z._DOWN ||
                x(s, "positionDelta") ||
                (s.positionDelta = 0),
              s.direction === Z._UP)
            )
              return super.putMessageOnPipe(t, e, n, s);
            const i = super.putMessageOnPipe(t, e, n, s);
            if (i.length) return i;
            for (const a in this.children) {
              const { leaf: l } = this.children[a],
                c =
                  ((r = Fs({}, s)),
                  (o = {
                    selfExecute: !0,
                    positionDelta: s.positionDelta + this.children[a].position,
                  }),
                  Ls(r, js(o)));
              i.push(...l.putMessageOnPipe(t, e, n, c));
            }
            var r, o;
            return i;
          }
          putMsgOnPipeWithResult(t, e, n, s = {}) {
            return this.putMessageOnPipe(t, e, n, s), { result: !0 };
          }
          handleGetPositionOnPyramidion(t, e) {
            const n = e.delta + this.getLeafPosition(e.id);
            return this.getPositionOnPyramidion(n);
          }
        }
        var Hs = Object.defineProperty,
          Ys = (t, e, n) => (
            ((t, e, n) => {
              e in t
                ? Hs(t, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: n,
                  })
                : (t[e] = n);
            })(t, "symbol" != typeof e ? e + "" : e, n),
            n
          );
        class Us extends Xs {
          constructor(t, e) {
            super(e),
              Ys(this, "hasIncidents"),
              Ys(this, "instantiatedCopiesContexts"),
              Ys(this, "handleRemoveIncident", this.handleMoveIncident),
              (this.mc_plugin_npm_name = u),
              (this.plugin_channel_class = Y),
              (this.hasIncidents = !0),
              this.onGroupInitialise(),
              (this.calculatedDuration = 0);
          }
          onGroupInitialise() {}
          handleAddIncident(t, e) {
            if (this.id === t) {
              const t = (0, e.incidentFromDescription)(
                e.incident,
                e.contextData
              );
              if (null !== t) return t;
            }
            return this.bypass();
          }
          handleMoveIncident(t, e) {
            if (this.id === t) {
              const t = this.getLeafById(e.incidentId, !0);
              if (null !== t) return t;
            }
            return this.bypass();
          }
          handleResize(t) {
            return this.id === t ? this : this.bypass();
          }
          removeChild(t) {
            return this.children[t].leaf.lastWish(), super.removeChild(t);
          }
          getIncidentsByChannel(t = 0, e = 0) {
            const n = {
              [u]: [
                {
                  millisecond: t,
                  parentMillisecond: e,
                  incident: this,
                  id: this.id,
                },
              ],
            };
            for (const e in this.children) {
              const s = this.children[e],
                i = s.leaf.getIncidentsByChannel(t + s.position, t);
              for (const t in i)
                x(n, t) ? (n[t] = n[t].concat(i[t])) : (n[t] = i[t]);
            }
            return n;
          }
          lastWish() {
            for (const t in this.children) this.children[t].leaf.lastWish();
          }
        }
        var Ws = Object.defineProperty,
          qs = Object.defineProperties,
          Gs = Object.getOwnPropertyDescriptors,
          Zs = Object.getOwnPropertySymbols,
          Ks = Object.prototype.hasOwnProperty,
          Js = Object.prototype.propertyIsEnumerable,
          Qs = (t, e, n) =>
            e in t
              ? Ws(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (t[e] = n),
          ti = (t, e) => {
            for (var n in e || (e = {})) Ks.call(e, n) && Qs(t, n, e[n]);
            if (Zs) for (var n of Zs(e)) Js.call(e, n) && Qs(t, n, e[n]);
            return t;
          },
          ei = (t, e) => qs(t, Gs(e)),
          ni = (t, e, n) => (Qs(t, "symbol" != typeof e ? e + "" : e, n), n);
        class si extends ps {
          constructor(t, e, n, s) {
            if (
              (super(
                ei(ti({}, t.props), {
                  id: `${t.incidentId}_${n}${null != s ? "_" + s : ""}`,
                })
              ),
              ni(this, "attribute"),
              ni(this, "originalAnimatedAttributeValue"),
              ni(this, "repeatDuration"),
              ni(this, "originalClipContext"),
              (this.contexts = {}),
              (this.constructionIngredients = t),
              (this.mcid = n),
              (this.attribute = s),
              (this.mc_plugin_npm_name = t.plugin_npm_name),
              (this.plugin_channel_class = t.Channel),
              (this.DescriptiveIncident = t.DescriptiveIncident),
              this.addContext(e),
              null !== s)
            ) {
              const t =
                this.constructionIngredients.attrs.animatedAttrs[
                  this.attribute
                ];
              Array.isArray(t)
                ? (this.originalAnimatedAttributeValue = [...t])
                : v(t)
                ? (this.originalAnimatedAttributeValue = ti({}, t))
                : (this.originalAnimatedAttributeValue = t);
            }
            (this.easing = Jn.linear),
              x(this.props, "easing") &&
                (this.easing = Array.isArray(this.props.easing)
                  ? xs(
                      this.props.easing[0],
                      this.props.easing[1],
                      this.props.easing[2],
                      this.props.easing[3]
                    )
                  : Jn[this.props.easing]),
              (this._duration = super.duration),
              (this.repeatDuration =
                this.delay + this.props.duration + this.hiatus);
          }
          exportLiveDefinition(t) {
            throw new Error("Method not implemented.");
          }
          manageEditAttrProps(t, e) {
            throw new Error("Method not implemented.");
          }
          get originalContext() {
            return this.contexts[this.originalContextKey];
          }
          get duration() {
            return this._duration;
          }
          set duration(t) {
            super.duration = t;
            for (const e in this.contexts) this.contexts[e].duration = t;
            (this._duration = super.duration),
              (this.repeatDuration =
                this.delay + this.props.duration + this.hiatus);
          }
          addContext(t, e = !1) {
            let n = !1;
            0 === Object.keys(this.contexts).length &&
              ((this.originalContextKey = t.clipId),
              (this.originalClipContext = t.context),
              (n = !0));
            const s = Ct(
              ei(ti({}, this.constructionIngredients), {
                context: t.context,
                mcid: this.mcid,
              })
            );
            (this.contexts[t.clipId] = s),
              n ||
                null == this.attribute ||
                this.contexts[t.clipId].setInitialValue(this.initialValue),
              e &&
                this.contexts[t.clipId].context.contextLoaded &&
                this.contexts[t.clipId]._onGetContextOnce();
          }
          handleAddContext(t, e) {
            return this.addContext(e, !0), !0;
          }
          handleContextLoaded(t, e) {
            return this._onGetContextOnce(), !0;
          }
          onProgress(t, e) {
            const n = this.props.delay || 0;
            let s = t % this.repeatDuration;
            0 !== t && 0 === s && (s = n + this.props.duration);
            let i = s - n;
            i < 0
              ? (i = 0)
              : i > this.props.duration && (i = this.props.duration);
            const r = i / this.props.duration,
              o = this.easing(r) * this.props.duration;
            if (null != e) this.contexts[e].onProgress(o);
            else
              for (const t in this.contexts)
                (this.originalContextKey === t &&
                  !0 === this.originalContext.fragment) ||
                  this.contexts[t].onProgress(o);
          }
          get animatedAttributeValue() {
            return this.constructionIngredients.attrs.animatedAttrs[
              this.attribute
            ];
          }
          set animatedAttributeValue(t) {
            this.constructionIngredients.attrs.animatedAttrs[this.attribute] =
              t;
          }
          gotContext() {
            for (const t in this.contexts) this.contexts[t].gotContext();
          }
          _onGetContextOnce() {
            if (this.originalContext.context.contextLoaded)
              for (const t in this.contexts)
                this.contexts[t]._onGetContextOnce();
          }
          lastWish() {
            for (const t in this.contexts) this.contexts[t].lastWish();
          }
          onGetContext() {
            if (0 != !this.originalContext.contextLoaded)
              for (const t in this.contexts)
                this.contexts[t].context.contextLoaded &&
                  this.contexts[t].onGetContext();
          }
          get initialValue() {
            return this.originalContext.initialValue;
          }
          get scratchValue() {
            return this.originalContext.scratchValue;
          }
          get pureInitialValues() {
            return this.originalContext.pureInitialValues;
          }
          setInitialValue(t, e = !0) {
            const n = w(null != t ? t : this.getScratchValue());
            for (const t in this.contexts)
              this.contexts[t].setInitialValue(n, e);
          }
          getScratchValue(t = null) {
            if (!1 === this.originalContext.context.contextLoaded) return 0;
            if (null != t) return this.contexts[t].getScratchValue();
            if (x(this.originalClipContext, "nonFragmentedContext"))
              return Ct(
                ei(ti({}, this.constructionIngredients), {
                  context: this.originalClipContext.nonFragmentedContext,
                  mcid: this.mcid,
                })
              ).getScratchValue();
            const e = Object.keys(this.contexts);
            return 1 === e.length
              ? this.originalContext.getScratchValue()
              : this.contexts[e[1]].getScratchValue();
          }
          play(t, e, n) {
            return this.contexts[n].play(e);
          }
          stop(t) {
            this.contexts[t].stop();
          }
        }
        var ii = Object.defineProperty,
          ri = Object.defineProperties,
          oi = Object.getOwnPropertyDescriptors,
          ai = Object.getOwnPropertySymbols,
          li = Object.prototype.hasOwnProperty,
          ci = Object.prototype.propertyIsEnumerable,
          ui = (t, e, n) =>
            e in t
              ? ii(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (t[e] = n),
          pi = (t, e) => {
            for (var n in e || (e = {})) li.call(e, n) && ui(t, n, e[n]);
            if (ai) for (var n of ai(e)) ci.call(e, n) && ui(t, n, e[n]);
            return t;
          },
          hi = (t, e) => ri(t, oi(e));
        class di extends Us {
          constructor(t, e, n, s, i) {
            var r;
            super({}, { id: `${t.id}_${n}` }),
              ui(this, "symbol" != typeof (r = "data") ? r + "" : r, void 0),
              (this.mcid = n),
              (this.selector = s),
              (this.data = i),
              this.setUp(t, e);
          }
          exportLiveDefinition(t) {
            throw new Error("Method not implemented.");
          }
          manageEditAttrProps(t, e) {
            throw new Error("Method not implemented.");
          }
          setUp(t, e) {
            for (const n in this.data.attrs.animatedAttrs) {
              const s = { [n]: this.data.attrs.animatedAttrs[n] },
                i = hi(pi({}, this.data.attrs), { animatedAttrs: s }),
                r = hi(pi({}, this.data.props), { selector: this.selector }),
                o = {
                  incidentId: t.id,
                  attrs: i,
                  props: r,
                  Incident: t.constructor.Incident,
                  plugin_npm_name: t.constructor.plugin_npm_name,
                  Channel: t.constructor.Channel,
                  DescriptiveIncident: t,
                },
                a = new si(o, e, this.mcid, n);
              this.addChild(a, 0);
            }
          }
        }
        var mi = Object.defineProperty,
          fi = (t, e, n) => (
            ((t, e, n) => {
              e in t
                ? mi(t, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: n,
                  })
                : (t[e] = n);
            })(t, "symbol" != typeof e ? e + "" : e, n),
            n
          );
        class gi extends Us {
          constructor(t, e) {
            super({}, { id: t.id, duration: t.duration }),
              fi(this, "initParams"),
              fi(this, "staggerAttrs"),
              fi(this, "staggerProps"),
              (this.contexts = { [e.clipId]: e.context }),
              (this.originalContextKey = e.clipId),
              (this.initParams = e.context.initParams),
              (this.instantiatedCopiesContexts = e.instantiatedCopiesContexts),
              (this.descriptiveIncident = t),
              (this.staggerAttrs = []),
              (this.staggerProps = []),
              this.setUp(t, e);
          }
          get originalContext() {
            return this.contexts[this.originalContextKey];
          }
          parsePropsDynamicValues(t, e) {
            for (let n = 0; n < t.propsStaggers.length; n++) {
              const s = t.propsStaggers[n];
              this.staggerProps.push({
                path: s.path,
                values: s.stagger.calculateValues(e, this.initParams),
              });
            }
          }
          parseAttrsDynamicValues(t, e) {
            for (let n = 0; n < t.attributesStaggers.length; n++) {
              const s = t.attributesStaggers[n];
              this.staggerAttrs.push({
                path: s.path,
                values: s.stagger.calculateValues(e, this.initParams),
              });
            }
          }
          setUp(t, e) {
            const n = this.originalContext.getElements(t.selector());
            let s, i;
            this.parsePropsDynamicValues(t, n),
              this.parseAttrsDynamicValues(t, n);
            for (let r = 0; r < n.length; r++) {
              (s = n[r]), (i = this._getElementMCID(s));
              for (const e in this.instantiatedCopiesContexts)
                this._setElementMCID(
                  this.instantiatedCopiesContexts[e],
                  this.instantiatedCopiesContexts[e].getElements(t.selector())[
                    r
                  ],
                  i
                );
              this._createElementIncident(s, t, e, r, n.length, i);
            }
          }
          handleRecalcDuration(t, e) {
            const n = super.handleRecalcDuration(t, e);
            return (
              this.descriptiveIncident.propsStaggers.length > 0 &&
                (this.descriptiveIncident.dynamicDurationValue =
                  1 * this.duration),
              n
            );
          }
          lastWish() {
            this.descriptiveIncident.propsStaggers.length > 0 &&
              ((this.descriptiveIncident.dynamicDurationValue = null),
              this.descriptiveIncident.putMessageOnPipe(
                "setDurationDynamic",
                {},
                "Groups",
                { selfExecute: !1, direction: Z._UP }
              )),
              super.lastWish();
          }
          _getElementMCID(t) {
            let e = this.originalContext.getMCID(t);
            return e || ((e = A(!0)), this.originalContext.setMCID(t, e)), e;
          }
          _setElementMCID(t, e, n) {
            t.getMCID(e) || t.setMCID(e, n);
          }
          _prepareAttrsPropsForElement(t, e) {
            const n = (function (t, e) {
                const n = [];
                for (let s = 0; s < t.length; s++)
                  n.push({ path: t[s].path, value: t[s].values[e] });
                return n;
              })(this.staggerAttrs, e),
              s = (function (t, e) {
                const n = [];
                for (let s = 0; s < t.length; s++)
                  n.push({ path: t[s].path, value: t[s].values[e] });
                return n;
              })(this.staggerProps, e);
            let i = t.attrs,
              r = t.props;
            if (n.length > 0) {
              i = w(t.attrs);
              for (let t = 0; t < n.length; t++) B(i, n[t].path, n[t].value);
            }
            if (s.length > 0) {
              r = w(t.props);
              for (let t = 0; t < s.length; t++) B(r, s[t].path, s[t].value);
            }
            return { attrs: i, props: r };
          }
          _createElementIncident(t, e, n, s, i, r) {
            const o = this._prepareAttrsPropsForElement(e, s);
            if (x(e.attrs, "animatedAttrs")) {
              const t = new di(
                e,
                n,
                r,
                n.context.getElementSelectorByMCID(r),
                o
              );
              return void this.addChild(t, 0);
            }
            const a = o.attrs,
              l = o.props,
              c = {
                incidentId: e.id,
                attrs: a,
                props: l,
                Incident: e.constructor.Incident,
                plugin_npm_name: e.constructor.plugin_npm_name,
                Channel: e.constructor.Channel,
                DescriptiveIncident: e,
              },
              u = new si(c, n, r, null);
            this.addChild(u, 0);
          }
          exportLiveDefinition(t) {
            throw new Error("Method not implemented.");
          }
          manageEditAttrProps(t, e) {
            throw new Error("Method not implemented.");
          }
        }
        var yi = Object.defineProperty,
          vi = Object.defineProperties,
          bi = Object.getOwnPropertyDescriptors,
          xi = Object.getOwnPropertySymbols,
          wi = Object.prototype.hasOwnProperty,
          Ci = Object.prototype.propertyIsEnumerable,
          Ii = (t, e, n) =>
            e in t
              ? yi(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (t[e] = n),
          Pi = (t, e) => {
            for (var n in e || (e = {})) wi.call(e, n) && Ii(t, n, e[n]);
            if (xi) for (var n of xi(e)) Ci.call(e, n) && Ii(t, n, e[n]);
            return t;
          },
          Ei = (t, e) => vi(t, bi(e));
        class ki extends gi {
          constructor(t, e) {
            super(t, e), (this.realClip = t.realClip);
          }
          _createElementIncident(t, e, n, s, i, r) {
            const o = this._prepareAttrsPropsForElement(e, s);
            if (e.realClip.isNullClip) {
              const t = G(Object.assign(e.exportLiveDefinition(), o));
              (e.realClip = t.realClip),
                e.subscribe(
                  A(),
                  (e, n) => {
                    t._setState(n);
                  },
                  0,
                  1,
                  !0
                ),
                (t.handleSetBlock = (n, s) =>
                  e.putMessageOnPipe(
                    "setBlock",
                    Ei(Pi({}, s), { id: t.id }),
                    "rootClip",
                    { selfExecute: !0, direction: Z._UP }
                  )),
                (t.handleUnBlock = () =>
                  e.putMessageOnPipe("unBlock", { id: t.id }, "rootClip", {
                    selfExecute: !0,
                    direction: Z._UP,
                  }));
            }
            const a = e.realClip.exportConstructionArguments(),
              l = Ei(
                Pi(
                  Pi(
                    Ei(Pi({}, e.props), { duration: e.realClip.duration }),
                    a.props
                  ),
                  o.props
                ),
                { selector: n.context.getElementSelectorByMCID(r) }
              ),
              c = {
                incidentId: e.id,
                attrs: a.attrs,
                props: l,
                Incident: e.constructor.Incident,
                plugin_npm_name: e.constructor.plugin_npm_name,
                Channel: q,
                DescriptiveIncident: e,
              },
              u = new As(c, n, r, e);
            this.addChild(u, 0);
          }
          exportLiveDefinition(t) {
            throw new Error("Method not implemented.");
          }
          manageEditAttrProps(t, e) {
            throw new Error("Method not implemented.");
          }
        }
        var Si = At({
            "../../node_modules/.pnpm/fastest-validator@1.17.0/node_modules/fastest-validator/dist/index.min.js"(
              t,
              e
            ) {
              var n = n || {};
              (n.scope = {}),
                (n.arrayIteratorImpl = function (t) {
                  var e = 0;
                  return function () {
                    return e < t.length
                      ? { done: !1, value: t[e++] }
                      : { done: !0 };
                  };
                }),
                (n.arrayIterator = function (t) {
                  return { next: n.arrayIteratorImpl(t) };
                }),
                (n.ASSUME_ES5 = !1),
                (n.ASSUME_NO_NATIVE_MAP = !1),
                (n.ASSUME_NO_NATIVE_SET = !1),
                (n.SIMPLE_FROUND_POLYFILL = !1),
                (n.ISOLATE_POLYFILLS = !1),
                (n.FORCE_POLYFILL_PROMISE = !1),
                (n.FORCE_POLYFILL_PROMISE_WHEN_NO_UNHANDLED_REJECTION = !1),
                (n.defineProperty =
                  n.ASSUME_ES5 || "function" == typeof Object.defineProperties
                    ? Object.defineProperty
                    : function (t, e, n) {
                        return (
                          t == Array.prototype ||
                            t == Object.prototype ||
                            (t[e] = n.value),
                          t
                        );
                      }),
                (n.getGlobal = function (t) {
                  t = [
                    "object" == typeof globalThis && globalThis,
                    t,
                    "object" == typeof window && window,
                    "object" == typeof self && self,
                    "object" == typeof global && global,
                  ];
                  for (var e = 0; e < t.length; ++e) {
                    var n = t[e];
                    if (n && n.Math == Math) return n;
                  }
                  throw Error("Cannot find global object");
                }),
                (n.global = n.getGlobal(t)),
                (n.IS_SYMBOL_NATIVE =
                  "function" == typeof Symbol &&
                  "symbol" == typeof Symbol("x")),
                (n.TRUST_ES6_POLYFILLS =
                  !n.ISOLATE_POLYFILLS || n.IS_SYMBOL_NATIVE),
                (n.polyfills = {}),
                (n.propertyToPolyfillSymbol = {}),
                (n.POLYFILL_PREFIX = "$jscp$"),
                (n.polyfill = function (t, e, s, i) {
                  e &&
                    (n.ISOLATE_POLYFILLS
                      ? n.polyfillIsolated(t, e, s, i)
                      : n.polyfillUnisolated(t, e, s, i));
                }),
                (n.polyfillUnisolated = function (t, e) {
                  var s = n.global;
                  t = t.split(".");
                  for (var i = 0; i < t.length - 1; i++) {
                    var r = t[i];
                    if (!(r in s)) return;
                    s = s[r];
                  }
                  (e = e((i = s[(t = t[t.length - 1])]))) != i &&
                    null != e &&
                    n.defineProperty(s, t, {
                      configurable: !0,
                      writable: !0,
                      value: e,
                    });
                }),
                (n.polyfillIsolated = function (t, e, s) {
                  var i = t.split(".");
                  t = 1 === i.length;
                  var r = i[0];
                  r = !t && r in n.polyfills ? n.polyfills : n.global;
                  for (var o = 0; o < i.length - 1; o++) {
                    var a = i[o];
                    if (!(a in r)) return;
                    r = r[a];
                  }
                  (i = i[i.length - 1]),
                    null !=
                      (e = e(
                        (s = n.IS_SYMBOL_NATIVE && "es6" === s ? r[i] : null)
                      )) &&
                      (t
                        ? n.defineProperty(n.polyfills, i, {
                            configurable: !0,
                            writable: !0,
                            value: e,
                          })
                        : e !== s &&
                          (void 0 === n.propertyToPolyfillSymbol[i] &&
                            ((t = (1e9 * Math.random()) >>> 0),
                            (n.propertyToPolyfillSymbol[i] = n.IS_SYMBOL_NATIVE
                              ? n.global.Symbol(i)
                              : n.POLYFILL_PREFIX + t + "$" + i)),
                          n.defineProperty(r, n.propertyToPolyfillSymbol[i], {
                            configurable: !0,
                            writable: !0,
                            value: e,
                          })));
                }),
                (n.initSymbol = function () {}),
                n.polyfill(
                  "Symbol",
                  function (t) {
                    function e(t, e) {
                      (this.$jscomp$symbol$id_ = t),
                        n.defineProperty(this, "description", {
                          configurable: !0,
                          writable: !0,
                          value: e,
                        });
                    }
                    if (t) return t;
                    e.prototype.toString = function () {
                      return this.$jscomp$symbol$id_;
                    };
                    var s =
                        "jscomp_symbol_" + ((1e9 * Math.random()) >>> 0) + "_",
                      i = 0;
                    return function t(n) {
                      if (this instanceof t)
                        throw new TypeError("Symbol is not a constructor");
                      return new e(s + (n || "") + "_" + i++, n);
                    };
                  },
                  "es6",
                  "es3"
                ),
                n.polyfill(
                  "Symbol.iterator",
                  function (t) {
                    if (t) return t;
                    t = Symbol("Symbol.iterator");
                    for (
                      var e =
                          "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(
                            " "
                          ),
                        s = 0;
                      s < e.length;
                      s++
                    ) {
                      var i = n.global[e[s]];
                      "function" == typeof i &&
                        "function" != typeof i.prototype[t] &&
                        n.defineProperty(i.prototype, t, {
                          configurable: !0,
                          writable: !0,
                          value: function () {
                            return n.iteratorPrototype(
                              n.arrayIteratorImpl(this)
                            );
                          },
                        });
                    }
                    return t;
                  },
                  "es6",
                  "es3"
                ),
                (n.iteratorPrototype = function (t) {
                  return (
                    ((t = { next: t })[Symbol.iterator] = function () {
                      return this;
                    }),
                    t
                  );
                }),
                (n.iteratorFromArray = function (t, e) {
                  t instanceof String && (t += "");
                  var n = 0,
                    s = !1,
                    i = {
                      next: function () {
                        if (!s && n < t.length) {
                          var i = n++;
                          return { value: e(i, t[i]), done: !1 };
                        }
                        return (s = !0), { done: !0, value: void 0 };
                      },
                    };
                  return (
                    (i[Symbol.iterator] = function () {
                      return i;
                    }),
                    i
                  );
                }),
                n.polyfill(
                  "Array.prototype.keys",
                  function (t) {
                    return (
                      t ||
                      function () {
                        return n.iteratorFromArray(this, function (t) {
                          return t;
                        });
                      }
                    );
                  },
                  "es6",
                  "es3"
                ),
                n.polyfill(
                  "Array.prototype.values",
                  function (t) {
                    return (
                      t ||
                      function () {
                        return n.iteratorFromArray(this, function (t, e) {
                          return e;
                        });
                      }
                    );
                  },
                  "es8",
                  "es3"
                ),
                (n.checkStringArgs = function (t, e, n) {
                  if (null == t)
                    throw new TypeError(
                      "The 'this' value for String.prototype." +
                        n +
                        " must not be null or undefined"
                    );
                  if (e instanceof RegExp)
                    throw new TypeError(
                      "First argument to String.prototype." +
                        n +
                        " must not be a regular expression"
                    );
                  return t + "";
                }),
                n.polyfill(
                  "String.prototype.startsWith",
                  function (t) {
                    return (
                      t ||
                      function (t, e) {
                        var s = n.checkStringArgs(this, t, "startsWith");
                        t += "";
                        var i = s.length,
                          r = t.length;
                        e = Math.max(0, Math.min(0 | e, s.length));
                        for (var o = 0; o < r && e < i; )
                          if (s[e++] != t[o++]) return !1;
                        return o >= r;
                      }
                    );
                  },
                  "es6",
                  "es3"
                ),
                (n.owns = function (t, e) {
                  return Object.prototype.hasOwnProperty.call(t, e);
                }),
                (n.assign =
                  n.TRUST_ES6_POLYFILLS && "function" == typeof Object.assign
                    ? Object.assign
                    : function (t, e) {
                        for (var s = 1; s < arguments.length; s++) {
                          var i = arguments[s];
                          if (i) for (var r in i) n.owns(i, r) && (t[r] = i[r]);
                        }
                        return t;
                      }),
                n.polyfill(
                  "Object.assign",
                  function (t) {
                    return t || n.assign;
                  },
                  "es6",
                  "es3"
                ),
                (n.checkEs6ConformanceViaProxy = function () {
                  try {
                    var t = {},
                      e = Object.create(
                        new n.global.Proxy(t, {
                          get: function (n, s, i) {
                            return n == t && "q" == s && i == e;
                          },
                        })
                      );
                    return !0 === e.q;
                  } catch (t) {
                    return !1;
                  }
                }),
                (n.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS = !1),
                (n.ES6_CONFORMANCE =
                  n.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS &&
                  n.checkEs6ConformanceViaProxy()),
                (n.makeIterator = function (t) {
                  var e =
                    "undefined" != typeof Symbol &&
                    Symbol.iterator &&
                    t[Symbol.iterator];
                  return e ? e.call(t) : n.arrayIterator(t);
                }),
                n.polyfill(
                  "WeakMap",
                  function (t) {
                    function e(t) {
                      if (
                        ((this.id_ = (l += Math.random() + 1).toString()), t)
                      ) {
                        t = n.makeIterator(t);
                        for (var e; !(e = t.next()).done; )
                          (e = e.value), this.set(e[0], e[1]);
                      }
                    }
                    function s() {}
                    function i(t) {
                      var e = typeof t;
                      return ("object" === e && null !== t) || "function" === e;
                    }
                    function r(t) {
                      if (!n.owns(t, a)) {
                        var e = new s();
                        n.defineProperty(t, a, { value: e });
                      }
                    }
                    function o(t) {
                      if (!n.ISOLATE_POLYFILLS) {
                        var e = Object[t];
                        e &&
                          (Object[t] = function (t) {
                            return t instanceof s
                              ? t
                              : (Object.isExtensible(t) && r(t), e(t));
                          });
                      }
                    }
                    if (n.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS) {
                      if (t && n.ES6_CONFORMANCE) return t;
                    } else if (
                      (function () {
                        if (!t || !Object.seal) return !1;
                        try {
                          var e = Object.seal({}),
                            n = Object.seal({}),
                            s = new t([
                              [e, 2],
                              [n, 3],
                            ]);
                          return (
                            2 == s.get(e) &&
                            3 == s.get(n) &&
                            (s.delete(e),
                            s.set(n, 4),
                            !s.has(e) && 4 == s.get(n))
                          );
                        } catch (t) {
                          return !1;
                        }
                      })()
                    )
                      return t;
                    var a = "$jscomp_hidden_" + Math.random();
                    o("freeze"), o("preventExtensions"), o("seal");
                    var l = 0;
                    return (
                      (e.prototype.set = function (t, e) {
                        if (!i(t)) throw Error("Invalid WeakMap key");
                        if ((r(t), !n.owns(t, a)))
                          throw Error("WeakMap key fail: " + t);
                        return (t[a][this.id_] = e), this;
                      }),
                      (e.prototype.get = function (t) {
                        return i(t) && n.owns(t, a) ? t[a][this.id_] : void 0;
                      }),
                      (e.prototype.has = function (t) {
                        return i(t) && n.owns(t, a) && n.owns(t[a], this.id_);
                      }),
                      (e.prototype.delete = function (t) {
                        return (
                          !!(i(t) && n.owns(t, a) && n.owns(t[a], this.id_)) &&
                          delete t[a][this.id_]
                        );
                      }),
                      e
                    );
                  },
                  "es6",
                  "es3"
                ),
                (n.MapEntry = function () {}),
                n.polyfill(
                  "Map",
                  function (t) {
                    function e() {
                      var t = {};
                      return (t.previous = t.next = t.head = t);
                    }
                    function s(t, e) {
                      var s = t.head_;
                      return n.iteratorPrototype(function () {
                        if (s) {
                          for (; s.head != t.head_; ) s = s.previous;
                          for (; s.next != s.head; )
                            return (s = s.next), { done: !1, value: e(s) };
                          s = null;
                        }
                        return { done: !0, value: void 0 };
                      });
                    }
                    function i(t, e) {
                      var s = e && typeof e;
                      "object" == s || "function" == s
                        ? o.has(e)
                          ? (s = o.get(e))
                          : ((s = "" + ++a), o.set(e, s))
                        : (s = "p_" + e);
                      var i = t.data_[s];
                      if (i && n.owns(t.data_, s))
                        for (t = 0; t < i.length; t++) {
                          var r = i[t];
                          if ((e != e && r.key != r.key) || e === r.key)
                            return { id: s, list: i, index: t, entry: r };
                        }
                      return { id: s, list: i, index: -1, entry: void 0 };
                    }
                    function r(t) {
                      if (
                        ((this.data_ = {}),
                        (this.head_ = e()),
                        (this.size = 0),
                        t)
                      ) {
                        t = n.makeIterator(t);
                        for (var s; !(s = t.next()).done; )
                          (s = s.value), this.set(s[0], s[1]);
                      }
                    }
                    if (n.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS) {
                      if (t && n.ES6_CONFORMANCE) return t;
                    } else if (
                      (function () {
                        if (
                          n.ASSUME_NO_NATIVE_MAP ||
                          !t ||
                          "function" != typeof t ||
                          !t.prototype.entries ||
                          "function" != typeof Object.seal
                        )
                          return !1;
                        try {
                          var e = Object.seal({ x: 4 }),
                            s = new t(n.makeIterator([[e, "s"]]));
                          if (
                            "s" != s.get(e) ||
                            1 != s.size ||
                            s.get({ x: 4 }) ||
                            s.set({ x: 4 }, "t") != s ||
                            2 != s.size
                          )
                            return !1;
                          var i = s.entries(),
                            r = i.next();
                          return (
                            !r.done &&
                            r.value[0] == e &&
                            "s" == r.value[1] &&
                            !(
                              (r = i.next()).done ||
                              4 != r.value[0].x ||
                              "t" != r.value[1] ||
                              !i.next().done
                            )
                          );
                        } catch (t) {
                          return !1;
                        }
                      })()
                    )
                      return t;
                    var o = new WeakMap();
                    (r.prototype.set = function (t, e) {
                      var n = i(this, (t = 0 === t ? 0 : t));
                      return (
                        n.list || (n.list = this.data_[n.id] = []),
                        n.entry
                          ? (n.entry.value = e)
                          : ((n.entry = {
                              next: this.head_,
                              previous: this.head_.previous,
                              head: this.head_,
                              key: t,
                              value: e,
                            }),
                            n.list.push(n.entry),
                            (this.head_.previous.next = n.entry),
                            (this.head_.previous = n.entry),
                            this.size++),
                        this
                      );
                    }),
                      (r.prototype.delete = function (t) {
                        return !(
                          !(t = i(this, t)).entry ||
                          !t.list ||
                          (t.list.splice(t.index, 1),
                          t.list.length || delete this.data_[t.id],
                          (t.entry.previous.next = t.entry.next),
                          (t.entry.next.previous = t.entry.previous),
                          (t.entry.head = null),
                          this.size--,
                          0)
                        );
                      }),
                      (r.prototype.clear = function () {
                        (this.data_ = {}),
                          (this.head_ = this.head_.previous = e()),
                          (this.size = 0);
                      }),
                      (r.prototype.has = function (t) {
                        return !!i(this, t).entry;
                      }),
                      (r.prototype.get = function (t) {
                        return (t = i(this, t).entry) && t.value;
                      }),
                      (r.prototype.entries = function () {
                        return s(this, function (t) {
                          return [t.key, t.value];
                        });
                      }),
                      (r.prototype.keys = function () {
                        return s(this, function (t) {
                          return t.key;
                        });
                      }),
                      (r.prototype.values = function () {
                        return s(this, function (t) {
                          return t.value;
                        });
                      }),
                      (r.prototype.forEach = function (t, e) {
                        for (var n, s = this.entries(); !(n = s.next()).done; )
                          (n = n.value), t.call(e, n[1], n[0], this);
                      }),
                      (r.prototype[Symbol.iterator] = r.prototype.entries);
                    var a = 0;
                    return r;
                  },
                  "es6",
                  "es3"
                ),
                n.polyfill(
                  "String.prototype.endsWith",
                  function (t) {
                    return (
                      t ||
                      function (t, e) {
                        var s = n.checkStringArgs(this, t, "endsWith");
                        (t += ""),
                          void 0 === e && (e = s.length),
                          (e = Math.max(0, Math.min(0 | e, s.length)));
                        for (var i = t.length; 0 < i && 0 < e; )
                          if (s[--e] != t[--i]) return !1;
                        return 0 >= i;
                      }
                    );
                  },
                  "es6",
                  "es3"
                ),
                n.polyfill(
                  "Number.isNaN",
                  function (t) {
                    return (
                      t ||
                      function (t) {
                        return "number" == typeof t && isNaN(t);
                      }
                    );
                  },
                  "es6",
                  "es3"
                ),
                n.polyfill(
                  "Object.entries",
                  function (t) {
                    return (
                      t ||
                      function (t) {
                        var e,
                          s = [];
                        for (e in t) n.owns(t, e) && s.push([e, t[e]]);
                        return s;
                      }
                    );
                  },
                  "es8",
                  "es3"
                );
              var s = t;
              function i() {
                function t(t) {
                  if (
                    ((this.opts = {}),
                    (this.defaults = {}),
                    (this.messages = Object.assign({}, M)),
                    (this.rules = {
                      any: P,
                      array: I,
                      boolean: C,
                      class: w,
                      custom: x,
                      currency: b,
                      date: v,
                      email: y,
                      enum: g,
                      equal: f,
                      forbidden: m,
                      function: d,
                      multi: h,
                      number: p,
                      object: u,
                      objectID: c,
                      record: l,
                      string: a,
                      tuple: o,
                      url: r,
                      uuid: i,
                      mac: s,
                      luhn: n,
                    }),
                    (this.aliases = {}),
                    (this.cache = new Map()),
                    t)
                  ) {
                    if (
                      (k(this.opts, t),
                      t.defaults && k(this.defaults, t.defaults),
                      t.messages)
                    )
                      for (var E in t.messages)
                        this.addMessage(E, t.messages[E]);
                    if (t.aliases)
                      for (var S in t.aliases) this.alias(S, t.aliases[S]);
                    if (t.customRules)
                      for (var O in t.customRules)
                        this.add(O, t.customRules[O]);
                    if (t.plugins) {
                      if (((t = t.plugins), !Array.isArray(t)))
                        throw Error("Plugins type must be array");
                      t.forEach(this.plugin.bind(this));
                    }
                    this.opts.debug &&
                      ((t = function (t) {
                        return t;
                      }),
                      "undefined" == typeof window && (t = e),
                      (this._formatter = t));
                  }
                }
                function e(t) {
                  return (
                    A ||
                      ((A = O()),
                      (_ = {
                        parser: "babel",
                        useTabs: !1,
                        printWidth: 120,
                        trailingComma: "none",
                        tabWidth: 4,
                        singleQuote: !1,
                        semi: !0,
                        bracketSpacing: !0,
                      }),
                      (T = O()),
                      (D = {
                        language: "js",
                        theme: T.fromJson({
                          keyword: ["white", "bold"],
                          built_in: "magenta",
                          literal: "cyan",
                          number: "magenta",
                          regexp: "red",
                          string: ["yellow", "bold"],
                          symbol: "plain",
                          class: "blue",
                          attr: "plain",
                          function: ["white", "bold"],
                          title: "plain",
                          params: "green",
                          comment: "grey",
                        }),
                      })),
                    (t = A.format(t, _)),
                    T.highlight(t, D)
                  );
                }
                function n(t) {
                  return (
                    t.schema,
                    (t = t.messages),
                    {
                      source:
                        '\n\t\t\tif (typeof value !== "string") {\n\t\t\t\t' +
                        this.makeError({
                          type: "string",
                          actual: "value",
                          messages: t,
                        }) +
                        '\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tif (typeof value !== "string")\n\t\t\t\tvalue = String(value);\n\n\t\t\tval = value.replace(/\\D+/g, "");\n\n\t\t\tvar array = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9];\n\t\t\tvar len = val ? val.length : 0,\n\t\t\t\tbit = 1,\n\t\t\t\tsum = 0;\n\t\t\twhile (len--) {\n\t\t\t\tsum += !(bit ^= 1) ? parseInt(val[len], 10) : array[val[len]];\n\t\t\t}\n\n\t\t\tif (!(sum % 10 === 0 && sum > 0)) {\n\t\t\t\t' +
                        this.makeError({
                          type: "luhn",
                          actual: "value",
                          messages: t,
                        }) +
                        "\n\t\t\t}\n\n\t\t\treturn value;\n\t\t",
                    }
                  );
                }
                function s(t) {
                  return (
                    t.schema,
                    (t = t.messages),
                    {
                      source:
                        '\n\t\t\tif (typeof value !== "string") {\n\t\t\t\t' +
                        this.makeError({
                          type: "string",
                          actual: "value",
                          messages: t,
                        }) +
                        "\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tvar v = value.toLowerCase();\n\t\t\tif (!" +
                        U.toString() +
                        ".test(v)) {\n\t\t\t\t" +
                        this.makeError({
                          type: "mac",
                          actual: "value",
                          messages: t,
                        }) +
                        "\n\t\t\t}\n\t\t\t\n\t\t\treturn value;\n\t\t",
                    }
                  );
                }
                function i(t) {
                  var e = t.schema;
                  t = t.messages;
                  var n = [];
                  return (
                    n.push(
                      '\n\t\tif (typeof value !== "string") {\n\t\t\t' +
                        this.makeError({
                          type: "string",
                          actual: "value",
                          messages: t,
                        }) +
                        "\n\t\t\treturn value;\n\t\t}\n\n\t\tvar val = value.toLowerCase();\n\t\tif (!" +
                        Y.toString() +
                        ".test(val)) {\n\t\t\t" +
                        this.makeError({
                          type: "uuid",
                          actual: "value",
                          messages: t,
                        }) +
                        "\n\t\t\treturn value;\n\t\t}\n\n\t\tconst version = val.charAt(14) | 0;\n\t"
                    ),
                    7 > parseInt(e.version) &&
                      n.push(
                        "\n\t\t\tif (" +
                          e.version +
                          " !== version) {\n\t\t\t\t" +
                          this.makeError({
                            type: "uuidVersion",
                            expected: e.version,
                            actual: "version",
                            messages: t,
                          }) +
                          "\n\t\t\t\treturn value;\n\t\t\t}\n\t\t"
                      ),
                    n.push(
                      '\n\t\tswitch (version) {\n\t\tcase 0:\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 6:\n\t\t\tbreak;\n\t\tcase 3:\n\t\tcase 4:\n\t\tcase 5:\n\t\t\tif (["8", "9", "a", "b"].indexOf(val.charAt(19)) === -1) {\n\t\t\t\t' +
                        this.makeError({
                          type: "uuid",
                          actual: "value",
                          messages: t,
                        }) +
                        "\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t"
                    ),
                    { source: n.join("\n") }
                  );
                }
                function r(t) {
                  var e = t.schema;
                  t = t.messages;
                  var n = [];
                  return (
                    n.push(
                      '\n\t\tif (typeof value !== "string") {\n\t\t\t' +
                        this.makeError({
                          type: "string",
                          actual: "value",
                          messages: t,
                        }) +
                        "\n\t\t\treturn value;\n\t\t}\n\t"
                    ),
                    e.empty
                      ? n.push(
                          "\n\t\t\tif (value.length === 0) return value;\n\t\t"
                        )
                      : n.push(
                          "\n\t\t\tif (value.length === 0) {\n\t\t\t\t" +
                            this.makeError({
                              type: "urlEmpty",
                              actual: "value",
                              messages: t,
                            }) +
                            "\n\t\t\t\treturn value;\n\t\t\t}\n\t\t"
                        ),
                    n.push(
                      "\n\t\tif (!" +
                        H.toString() +
                        ".test(value)) {\n\t\t\t" +
                        this.makeError({
                          type: "url",
                          actual: "value",
                          messages: t,
                        }) +
                        "\n\t\t}\n\n\t\treturn value;\n\t"
                    ),
                    { source: n.join("\n") }
                  );
                }
                function o(t, e, n) {
                  var s = t.schema,
                    i = t.messages;
                  if (((t = []), null != s.items)) {
                    if (!Array.isArray(s.items))
                      throw Error(
                        "Invalid '" +
                          s.type +
                          "' schema. The 'items' field must be an array."
                      );
                    if (0 === s.items.length)
                      throw Error(
                        "Invalid '" +
                          s.type +
                          "' schema. The 'items' field must not be an empty array."
                      );
                  }
                  if (
                    (t.push(
                      "\n\t\tif (!Array.isArray(value)) {\n\t\t\t" +
                        this.makeError({
                          type: "tuple",
                          actual: "value",
                          messages: i,
                        }) +
                        "\n\t\t\treturn value;\n\t\t}\n\n\t\tvar len = value.length;\n\t"
                    ),
                    !1 === s.empty &&
                      t.push(
                        "\n\t\t\tif (len === 0) {\n\t\t\t\t" +
                          this.makeError({
                            type: "tupleEmpty",
                            actual: "value",
                            messages: i,
                          }) +
                          "\n\t\t\t\treturn value;\n\t\t\t}\n\t\t"
                      ),
                    null != s.items)
                  ) {
                    for (
                      t.push(
                        "\n\t\t\tif (" +
                          s.empty +
                          " !== false && len === 0) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tif (len !== " +
                          s.items.length +
                          ") {\n\t\t\t\t" +
                          this.makeError({
                            type: "tupleLength",
                            expected: s.items.length,
                            actual: "len",
                            messages: i,
                          }) +
                          "\n\t\t\t\treturn value;\n\t\t\t}\n\t\t"
                      ),
                        t.push(
                          "\n\t\t\tvar arr = value;\n\t\t\tvar parentField = field;\n\t\t"
                        ),
                        i = 0;
                      i < s.items.length;
                      i++
                    ) {
                      t.push("\n\t\t\tvalue = arr[" + i + "];\n\t\t");
                      var r = e + "[" + i + "]",
                        o = this.getRuleFromSchema(s.items[i]);
                      t.push(
                        this.compileRule(
                          o,
                          n,
                          r,
                          "\n\t\t\tarr[" +
                            i +
                            "] = " +
                            (n.async ? "await " : "") +
                            "context.fn[%%INDEX%%](arr[" +
                            i +
                            '], (parentField ? parentField : "") + "[" + ' +
                            i +
                            ' + "]", parent, errors, context);\n\t\t',
                          "arr[" + i + "]"
                        )
                      );
                    }
                    t.push("\n\t\treturn arr;\n\t");
                  } else t.push("\n\t\treturn value;\n\t");
                  return { source: t.join("\n") };
                }
                function a(t) {
                  var e = t.schema;
                  t = t.messages;
                  var n = [],
                    s = !1;
                  if (
                    (!0 === e.convert &&
                      ((s = !0),
                      n.push(
                        '\n\t\t\tif (typeof value !== "string") {\n\t\t\t\tvalue = String(value);\n\t\t\t}\n\t\t'
                      )),
                    n.push(
                      '\n\t\tif (typeof value !== "string") {\n\t\t\t' +
                        this.makeError({
                          type: "string",
                          actual: "value",
                          messages: t,
                        }) +
                        "\n\t\t\treturn value;\n\t\t}\n\n\t\tvar origValue = value;\n\t"
                    ),
                    e.trim &&
                      ((s = !0), n.push("\n\t\t\tvalue = value.trim();\n\t\t")),
                    e.trimLeft &&
                      ((s = !0),
                      n.push("\n\t\t\tvalue = value.trimLeft();\n\t\t")),
                    e.trimRight &&
                      ((s = !0),
                      n.push("\n\t\t\tvalue = value.trimRight();\n\t\t")),
                    e.padStart &&
                      ((s = !0),
                      n.push(
                        "\n\t\t\tvalue = value.padStart(" +
                          e.padStart +
                          ", " +
                          JSON.stringify(null != e.padChar ? e.padChar : " ") +
                          ");\n\t\t"
                      )),
                    e.padEnd &&
                      ((s = !0),
                      n.push(
                        "\n\t\t\tvalue = value.padEnd(" +
                          e.padEnd +
                          ", " +
                          JSON.stringify(null != e.padChar ? e.padChar : " ") +
                          ");\n\t\t"
                      )),
                    e.lowercase &&
                      ((s = !0),
                      n.push("\n\t\t\tvalue = value.toLowerCase();\n\t\t")),
                    e.uppercase &&
                      ((s = !0),
                      n.push("\n\t\t\tvalue = value.toUpperCase();\n\t\t")),
                    e.localeLowercase &&
                      ((s = !0),
                      n.push(
                        "\n\t\t\tvalue = value.toLocaleLowerCase();\n\t\t"
                      )),
                    e.localeUppercase &&
                      ((s = !0),
                      n.push(
                        "\n\t\t\tvalue = value.toLocaleUpperCase();\n\t\t"
                      )),
                    n.push("\n\t\t\tvar len = value.length;\n\t"),
                    !1 === e.empty
                      ? n.push(
                          "\n\t\t\tif (len === 0) {\n\t\t\t\t" +
                            this.makeError({
                              type: "stringEmpty",
                              actual: "value",
                              messages: t,
                            }) +
                            "\n\t\t\t}\n\t\t"
                        )
                      : !0 === e.empty &&
                        n.push(
                          "\n\t\t\tif (len === 0) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t"
                        ),
                    null != e.min &&
                      n.push(
                        "\n\t\t\tif (len < " +
                          e.min +
                          ") {\n\t\t\t\t" +
                          this.makeError({
                            type: "stringMin",
                            expected: e.min,
                            actual: "len",
                            messages: t,
                          }) +
                          "\n\t\t\t}\n\t\t"
                      ),
                    null != e.max &&
                      n.push(
                        "\n\t\t\tif (len > " +
                          e.max +
                          ") {\n\t\t\t\t" +
                          this.makeError({
                            type: "stringMax",
                            expected: e.max,
                            actual: "len",
                            messages: t,
                          }) +
                          "\n\t\t\t}\n\t\t"
                      ),
                    null != e.length &&
                      n.push(
                        "\n\t\t\tif (len !== " +
                          e.length +
                          ") {\n\t\t\t\t" +
                          this.makeError({
                            type: "stringLength",
                            expected: e.length,
                            actual: "len",
                            messages: t,
                          }) +
                          "\n\t\t\t}\n\t\t"
                      ),
                    null != e.pattern)
                  ) {
                    var i = e.pattern;
                    "string" == typeof e.pattern &&
                      (i = new RegExp(e.pattern, e.patternFlags)),
                      n.push(
                        "\n\t\t\tif (!" +
                          i.toString() +
                          ".test(value)) {\n\t\t\t\t" +
                          this.makeError({
                            type: "stringPattern",
                            expected:
                              '"' + i.toString().replace(/"/g, "\\$&") + '"',
                            actual: "origValue",
                            messages: t,
                          }) +
                          "\n\t\t\t}\n\t\t"
                      );
                  }
                  return (
                    null != e.contains &&
                      n.push(
                        '\n\t\t\tif (value.indexOf("' +
                          e.contains +
                          '") === -1) {\n\t\t\t\t' +
                          this.makeError({
                            type: "stringContains",
                            expected: '"' + e.contains + '"',
                            actual: "origValue",
                            messages: t,
                          }) +
                          "\n\t\t\t}\n\t\t"
                      ),
                    null != e.enum &&
                      ((i = JSON.stringify(e.enum)),
                      n.push(
                        "\n\t\t\tif (" +
                          i +
                          ".indexOf(value) === -1) {\n\t\t\t\t" +
                          this.makeError({
                            type: "stringEnum",
                            expected: '"' + e.enum.join(", ") + '"',
                            actual: "origValue",
                            messages: t,
                          }) +
                          "\n\t\t\t}\n\t\t"
                      )),
                    !0 === e.numeric &&
                      n.push(
                        "\n\t\t\tif (!" +
                          N.toString() +
                          ".test(value) ) {\n\t\t\t\t" +
                          this.makeError({
                            type: "stringNumeric",
                            actual: "origValue",
                            messages: t,
                          }) +
                          "\n\t\t\t}\n\t\t"
                      ),
                    !0 === e.alpha &&
                      n.push(
                        "\n\t\t\tif(!" +
                          $.toString() +
                          ".test(value)) {\n\t\t\t\t" +
                          this.makeError({
                            type: "stringAlpha",
                            actual: "origValue",
                            messages: t,
                          }) +
                          "\n\t\t\t}\n\t\t"
                      ),
                    !0 === e.alphanum &&
                      n.push(
                        "\n\t\t\tif(!" +
                          R.toString() +
                          ".test(value)) {\n\t\t\t\t" +
                          this.makeError({
                            type: "stringAlphanum",
                            actual: "origValue",
                            messages: t,
                          }) +
                          "\n\t\t\t}\n\t\t"
                      ),
                    !0 === e.alphadash &&
                      n.push(
                        "\n\t\t\tif(!" +
                          F.toString() +
                          ".test(value)) {\n\t\t\t\t" +
                          this.makeError({
                            type: "stringAlphadash",
                            actual: "origValue",
                            messages: t,
                          }) +
                          "\n\t\t\t}\n\t\t"
                      ),
                    !0 === e.hex &&
                      n.push(
                        "\n\t\t\tif(value.length % 2 !== 0 || !" +
                          z.toString() +
                          ".test(value)) {\n\t\t\t\t" +
                          this.makeError({
                            type: "stringHex",
                            actual: "origValue",
                            messages: t,
                          }) +
                          "\n\t\t\t}\n\t\t"
                      ),
                    !0 === e.singleLine &&
                      n.push(
                        '\n\t\t\tif(value.includes("\\n")) {\n\t\t\t\t' +
                          this.makeError({
                            type: "stringSingleLine",
                            messages: t,
                          }) +
                          "\n\t\t\t}\n\t\t"
                      ),
                    !0 === e.base64 &&
                      n.push(
                        "\n\t\t\tif(!" +
                          X.toString() +
                          ".test(value)) {\n\t\t\t\t" +
                          this.makeError({
                            type: "stringBase64",
                            actual: "origValue",
                            messages: t,
                          }) +
                          "\n\t\t\t}\n\t\t"
                      ),
                    n.push("\n\t\treturn value;\n\t"),
                    { sanitized: s, source: n.join("\n") }
                  );
                }
                function l(t, e, n) {
                  var s = t.schema,
                    i = [];
                  for (var r in (i.push(
                    '\n\t\tif (typeof value !== "object" || value === null || Array.isArray(value)) {\n\t\t\t' +
                      this.makeError({
                        type: "record",
                        actual: "value",
                        messages: t.messages,
                      }) +
                      "\n\t\t\treturn value;\n\t\t}\n\t"
                  ),
                  (t = s.key || "string"),
                  (s = s.value || "any"),
                  i.push(
                    "\n\t\tconst record = value;\n\t\tlet sanitizedKey, sanitizedValue;\n\t\tconst result = {};\n\t\tfor (let key in value) {\n\t"
                  ),
                  i.push("sanitizedKey = value = key;"),
                  (t = this.getRuleFromSchema(t)).messages))
                    r.startsWith("string") &&
                      (t.messages[r] = t.messages[r].replace(
                        " field ",
                        " key "
                      ));
                  return (
                    i.push(
                      this.compileRule(
                        t,
                        n,
                        null,
                        "\n\t\tsanitizedKey = " +
                          (n.async ? "await " : "") +
                          'context.fn[%%INDEX%%](key, field ? field + "." + key : key, record, errors, context);\n\t',
                        "sanitizedKey"
                      )
                    ),
                    i.push("sanitizedValue = value = record[key];"),
                    (r = this.getRuleFromSchema(s)),
                    i.push(
                      this.compileRule(
                        r,
                        n,
                        e + "[key]",
                        "\n\t\tsanitizedValue = " +
                          (n.async ? "await " : "") +
                          'context.fn[%%INDEX%%](value, field ? field + "." + key : key, record, errors, context);\n\t',
                        "sanitizedValue"
                      )
                    ),
                    i.push("result[sanitizedKey] = sanitizedValue;"),
                    i.push("\n\t\t}\n\t"),
                    i.push("return result;"),
                    { source: i.join("\n") }
                  );
                }
                function c(t, e, n) {
                  e = t.schema;
                  var s = t.messages;
                  t = t.index;
                  var i = [];
                  return (
                    n.customs[t]
                      ? (n.customs[t].schema = e)
                      : (n.customs[t] = { schema: e }),
                    i.push(
                      "\n\t\tconst ObjectID = context.customs[" +
                        t +
                        "].schema.ObjectID;\n\t\tif (!ObjectID.isValid(value)) {\n\t\t\t" +
                        this.makeError({
                          type: "objectID",
                          actual: "value",
                          messages: s,
                        }) +
                        "\n\t\t\treturn;\n\t\t}\n\t"
                    ),
                    !0 === e.convert
                      ? i.push("return new ObjectID(value)")
                      : "hexString" === e.convert
                      ? i.push("return value.toString()")
                      : i.push("return value"),
                    { source: i.join("\n") }
                  );
                }
                function u(t, e, n) {
                  var s = t.schema;
                  t = t.messages;
                  var i = [];
                  i.push(
                    '\n\t\tif (typeof value !== "object" || value === null || Array.isArray(value)) {\n\t\t\t' +
                      this.makeError({
                        type: "object",
                        actual: "value",
                        messages: t,
                      }) +
                      "\n\t\t\treturn value;\n\t\t}\n\t"
                  );
                  var r = s.properties || s.props;
                  if (r) {
                    i.push("var parentObj = value;"),
                      i.push("var parentField = field;");
                    for (var o = Object.keys(r), a = 0; a < o.length; a++) {
                      var l = o[a],
                        c = S(l),
                        u = j.test(c) ? "." + c : "['" + c + "']",
                        p = "parentObj" + u,
                        h = (e ? e + "." : "") + l,
                        d = r[l].label;
                      (d = d ? "'" + S(d) + "'" : void 0),
                        i.push("\n// Field: " + S(h)),
                        i.push(
                          'field = parentField ? parentField + "' +
                            u +
                            '" : "' +
                            c +
                            '";'
                        ),
                        i.push("value = " + p + ";"),
                        i.push("label = " + d),
                        (l = this.getRuleFromSchema(r[l])),
                        i.push(
                          this.compileRule(
                            l,
                            n,
                            h,
                            "\n\t\t\t\t" +
                              p +
                              " = " +
                              (n.async ? "await " : "") +
                              "context.fn[%%INDEX%%](value, field, parentObj, errors, context, label);\n\t\t\t",
                            p
                          )
                        ),
                        !0 === this.opts.haltOnFirstError &&
                          i.push("if (errors.length) return parentObj;");
                    }
                    s.strict &&
                      ((e = Object.keys(r)),
                      i.push(
                        "\n\t\t\t\tfield = parentField;\n\t\t\t\tvar invalidProps = [];\n\t\t\t\tvar props = Object.keys(parentObj);\n\n\t\t\t\tfor (let i = 0; i < props.length; i++) {\n\t\t\t\t\tif (" +
                          JSON.stringify(e) +
                          ".indexOf(props[i]) === -1) {\n\t\t\t\t\t\tinvalidProps.push(props[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (invalidProps.length) {\n\t\t\t"
                      ),
                      "remove" === s.strict
                        ? (i.push(
                            "\n\t\t\t\t\tif (errors.length === 0) {\n\t\t\t\t"
                          ),
                          i.push(
                            "\n\t\t\t\t\t\tinvalidProps.forEach(function(field) {\n\t\t\t\t\t\t\tdelete parentObj[field];\n\t\t\t\t\t\t});\n\t\t\t\t"
                          ),
                          i.push("\n\t\t\t\t\t}\n\t\t\t\t"))
                        : i.push(
                            "\n\t\t\t\t\t" +
                              this.makeError({
                                type: "objectStrict",
                                expected: '"' + e.join(", ") + '"',
                                actual: "invalidProps.join(', ')",
                                messages: t,
                              }) +
                              "\n\t\t\t\t"
                          ),
                      i.push("\n\t\t\t\t}\n\t\t\t"));
                  }
                  return (
                    (null == s.minProps && null == s.maxProps) ||
                      (s.strict
                        ? i.push(
                            "\n\t\t\t\tprops = Object.keys(" +
                              (r ? "parentObj" : "value") +
                              ");\n\t\t\t"
                          )
                        : i.push(
                            "\n\t\t\t\tvar props = Object.keys(" +
                              (r ? "parentObj" : "value") +
                              ");\n\t\t\t\t" +
                              (r ? "field = parentField;" : "") +
                              "\n\t\t\t"
                          )),
                    null != s.minProps &&
                      i.push(
                        "\n\t\t\tif (props.length < " +
                          s.minProps +
                          ") {\n\t\t\t\t" +
                          this.makeError({
                            type: "objectMinProps",
                            expected: s.minProps,
                            actual: "props.length",
                            messages: t,
                          }) +
                          "\n\t\t\t}\n\t\t"
                      ),
                    null != s.maxProps &&
                      i.push(
                        "\n\t\t\tif (props.length > " +
                          s.maxProps +
                          ") {\n\t\t\t\t" +
                          this.makeError({
                            type: "objectMaxProps",
                            expected: s.maxProps,
                            actual: "props.length",
                            messages: t,
                          }) +
                          "\n\t\t\t}\n\t\t"
                      ),
                    r
                      ? i.push("\n\t\t\treturn parentObj;\n\t\t")
                      : i.push("\n\t\t\treturn value;\n\t\t"),
                    { source: i.join("\n") }
                  );
                }
                function p(t) {
                  var e = t.schema;
                  t = t.messages;
                  var n = [];
                  n.push("\n\t\tvar origValue = value;\n\t");
                  var s = !1;
                  return (
                    !0 === e.convert &&
                      ((s = !0),
                      n.push(
                        '\n\t\t\tif (typeof value !== "number") {\n\t\t\t\tvalue = Number(value);\n\t\t\t}\n\t\t'
                      )),
                    n.push(
                      '\n\t\tif (typeof value !== "number" || isNaN(value) || !isFinite(value)) {\n\t\t\t' +
                        this.makeError({
                          type: "number",
                          actual: "origValue",
                          messages: t,
                        }) +
                        "\n\t\t\treturn value;\n\t\t}\n\t"
                    ),
                    null != e.min &&
                      n.push(
                        "\n\t\t\tif (value < " +
                          e.min +
                          ") {\n\t\t\t\t" +
                          this.makeError({
                            type: "numberMin",
                            expected: e.min,
                            actual: "origValue",
                            messages: t,
                          }) +
                          "\n\t\t\t}\n\t\t"
                      ),
                    null != e.max &&
                      n.push(
                        "\n\t\t\tif (value > " +
                          e.max +
                          ") {\n\t\t\t\t" +
                          this.makeError({
                            type: "numberMax",
                            expected: e.max,
                            actual: "origValue",
                            messages: t,
                          }) +
                          "\n\t\t\t}\n\t\t"
                      ),
                    null != e.equal &&
                      n.push(
                        "\n\t\t\tif (value !== " +
                          e.equal +
                          ") {\n\t\t\t\t" +
                          this.makeError({
                            type: "numberEqual",
                            expected: e.equal,
                            actual: "origValue",
                            messages: t,
                          }) +
                          "\n\t\t\t}\n\t\t"
                      ),
                    null != e.notEqual &&
                      n.push(
                        "\n\t\t\tif (value === " +
                          e.notEqual +
                          ") {\n\t\t\t\t" +
                          this.makeError({
                            type: "numberNotEqual",
                            expected: e.notEqual,
                            actual: "origValue",
                            messages: t,
                          }) +
                          "\n\t\t\t}\n\t\t"
                      ),
                    !0 === e.integer &&
                      n.push(
                        "\n\t\t\tif (value % 1 !== 0) {\n\t\t\t\t" +
                          this.makeError({
                            type: "numberInteger",
                            actual: "origValue",
                            messages: t,
                          }) +
                          "\n\t\t\t}\n\t\t"
                      ),
                    !0 === e.positive &&
                      n.push(
                        "\n\t\t\tif (value <= 0) {\n\t\t\t\t" +
                          this.makeError({
                            type: "numberPositive",
                            actual: "origValue",
                            messages: t,
                          }) +
                          "\n\t\t\t}\n\t\t"
                      ),
                    !0 === e.negative &&
                      n.push(
                        "\n\t\t\tif (value >= 0) {\n\t\t\t\t" +
                          this.makeError({
                            type: "numberNegative",
                            actual: "origValue",
                            messages: t,
                          }) +
                          "\n\t\t\t}\n\t\t"
                      ),
                    n.push("\n\t\treturn value;\n\t"),
                    { sanitized: s, source: n.join("\n") }
                  );
                }
                function h(t, e, n) {
                  var s = t.schema;
                  t.messages,
                    (t = []).push(
                      "\n\t\tvar hasValid = false;\n\t\tvar newVal = value;\n\t\tvar checkErrors = [];\n\t\tvar errorsSize = errors.length;\n\t"
                    );
                  for (var i = 0; i < s.rules.length; i++) {
                    t.push(
                      "\n\t\t\tif (!hasValid) {\n\t\t\t\tvar _errors = [];\n\t\t"
                    );
                    var r = this.getRuleFromSchema(s.rules[i]);
                    t.push(
                      this.compileRule(
                        r,
                        n,
                        e,
                        "var tmpVal = " +
                          (n.async ? "await " : "") +
                          "context.fn[%%INDEX%%](value, field, parent, _errors, context);",
                        "tmpVal"
                      )
                    ),
                      t.push(
                        "\n\t\t\t\tif (errors.length == errorsSize && _errors.length == 0) {\n\t\t\t\t\thasValid = true;\n\t\t\t\t\tnewVal = tmpVal;\n\t\t\t\t} else {\n\t\t\t\t\tArray.prototype.push.apply(checkErrors, [].concat(_errors, errors.splice(errorsSize)));\n\t\t\t\t}\n\t\t\t}\n\t\t"
                      );
                  }
                  return (
                    t.push(
                      "\n\t\tif (!hasValid) {\n\t\t\tArray.prototype.push.apply(errors, checkErrors);\n\t\t}\n\n\t\treturn newVal;\n\t"
                    ),
                    { source: t.join("\n") }
                  );
                }
                function d(t) {
                  return (
                    t.schema,
                    {
                      source:
                        '\n\t\t\tif (typeof value !== "function")\n\t\t\t\t' +
                        this.makeError({
                          type: "function",
                          actual: "value",
                          messages: t.messages,
                        }) +
                        "\n\n\t\t\treturn value;\n\t\t",
                    }
                  );
                }
                function m(t) {
                  var e = t.schema;
                  t = t.messages;
                  var n = [];
                  return (
                    n.push(
                      "\n\t\tif (value !== null && value !== undefined) {\n\t"
                    ),
                    e.remove
                      ? n.push("\n\t\t\treturn undefined;\n\t\t")
                      : n.push(
                          "\n\t\t\t" +
                            this.makeError({
                              type: "forbidden",
                              actual: "value",
                              messages: t,
                            }) +
                            "\n\t\t"
                        ),
                    n.push("\n\t\t}\n\n\t\treturn value;\n\t"),
                    { source: n.join("\n") }
                  );
                }
                function f(t) {
                  var e = t.schema;
                  t = t.messages;
                  var n = [];
                  return (
                    e.field
                      ? (e.strict
                          ? n.push(
                              '\n\t\t\t\tif (value !== parent["' +
                                e.field +
                                '"])\n\t\t\t'
                            )
                          : n.push(
                              '\n\t\t\t\tif (value != parent["' +
                                e.field +
                                '"])\n\t\t\t'
                            ),
                        n.push(
                          "\n\t\t\t\t" +
                            this.makeError({
                              type: "equalField",
                              actual: "value",
                              expected: JSON.stringify(e.field),
                              messages: t,
                            }) +
                            "\n\t\t"
                        ))
                      : (e.strict
                          ? n.push(
                              "\n\t\t\t\tif (value !== " +
                                JSON.stringify(e.value) +
                                ")\n\t\t\t"
                            )
                          : n.push(
                              "\n\t\t\t\tif (value != " +
                                JSON.stringify(e.value) +
                                ")\n\t\t\t"
                            ),
                        n.push(
                          "\n\t\t\t\t" +
                            this.makeError({
                              type: "equalValue",
                              actual: "value",
                              expected: JSON.stringify(e.value),
                              messages: t,
                            }) +
                            "\n\t\t"
                        )),
                    n.push("\n\t\treturn value;\n\t"),
                    { source: n.join("\n") }
                  );
                }
                function g(t) {
                  var e = t.schema;
                  return (
                    (t = t.messages),
                    {
                      source:
                        "\n\t\t\tif (" +
                        JSON.stringify(e.values || []) +
                        ".indexOf(value) === -1)\n\t\t\t\t" +
                        this.makeError({
                          type: "enumValue",
                          expected: '"' + e.values.join(", ") + '"',
                          actual: "value",
                          messages: t,
                        }) +
                        "\n\t\t\t\n\t\t\treturn value;\n\t\t",
                    }
                  );
                }
                function y(t) {
                  var e = t.schema;
                  t = t.messages;
                  var n = [],
                    s = "precise" == e.mode ? B : L,
                    i = !1;
                  return (
                    n.push(
                      '\n\t\tif (typeof value !== "string") {\n\t\t\t' +
                        this.makeError({
                          type: "string",
                          actual: "value",
                          messages: t,
                        }) +
                        "\n\t\t\treturn value;\n\t\t}\n\t"
                    ),
                    e.empty
                      ? n.push(
                          "\n\t\t\tif (value.length === 0) return value;\n\t\t"
                        )
                      : n.push(
                          "\n\t\t\tif (value.length === 0) {\n\t\t\t\t" +
                            this.makeError({
                              type: "emailEmpty",
                              actual: "value",
                              messages: t,
                            }) +
                            "\n\t\t\t\treturn value;\n\t\t\t}\n\t\t"
                        ),
                    e.normalize &&
                      ((i = !0),
                      n.push(
                        "\n\t\t\tvalue = value.trim().toLowerCase();\n\t\t"
                      )),
                    null != e.min &&
                      n.push(
                        "\n\t\t\tif (value.length < " +
                          e.min +
                          ") {\n\t\t\t\t" +
                          this.makeError({
                            type: "emailMin",
                            expected: e.min,
                            actual: "value.length",
                            messages: t,
                          }) +
                          "\n\t\t\t}\n\t\t"
                      ),
                    null != e.max &&
                      n.push(
                        "\n\t\t\tif (value.length > " +
                          e.max +
                          ") {\n\t\t\t\t" +
                          this.makeError({
                            type: "emailMax",
                            expected: e.max,
                            actual: "value.length",
                            messages: t,
                          }) +
                          "\n\t\t\t}\n\t\t"
                      ),
                    n.push(
                      "\n\t\tif (!" +
                        s.toString() +
                        ".test(value)) {\n\t\t\t" +
                        this.makeError({
                          type: "email",
                          actual: "value",
                          messages: t,
                        }) +
                        "\n\t\t}\n\n\t\treturn value;\n\t"
                    ),
                    { sanitized: i, source: n.join("\n") }
                  );
                }
                function v(t) {
                  var e = t.schema;
                  t = t.messages;
                  var n = [],
                    s = !1;
                  return (
                    n.push("\n\t\tvar origValue = value;\n\t"),
                    !0 === e.convert &&
                      ((s = !0),
                      n.push(
                        "\n\t\t\tif (!(value instanceof Date)) {\n\t\t\t\tvalue = new Date(value.length && !isNaN(+value) ? +value : value);\n\t\t\t}\n\t\t"
                      )),
                    n.push(
                      "\n\t\tif (!(value instanceof Date) || isNaN(value.getTime()))\n\t\t\t" +
                        this.makeError({
                          type: "date",
                          actual: "origValue",
                          messages: t,
                        }) +
                        "\n\n\t\treturn value;\n\t"
                    ),
                    { sanitized: s, source: n.join("\n") }
                  );
                }
                function b(t) {
                  var e = t.schema;
                  t = t.messages;
                  var n = e.currencySymbol || null,
                    s = e.thousandSeparator || ",",
                    i = e.decimalSeparator || ".",
                    r = e.customRegex;
                  return (
                    (e = !e.symbolOptional),
                    (e =
                      "(?=.*\\d)^(-?~1|~1-?)(([0-9]\\d{0,2}(~2\\d{3})*)|0)?(\\~3\\d{1,2})?$"
                        .replace(/~1/g, n ? "\\" + n + (e ? "" : "?") : "")
                        .replace("~2", s)
                        .replace("~3", i)),
                    (n = []).push(
                      "\n\t\tif (!value.match(" +
                        (r || new RegExp(e)) +
                        ")) {\n\t\t\t" +
                        this.makeError({
                          type: "currency",
                          actual: "value",
                          messages: t,
                        }) +
                        "\n\t\t\treturn value;\n\t\t}\n\n\t\treturn value;\n\t"
                    ),
                    { source: n.join("\n") }
                  );
                }
                function x(t, e, n) {
                  var s = [];
                  return (
                    s.push(
                      "\n\t\t" +
                        this.makeCustomValidator({
                          fnName: "check",
                          path: e,
                          schema: t.schema,
                          messages: t.messages,
                          context: n,
                          ruleIndex: t.index,
                        }) +
                        "\n\t\treturn value;\n\t"
                    ),
                    { source: s.join("\n") }
                  );
                }
                function w(t, e, n) {
                  e = t.schema;
                  var s = t.messages;
                  t = t.index;
                  var i = [],
                    r = e.instanceOf.name ? e.instanceOf.name : "<UnknowClass>";
                  return (
                    n.customs[t]
                      ? (n.customs[t].schema = e)
                      : (n.customs[t] = { schema: e }),
                    i.push(
                      "\n\t\tif (!(value instanceof context.customs[" +
                        t +
                        "].schema.instanceOf))\n\t\t\t" +
                        this.makeError({
                          type: "classInstanceOf",
                          actual: "value",
                          expected: "'" + r + "'",
                          messages: s,
                        }) +
                        "\n\t"
                    ),
                    i.push("\n\t\treturn value;\n\t"),
                    { source: i.join("\n") }
                  );
                }
                function C(t) {
                  var e = t.schema;
                  t = t.messages;
                  var n = [],
                    s = !1;
                  return (
                    n.push("\n\t\tvar origValue = value;\n\t"),
                    !0 === e.convert &&
                      ((s = !0),
                      n.push(
                        '\n\t\t\tif (typeof value !== "boolean") {\n\t\t\t\tif (\n\t\t\t\tvalue === 1\n\t\t\t\t|| value === "true"\n\t\t\t\t|| value === "1"\n\t\t\t\t|| value === "on"\n\t\t\t\t) {\n\t\t\t\t\tvalue = true;\n\t\t\t\t} else if (\n\t\t\t\tvalue === 0\n\t\t\t\t|| value === "false"\n\t\t\t\t|| value === "0"\n\t\t\t\t|| value === "off"\n\t\t\t\t) {\n\t\t\t\t\tvalue = false;\n\t\t\t\t}\n\t\t\t}\n\t\t'
                      )),
                    n.push(
                      '\n\t\tif (typeof value !== "boolean") {\n\t\t\t' +
                        this.makeError({
                          type: "boolean",
                          actual: "origValue",
                          messages: t,
                        }) +
                        "\n\t\t}\n\t\t\n\t\treturn value;\n\t"
                    ),
                    { sanitized: s, source: n.join("\n") }
                  );
                }
                function I(t, e, n) {
                  var s = t.schema,
                    i = t.messages;
                  t = [];
                  var r = !1;
                  if (
                    (!0 === s.convert &&
                      ((r = !0),
                      t.push(
                        "\n\t\t\tif (!Array.isArray(value) && value != null) {\n\t\t\t\tvalue = [value];\n\t\t\t}\n\t\t"
                      )),
                    t.push(
                      "\n\t\tif (!Array.isArray(value)) {\n\t\t\t" +
                        this.makeError({
                          type: "array",
                          actual: "value",
                          messages: i,
                        }) +
                        "\n\t\t\treturn value;\n\t\t}\n\n\t\tvar len = value.length;\n\t"
                    ),
                    !1 === s.empty &&
                      t.push(
                        "\n\t\t\tif (len === 0) {\n\t\t\t\t" +
                          this.makeError({
                            type: "arrayEmpty",
                            actual: "value",
                            messages: i,
                          }) +
                          "\n\t\t\t}\n\t\t"
                      ),
                    null != s.min &&
                      t.push(
                        "\n\t\t\tif (len < " +
                          s.min +
                          ") {\n\t\t\t\t" +
                          this.makeError({
                            type: "arrayMin",
                            expected: s.min,
                            actual: "len",
                            messages: i,
                          }) +
                          "\n\t\t\t}\n\t\t"
                      ),
                    null != s.max &&
                      t.push(
                        "\n\t\t\tif (len > " +
                          s.max +
                          ") {\n\t\t\t\t" +
                          this.makeError({
                            type: "arrayMax",
                            expected: s.max,
                            actual: "len",
                            messages: i,
                          }) +
                          "\n\t\t\t}\n\t\t"
                      ),
                    null != s.length &&
                      t.push(
                        "\n\t\t\tif (len !== " +
                          s.length +
                          ") {\n\t\t\t\t" +
                          this.makeError({
                            type: "arrayLength",
                            expected: s.length,
                            actual: "len",
                            messages: i,
                          }) +
                          "\n\t\t\t}\n\t\t"
                      ),
                    null != s.contains &&
                      t.push(
                        "\n\t\t\tif (value.indexOf(" +
                          JSON.stringify(s.contains) +
                          ") === -1) {\n\t\t\t\t" +
                          this.makeError({
                            type: "arrayContains",
                            expected: JSON.stringify(s.contains),
                            actual: "value",
                            messages: i,
                          }) +
                          "\n\t\t\t}\n\t\t"
                      ),
                    !0 === s.unique &&
                      t.push(
                        "\n\t\t\tif(len > (new Set(value)).size) {\n\t\t\t\t" +
                          this.makeError({
                            type: "arrayUnique",
                            expected:
                              "Array.from(new Set(value.filter((item, index) => value.indexOf(item) !== index)))",
                            actual: "value",
                            messages: i,
                          }) +
                          "\n\t\t\t}\n\t\t"
                      ),
                    null != s.enum)
                  ) {
                    var o = JSON.stringify(s.enum);
                    t.push(
                      "\n\t\t\tfor (var i = 0; i < value.length; i++) {\n\t\t\t\tif (" +
                        o +
                        ".indexOf(value[i]) === -1) {\n\t\t\t\t\t" +
                        this.makeError({
                          type: "arrayEnum",
                          expected: '"' + s.enum.join(", ") + '"',
                          actual: "value[i]",
                          messages: i,
                        }) +
                        "\n\t\t\t\t}\n\t\t\t}\n\t\t"
                    );
                  }
                  return (
                    null != s.items
                      ? (t.push(
                          "\n\t\t\tvar arr = value;\n\t\t\tvar parentField = field;\n\t\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\t\tvalue = arr[i];\n\t\t"
                        ),
                        (e += "[]"),
                        (s = this.getRuleFromSchema(s.items)),
                        t.push(
                          this.compileRule(
                            s,
                            n,
                            e,
                            "arr[i] = " +
                              (n.async ? "await " : "") +
                              'context.fn[%%INDEX%%](arr[i], (parentField ? parentField : "") + "[" + i + "]", parent, errors, context)',
                            "arr[i]"
                          )
                        ),
                        t.push("\n\t\t\t}\n\t\t"),
                        t.push("\n\t\treturn arr;\n\t"))
                      : t.push("\n\t\treturn value;\n\t"),
                    { sanitized: r, source: t.join("\n") }
                  );
                }
                function P() {
                  var t = [];
                  return (
                    t.push("\n\t\treturn value;\n\t"), { source: t.join("\n") }
                  );
                }
                function E(t, e, n) {
                  return t.replace(
                    e,
                    null == n
                      ? ""
                      : "function" == typeof n.toString
                      ? n
                      : typeof n
                  );
                }
                function k(t, e, n) {
                  for (var s in (void 0 === n && (n = {}), e)) {
                    var i = e[s];
                    (i =
                      "object" == typeof i &&
                      !Array.isArray(i) &&
                      null != i &&
                      0 < Object.keys(i).length)
                      ? ((t[s] = t[s] || {}), k(t[s], e[s], n))
                      : (!0 === n.skipIfExist && void 0 !== t[s]) ||
                        (t[s] = e[s]);
                  }
                  return t;
                }
                function S(t) {
                  return t.replace(V, function (t) {
                    switch (t) {
                      case '"':
                      case "'":
                      case "\\":
                        return "\\" + t;
                      case "\n":
                        return "\\n";
                      case "\r":
                        return "\\r";
                      case "\u2028":
                        return "\\u2028";
                      case "\u2029":
                        return "\\u2029";
                    }
                  });
                }
                function O() {
                  throw Error(
                    "Dynamic requires are not currently supported by rollup-plugin-commonjs"
                  );
                }
                var M = {
                  required: "The '{field}' field is required.",
                  string: "The '{field}' field must be a string.",
                  stringEmpty: "The '{field}' field must not be empty.",
                  stringMin:
                    "The '{field}' field length must be greater than or equal to {expected} characters long.",
                  stringMax:
                    "The '{field}' field length must be less than or equal to {expected} characters long.",
                  stringLength:
                    "The '{field}' field length must be {expected} characters long.",
                  stringPattern:
                    "The '{field}' field fails to match the required pattern.",
                  stringContains:
                    "The '{field}' field must contain the '{expected}' text.",
                  stringEnum:
                    "The '{field}' field does not match any of the allowed values.",
                  stringNumeric:
                    "The '{field}' field must be a numeric string.",
                  stringAlpha:
                    "The '{field}' field must be an alphabetic string.",
                  stringAlphanum:
                    "The '{field}' field must be an alphanumeric string.",
                  stringAlphadash:
                    "The '{field}' field must be an alphadash string.",
                  stringHex: "The '{field}' field must be a hex string.",
                  stringSingleLine:
                    "The '{field}' field must be a single line string.",
                  stringBase64: "The '{field}' field must be a base64 string.",
                  number: "The '{field}' field must be a number.",
                  numberMin:
                    "The '{field}' field must be greater than or equal to {expected}.",
                  numberMax:
                    "The '{field}' field must be less than or equal to {expected}.",
                  numberEqual:
                    "The '{field}' field must be equal to {expected}.",
                  numberNotEqual:
                    "The '{field}' field can't be equal to {expected}.",
                  numberInteger: "The '{field}' field must be an integer.",
                  numberPositive:
                    "The '{field}' field must be a positive number.",
                  numberNegative:
                    "The '{field}' field must be a negative number.",
                  array: "The '{field}' field must be an array.",
                  arrayEmpty: "The '{field}' field must not be an empty array.",
                  arrayMin:
                    "The '{field}' field must contain at least {expected} items.",
                  arrayMax:
                    "The '{field}' field must contain less than or equal to {expected} items.",
                  arrayLength:
                    "The '{field}' field must contain {expected} items.",
                  arrayContains:
                    "The '{field}' field must contain the '{expected}' item.",
                  arrayUnique:
                    "The '{actual}' value in '{field}' field does not unique the '{expected}' values.",
                  arrayEnum:
                    "The '{actual}' value in '{field}' field does not match any of the '{expected}' values.",
                  tuple: "The '{field}' field must be an array.",
                  tupleEmpty: "The '{field}' field must not be an empty array.",
                  tupleLength:
                    "The '{field}' field must contain {expected} items.",
                  boolean: "The '{field}' field must be a boolean.",
                  currency: "The '{field}' must be a valid currency format",
                  date: "The '{field}' field must be a Date.",
                  dateMin:
                    "The '{field}' field must be greater than or equal to {expected}.",
                  dateMax:
                    "The '{field}' field must be less than or equal to {expected}.",
                  enumValue:
                    "The '{field}' field value '{expected}' does not match any of the allowed values.",
                  equalValue:
                    "The '{field}' field value must be equal to '{expected}'.",
                  equalField:
                    "The '{field}' field value must be equal to '{expected}' field value.",
                  forbidden: "The '{field}' field is forbidden.",
                  function: "The '{field}' field must be a function.",
                  email: "The '{field}' field must be a valid e-mail.",
                  emailEmpty: "The '{field}' field must not be empty.",
                  emailMin:
                    "The '{field}' field length must be greater than or equal to {expected} characters long.",
                  emailMax:
                    "The '{field}' field length must be less than or equal to {expected} characters long.",
                  luhn: "The '{field}' field must be a valid checksum luhn.",
                  mac: "The '{field}' field must be a valid MAC address.",
                  object: "The '{field}' must be an Object.",
                  objectStrict:
                    "The object '{field}' contains forbidden keys: '{actual}'.",
                  objectMinProps:
                    "The object '{field}' must contain at least {expected} properties.",
                  objectMaxProps:
                    "The object '{field}' must contain {expected} properties at most.",
                  url: "The '{field}' field must be a valid URL.",
                  urlEmpty: "The '{field}' field must not be empty.",
                  uuid: "The '{field}' field must be a valid UUID.",
                  uuidVersion:
                    "The '{field}' field must be a valid UUID version provided.",
                  classInstanceOf:
                    "The '{field}' field must be an instance of the '{expected}' class.",
                  objectID: "The '{field}' field must be an valid ObjectID",
                  record: "The '{field}' must be an Object.",
                };
                M.required,
                  M.string,
                  M.stringEmpty,
                  M.stringMin,
                  M.stringMax,
                  M.stringLength,
                  M.stringPattern,
                  M.stringContains,
                  M.stringEnum,
                  M.stringNumeric,
                  M.stringAlpha,
                  M.stringAlphanum,
                  M.stringAlphadash,
                  M.stringHex,
                  M.stringSingleLine,
                  M.stringBase64,
                  M.number,
                  M.numberMin,
                  M.numberMax,
                  M.numberEqual,
                  M.numberNotEqual,
                  M.numberInteger,
                  M.numberPositive,
                  M.numberNegative,
                  M.array,
                  M.arrayEmpty,
                  M.arrayMin,
                  M.arrayMax,
                  M.arrayLength,
                  M.arrayContains,
                  M.arrayUnique,
                  M.arrayEnum,
                  M.tuple,
                  M.tupleEmpty,
                  M.tupleLength,
                  M.currency,
                  M.date,
                  M.dateMin,
                  M.dateMax,
                  M.enumValue,
                  M.equalValue,
                  M.equalField,
                  M.forbidden,
                  M.email,
                  M.emailEmpty,
                  M.emailMin,
                  M.emailMax,
                  M.luhn,
                  M.mac,
                  M.object,
                  M.objectStrict,
                  M.objectMinProps,
                  M.objectMaxProps,
                  M.url,
                  M.urlEmpty,
                  M.uuid,
                  M.uuidVersion,
                  M.classInstanceOf,
                  M.objectID,
                  M.record;
                var A,
                  _,
                  T,
                  D,
                  B =
                    /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
                  L = /^\S+@\S+\.\S+$/,
                  j = /^[_$a-zA-Z][_$a-zA-Z0-9]*$/,
                  V = /["'\\\n\r\u2028\u2029]/g,
                  N = /^-?[0-9]\d*(\.\d+)?$/,
                  $ = /^[a-zA-Z]+$/,
                  R = /^[a-zA-Z0-9]+$/,
                  F = /^[a-zA-Z0-9_-]+$/,
                  z = /^[0-9a-fA-F]+$/,
                  X =
                    /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+/]{3}=)?$/,
                  H = /^https?:\/\/\S+/,
                  Y =
                    /^([0-9a-f]{8}-[0-9a-f]{4}-[1-6][0-9a-f]{3}-[0-9a-f]{4}-[0-9a-f]{12}|[0]{8}-[0]{4}-[0]{4}-[0]{4}-[0]{12})$/i,
                  U =
                    /^((([a-f0-9][a-f0-9]+[-]){5}|([a-f0-9][a-f0-9]+[:]){5})([a-f0-9][a-f0-9])$)|(^([a-f0-9][a-f0-9][a-f0-9][a-f0-9]+[.]){2}([a-f0-9][a-f0-9][a-f0-9][a-f0-9]))$/i;
                try {
                  var W = new Function(
                    "return Object.getPrototypeOf(async function(){}).constructor"
                  )();
                } catch (t) {}
                return (
                  (t.prototype.validate = function (t, e) {
                    return this.compile(e)(t);
                  }),
                  (t.prototype.wrapRequiredCheckSourceCode = function (
                    t,
                    e,
                    n,
                    s
                  ) {
                    var i = [],
                      r = this.opts.considerNullAsAValue;
                    void 0 === r && (r = !1);
                    var o =
                        !0 === t.schema.optional ||
                        "forbidden" === t.schema.type,
                      a = r
                        ? !1 !== t.schema.nullable ||
                          "forbidden" === t.schema.type
                        : !0 === t.schema.optional ||
                          !0 === t.schema.nullable ||
                          "forbidden" === t.schema.type;
                    return (
                      (
                        r
                          ? null != t.schema.default && null != t.schema.default
                          : null != t.schema.default
                      )
                        ? ((o = !1),
                          r
                            ? !1 === t.schema.nullable && (a = !1)
                            : !0 !== t.schema.nullable && (a = !1),
                          "function" == typeof t.schema.default
                            ? (n.customs[t.index] || (n.customs[t.index] = {}),
                              (n.customs[t.index].defaultFn = t.schema.default),
                              (t =
                                "context.customs[" +
                                t.index +
                                "].defaultFn.call(this, context.rules[" +
                                t.index +
                                "].schema, field, parent, context)"))
                            : (t = JSON.stringify(t.schema.default)),
                          (s =
                            "\n\t\t\t\tvalue = " +
                            t +
                            ";\n\t\t\t\t" +
                            s +
                            " = value;\n\t\t\t"))
                        : (s = this.makeError({
                            type: "required",
                            actual: "value",
                            messages: t.messages,
                          })),
                      i.push(
                        "\n\t\t\tif (value === undefined) { " +
                          (o ? "\n// allow undefined\n" : s) +
                          " }\n\t\t\telse if (value === null) { " +
                          (a ? "\n// allow null\n" : s) +
                          " }\n\t\t\t" +
                          (e ? "else { " + e + " }" : "") +
                          "\n\t\t"
                      ),
                      i.join("\n")
                    );
                  }),
                  (t.prototype.compile = function (t) {
                    function e(t, e) {
                      return (
                        (s.data = t),
                        e && e.meta && (s.meta = e.meta),
                        r.call(n, t, s)
                      );
                    }
                    if (null === t || "object" != typeof t)
                      throw Error("Invalid schema.");
                    var n = this,
                      s = {
                        index: 0,
                        async: !0 === t.$$async,
                        rules: [],
                        fn: [],
                        customs: {},
                        utils: { replace: E },
                      };
                    if ((this.cache.clear(), delete t.$$async, s.async && !W))
                      throw Error("Asynchronous mode is not supported.");
                    if (!0 !== t.$$root)
                      if (Array.isArray(t))
                        t = this.getRuleFromSchema(t).schema;
                      else {
                        var i = Object.assign({}, t);
                        (t = {
                          type: "object",
                          strict: i.$$strict,
                          properties: i,
                        }),
                          delete i.$$strict;
                      }
                    (i = [
                      "var errors = [];",
                      "var field;",
                      "var parent = null;",
                      "var label = " +
                        (t.label ? '"' + t.label + '"' : "null") +
                        ";",
                    ]),
                      (t = this.getRuleFromSchema(t)),
                      i.push(
                        this.compileRule(
                          t,
                          s,
                          null,
                          (s.async ? "await " : "") +
                            "context.fn[%%INDEX%%](value, field, null, errors, context, label);",
                          "value"
                        )
                      ),
                      i.push("if (errors.length) {"),
                      i.push(
                        "\n\t\t\treturn errors.map(err => {\n\t\t\t\tif (err.message) {\n\t\t\t\t\terr.message = context.utils.replace(err.message, /\\{field\\}/g, err.label || err.field);\n\t\t\t\t\terr.message = context.utils.replace(err.message, /\\{expected\\}/g, err.expected);\n\t\t\t\t\terr.message = context.utils.replace(err.message, /\\{actual\\}/g, err.actual);\n\t\t\t\t}\n\t\t\t\tif(!err.label) delete err.label\n\t\t\t\treturn err;\n\t\t\t});\n\t\t"
                      ),
                      i.push("}"),
                      i.push("return true;"),
                      (t = i.join("\n"));
                    var r = new (s.async ? W : Function)("value", "context", t);
                    return (
                      this.opts.debug &&
                        console.log(
                          this._formatter(
                            "// Main check function\n" + r.toString()
                          )
                        ),
                      this.cache.clear(),
                      (e.async = s.async),
                      e
                    );
                  }),
                  (t.prototype.compileRule = function (t, e, n, s, i) {
                    var r = [],
                      o = this.cache.get(t.schema);
                    return (
                      o
                        ? (((t = o).cycle = !0),
                          (t.cycleStack = []),
                          r.push(
                            this.wrapRequiredCheckSourceCode(
                              t,
                              "\n\t\t\t\tvar rule = context.rules[" +
                                t.index +
                                "];\n\t\t\t\tif (rule.cycleStack.indexOf(value) === -1) {\n\t\t\t\t\trule.cycleStack.push(value);\n\t\t\t\t\t" +
                                s.replace(/%%INDEX%%/g, t.index) +
                                "\n\t\t\t\t\trule.cycleStack.pop(value);\n\t\t\t\t}\n\t\t\t",
                              e,
                              i
                            )
                          ))
                        : (this.cache.set(t.schema, t),
                          (t.index = e.index),
                          (e.rules[e.index] = t),
                          (o = null != n ? n : "$$root"),
                          e.index++,
                          ((n = t.ruleFunction.call(this, t, n, e)).source =
                            n.source.replace(/%%INDEX%%/g, t.index)),
                          (n = new (e.async ? W : Function)(
                            "value",
                            "field",
                            "parent",
                            "errors",
                            "context",
                            "label",
                            n.source
                          )),
                          (e.fn[t.index] = n.bind(this)),
                          r.push(
                            this.wrapRequiredCheckSourceCode(
                              t,
                              s.replace(/%%INDEX%%/g, t.index),
                              e,
                              i
                            )
                          ),
                          r.push(
                            this.makeCustomValidator({
                              vName: i,
                              path: o,
                              schema: t.schema,
                              context: e,
                              messages: t.messages,
                              ruleIndex: t.index,
                            })
                          ),
                          this.opts.debug &&
                            console.log(
                              this._formatter(
                                "// Context.fn[" +
                                  t.index +
                                  "]\n" +
                                  n.toString()
                              )
                            )),
                      r.join("\n")
                    );
                  }),
                  (t.prototype.getRuleFromSchema = function (t) {
                    t = this.resolveType(t);
                    var e = this.aliases[t.type];
                    if (
                      (e && (delete t.type, (t = k(t, e, { skipIfExist: !0 }))),
                      !(e = this.rules[t.type]))
                    )
                      throw Error(
                        "Invalid '" + t.type + "' type in validator schema."
                      );
                    return {
                      messages: Object.assign({}, this.messages, t.messages),
                      schema: k(t, this.defaults[t.type], { skipIfExist: !0 }),
                      ruleFunction: e,
                    };
                  }),
                  (t.prototype.parseShortHand = function (t) {
                    var e = (t = t.split("|").map(function (t) {
                        return t.trim();
                      }))[0],
                      n = e.endsWith("[]")
                        ? this.getRuleFromSchema({
                            type: "array",
                            items: e.slice(0, -2),
                          }).schema
                        : { type: t[0] };
                    return (
                      t.slice(1).map(function (t) {
                        var e = t.indexOf(":");
                        if (-1 !== e) {
                          var s = t.substr(0, e).trim();
                          "true" === (t = t.substr(e + 1).trim()) ||
                          "false" === t
                            ? (t = "true" === t)
                            : Number.isNaN(Number(t)) || (t = Number(t)),
                            (n[s] = t);
                        } else t.startsWith("no-") ? (n[t.slice(3)] = !1) : (n[t] = !0);
                      }),
                      n
                    );
                  }),
                  (t.prototype.makeError = function (t) {
                    var e = t.type,
                      n = t.field,
                      s = t.expected,
                      i = t.actual,
                      r = {
                        type: '"' + e + '"',
                        message: '"' + t.messages[e] + '"',
                      };
                    return (
                      (r.field = n ? '"' + n + '"' : "field"),
                      null != s && (r.expected = s),
                      null != i && (r.actual = i),
                      (r.label = "label"),
                      "errors.push({ " +
                        Object.keys(r)
                          .map(function (t) {
                            return t + ": " + r[t];
                          })
                          .join(", ") +
                        " });"
                    );
                  }),
                  (t.prototype.makeCustomValidator = function (t) {
                    var e = t.vName;
                    void 0 === e && (e = "value");
                    var n = t.fnName;
                    void 0 === n && (n = "custom");
                    var s = t.ruleIndex,
                      i = t.path,
                      r = t.schema,
                      o = t.context,
                      a = t.messages;
                    t = "rule" + s;
                    var l = "fnCustomErrors" + s;
                    return "function" == typeof r[n]
                      ? (o.customs[s]
                          ? ((o.customs[s].messages = a),
                            (o.customs[s].schema = r))
                          : (o.customs[s] = { messages: a, schema: r }),
                        this.opts.useNewCustomCheckerFunction
                          ? "\n               \t\tconst " +
                            t +
                            " = context.customs[" +
                            s +
                            "];\n\t\t\t\t\tconst " +
                            l +
                            " = [];\n\t\t\t\t\t" +
                            e +
                            " = " +
                            (o.async ? "await " : "") +
                            t +
                            ".schema." +
                            n +
                            ".call(this, " +
                            e +
                            ", " +
                            l +
                            " , " +
                            t +
                            '.schema, "' +
                            i +
                            '", parent, context);\n\t\t\t\t\tif (Array.isArray(' +
                            l +
                            " )) {\n                  \t\t" +
                            l +
                            " .forEach(err => errors.push(Object.assign({ message: " +
                            t +
                            ".messages[err.type], field }, err)));\n\t\t\t\t\t}\n\t\t\t\t"
                          : "\n\t\t\t\tconst " +
                            t +
                            " = context.customs[" +
                            s +
                            "];\n\t\t\t\tconst " +
                            (r = "res_" + t) +
                            " = " +
                            (o.async ? "await " : "") +
                            t +
                            ".schema." +
                            n +
                            ".call(this, " +
                            e +
                            ", " +
                            t +
                            '.schema, "' +
                            i +
                            '", parent, context);\n\t\t\t\tif (Array.isArray(' +
                            r +
                            ")) {\n\t\t\t\t\t" +
                            r +
                            ".forEach(err => errors.push(Object.assign({ message: " +
                            t +
                            ".messages[err.type], field }, err)));\n\t\t\t\t}\n\t\t")
                      : "";
                  }),
                  (t.prototype.add = function (t, e) {
                    this.rules[t] = e;
                  }),
                  (t.prototype.addMessage = function (t, e) {
                    this.messages[t] = e;
                  }),
                  (t.prototype.alias = function (t, e) {
                    if (this.rules[t])
                      throw Error("Alias name must not be a rule name");
                    this.aliases[t] = e;
                  }),
                  (t.prototype.plugin = function (t) {
                    if ("function" != typeof t)
                      throw Error("Plugin fn type must be function");
                    return t(this);
                  }),
                  (t.prototype.resolveType = function (t) {
                    var e = this;
                    if ("string" == typeof t) t = this.parseShortHand(t);
                    else if (Array.isArray(t)) {
                      if (0 === t.length) throw Error("Invalid schema.");
                      (t = { type: "multi", rules: t }).rules
                        .map(function (t) {
                          return e.getRuleFromSchema(t);
                        })
                        .every(function (t) {
                          return !0 === t.schema.optional;
                        }) && (t.optional = !0);
                      var n = !this.opts.considerNullAsAValue;
                      t.rules
                        .map(function (t) {
                          return e.getRuleFromSchema(t);
                        })
                        .every(function (t) {
                          return t.schema.nullable === n;
                        }) && (t.nullable = n);
                    }
                    if (t.$$type) {
                      var s = this.getRuleFromSchema(t.$$type).schema;
                      delete t.$$type;
                      var i,
                        r = Object.assign({}, t);
                      for (i in t) delete t[i];
                      k(t, s, { skipIfExist: !0 }), (t.props = r);
                    }
                    return t;
                  }),
                  (t.prototype.normalize = function (t) {
                    var e = this,
                      n = this.resolveType(t);
                    return (
                      this.aliases[n.type] &&
                        (n = k(n, this.normalize(this.aliases[n.type]), {
                          skipIfExists: !0,
                        })),
                      "multi" ===
                      (n = k(n, this.defaults[n.type], { skipIfExist: !0 }))
                        .type
                        ? ((n.rules = n.rules.map(function (t) {
                            return e.normalize(t);
                          })),
                          (n.optional = n.rules.every(function (t) {
                            return !0 === t.optional;
                          })),
                          n)
                        : "array" === n.type
                        ? ((n.items = this.normalize(n.items)), n)
                        : ("object" === n.type &&
                            n.props &&
                            Object.entries(n.props).forEach(function (t) {
                              return (n.props[t[0]] = e.normalize(t[1]));
                            }),
                          "object" == typeof t &&
                            (t.type
                              ? ((t = this.normalize(t.type)),
                                k(n, t, { skipIfExists: !0 }))
                              : Object.entries(t).forEach(function (t) {
                                  return (n[t[0]] = e.normalize(t[1]));
                                })),
                          n)
                    );
                  }),
                  t
                );
              }
              "object" == typeof t && void 0 !== e
                ? (e.exports = i())
                : "function" == typeof define && define.amd
                ? define(i)
                : ((s =
                    "undefined" != typeof globalThis
                      ? globalThis
                      : s || self).FastestValidator = i());
            },
          }),
          Oi = At({
            "optimize-deps:fastest-validator"(t, e) {
              e.exports = Si();
            },
          })();
        const Mi = new RegExp(/^[-+]?\d+$/),
          Ai = new Oi({
            messages: {
              color:
                "The '{field}' field must be an a valid color! Actual: {actual}",
              measurement:
                "The '{field}' must be a measurement with specs that are not met. You've either provided wrong value/units or an invalid @ expression. Actual: {actual}",
              measurementNotAString:
                "measurement - The provided value of {field} is not a string",
              measurementMin:
                "measurement - The provided value of {field} ({actual}) is smaller than the schema's min",
              measurementMax:
                "measurement - The provided value of {field} ({actual}) is bigger than the schema's max",
              measurementInt:
                "measurement - The provided value of {field} ({actual}) is not an integer",
            },
            useNewCustomCheckerFunction: !0,
          });
        Ai.add("html", function ({ messages: t }, e, n) {
          return {
            source: `\n      if(value === null){\n        ${this.makeError({
              type: "html",
              actual: "value",
              messages: t,
            })}\n      } else {\n        return value;\n      }\n    `,
          };
        }),
          Ai.add("css", function ({ messages: t }, e, n) {
            return {
              source: `\n      if(value === null){\n        ${this.makeError({
                type: "css",
                actual: "value",
                messages: t,
              })}\n      } else {\n        return value;\n      }\n    `,
            };
          }),
          Ai.add("measurement", function ({ schema: t, messages: e }, n, s) {
            const i = new RegExp(
              "^[+-]?(\\d+([.]\\d*)?|[.]\\d+)(" + t.units.join("|") + ")$",
              "gi"
            );
            return {
              source: `\n      const validUnits = ['${t.units.join(
                "','"
              )}'];\n\n      if(typeof value !== 'string' && !(value instanceof String)){\n        ${this.makeError(
                { type: "measurementNotAString", actual: "value", messages: e }
              )}\n        return ;\n      }\n\n      if(!value.match(${i})){\n        ${this.makeError(
                { type: "measurement", actual: "value", messages: e }
              )}\n      } else {\n        var numberPart = value.match(${C})[0];\n        if(${x(
                t,
                "min"
              )}){\n          if(${
                t.min
              } > numberPart){\n            ${this.makeError({
                type: "measurementMin",
                actual: "value",
                messages: e,
              })}\n          }\n        }\n        if(${x(
                t,
                "max"
              )}){\n          if(${
                t.max
              } < numberPart){\n            ${this.makeError({
                type: "measurementMax",
                actual: "value",
                messages: e,
              })}\n          }\n        }\n         if(${x(
                t,
                "integer"
              )}){\n          if(!numberPart.match(${Mi})){\n            ${this.makeError(
                { type: "measurementInt", actual: "value", messages: e }
              )}\n          }\n        }\n      }\n      return value;\n    `,
            };
          }),
          Ai.add("color", function ({ messages: t }, e, n) {
            return {
              source: `\n    if(typeof value !== 'string' && !(value instanceof String)){\n      ${this.makeError(
                { type: "measurement", actual: "value", messages: t }
              )}\n      return ;\n    }\n    var option;\n    function isColor(strColor) {\n      if (!option ) {\n        option = new Option().style;\n      }\n      option.color = strColor;\n      const res = option.color !== '';\n      option.color = '';\n      return res;\n    }\n    if(!isColor(value)){\n      ${this.makeError(
                { type: "color", actual: "value", messages: t }
              )}\n    }\n    return value;\n    `,
            };
          }),
          Ai.alias("amount", { type: "number" });
        const _i = os(),
          Ti = (t, e) => {
            const n = Ai.compile({ [e]: t });
            return function (s, i, r) {
              return (function (t, e, n, s, i, r) {
                const o = function (n) {
                  e.push({ type: s.type, message: n, actual: t });
                };
                if (!y(t)) return o("Not a dynamic value expression"), null;
                const a = function (t) {
                  if (c.includes(s.type))
                    return (
                      j.warning(
                        `${s.type} does not support checkValues method. Returning true without validation`
                      ),
                      !0
                    );
                  let n = !0;
                  for (let s = 0; s < t.length; s++) {
                    const o = r({ [i]: t[s] });
                    !0 !== o && ((n = !1), e.push(...o));
                  }
                  return n;
                };
                for (let e = 0; e < _i.length; e++) {
                  const n = _i[e];
                  if (
                    t.trim().startsWith(`@${n.preface}`) &&
                    n.validation(t, o, a, s)
                  )
                    return t;
                }
                return o("Not a valid dynamic value expression"), null;
              })(s, i, 0, t, e, n);
            };
          };
        var Di = Object.defineProperty,
          Bi = Object.defineProperties,
          Li = Object.getOwnPropertyDescriptors,
          ji = Object.getOwnPropertySymbols,
          Vi = Object.prototype.hasOwnProperty,
          Ni = Object.prototype.propertyIsEnumerable,
          $i = (t, e, n) =>
            e in t
              ? Di(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (t[e] = n),
          Ri = (t, e) => {
            for (var n in e || (e = {})) Vi.call(e, n) && $i(t, n, e[n]);
            if (ji) for (var n of ji(e)) Ni.call(e, n) && $i(t, n, e[n]);
            return t;
          },
          Fi = (t, e) => Bi(t, Li(e)),
          zi = (t, e, n) => ($i(t, "symbol" != typeof e ? e + "" : e, n), n);
        function Xi(t) {
          return t[t.length - 1];
        }
        class Hi {
          constructor(t) {
            zi(this, "adapted"),
              zi(this, "schema"),
              (this.schema = t),
              (this.adapted = wn(t));
          }
          entryChange(t, e) {
            const n = t.join(".");
            if (Array.isArray(e))
              for (let n = 0; n < e.length; n++)
                this.entryChange(t.concat([`${n}`]), e[n]);
            else
              switch (e.type) {
                case "object":
                  this.adapted.setValue(n, this.createObject(e, Xi(t)));
                  break;
                case "array":
                  this.adapted.setValue(n, this.createArray(e, Xi(t)));
                  break;
                default:
                  this.adapted.setValue(n, [
                    e,
                    {
                      type: "custom",
                      optional: !1 !== e.optional,
                      check: Ti(e, Xi(t)),
                    },
                  ]);
              }
          }
          createArray(t, e) {
            const n = { items: t.items },
              s = new Hi(n).adaptSchema();
            return [
              Fi(Ri({}, t), { items: s.items }),
              { type: "custom", optional: !1 !== t.optional, check: Ti(t, e) },
            ];
          }
          createObject(t, e) {
            var n;
            const s = new Hi(null != (n = t.props) ? n : {}).adaptSchema();
            return [
              Fi(Ri({}, t), { props: s }),
              { type: "custom", optional: !1 !== t.optional, check: Ti(t, e) },
            ];
          }
          adaptSchema() {
            return this.objectPropsChange([], this.schema), this.adapted;
          }
          objectPropsChange(t, e) {
            for (const n in e) this.entryChange(t.concat([n]), e[n]);
          }
        }
        function Yi(t) {
          const e = new Hi(t).adaptSchema();
          return Ai.compile(e);
        }
        var Ui = Object.defineProperty,
          Wi = Object.defineProperties,
          qi = Object.getOwnPropertyDescriptors,
          Gi = Object.getOwnPropertySymbols,
          Zi = Object.prototype.hasOwnProperty,
          Ki = Object.prototype.propertyIsEnumerable,
          Ji = (t, e, n) =>
            e in t
              ? Ui(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (t[e] = n),
          Qi = (t, e) => {
            for (var n in e || (e = {})) Zi.call(e, n) && Ji(t, n, e[n]);
            if (Gi) for (var n of Gi(e)) Ki.call(e, n) && Ji(t, n, e[n]);
            return t;
          },
          tr = (t, e) => Wi(t, qi(e));
        const er = [
            "cm",
            "mm",
            "in",
            "px",
            "pt",
            "pc",
            "em",
            "ex",
            "ch",
            "rem",
            "vw",
            "vh",
            "vmin",
            "vmax",
            "%",
          ],
          nr = [
            {
              type: "string",
              optional: !0,
              default: "linear",
              enum: Object.keys(Jn),
            },
            {
              type: "array",
              optional: !0,
              length: 4,
              items: { type: "number" },
            },
          ],
          sr = { type: "string", empty: !1, trim: !0, optional: !0 },
          ir = { type: "string", empty: !1, trim: !0, optional: !0 },
          rr = { type: "string", empty: !1, optional: !1 },
          or = { type: "amount", optional: !0, integer: !0, min: 0 },
          ar = { type: "amount", integer: !0, min: 1, optional: !0 },
          lr = { type: "amount", integer: !0, min: 0, optional: !0 },
          cr = { type: "amount", integer: !0, min: 0, optional: !0 },
          ur = { type: "html", optional: !0 },
          pr = { type: "css", optional: !0 },
          hr = {
            type: "array",
            optional: !0,
            items: {
              type: "object",
              props: {
                type: { enum: ["google-font"], type: "string" },
                src: { type: "string" },
              },
            },
          },
          dr = {
            type: "array",
            items: {
              type: "object",
              strict: !0,
              props: {
                src: "string",
                id: "string",
                mcid: { type: "string", optional: !0 },
                classes: { type: "array", optional: !0, items: "string" },
                base64: { type: "boolean", optional: !0 },
                startValues: {
                  optional: !0,
                  type: "object",
                  props: {
                    gain: { optional: !0, type: "number" },
                    pan: { optional: !0, type: "number" },
                  },
                },
              },
            },
            optional: !0,
          },
          mr = Yi({
            id: sr,
            name: ir,
            selector: tr(Qi({}, rr), { optional: !0 }),
            easing: nr,
            duration: { type: "amount", optional: !1, integer: !0, min: 0 },
            startFrom: { type: "amount", integer: !0, min: 0, optional: !0 },
            repeats: ar,
            hiatus: lr,
            delay: cr,
          }),
          fr = {
            type: "object",
            optional: !0,
            props: {
              width: { type: "measurement", units: er, optional: !0 },
              height: { type: "measurement", units: er, optional: !0 },
            },
          },
          gr = { type: "string", enum: ["on", "off", "only"], optional: !0 },
          yr = Yi({
            props: [
              {
                type: "object",
                strict: !0,
                props: {
                  id: sr,
                  name: ir,
                  selector: tr(Qi({}, rr), { optional: !0 }),
                  repeats: ar,
                  hiatus: lr,
                  delay: cr,
                  easing: nr,
                  duration: or,
                  html: ur,
                  css: pr,
                  audioSources: dr,
                  audio: gr,
                  containerParams: fr,
                  fonts: hr,
                  initParams: { type: "object", optional: !0 },
                },
              },
              {
                type: "object",
                strict: !0,
                props: {
                  id: sr,
                  name: ir,
                  host: { type: "any", optional: !1 },
                  duration: or,
                  html: ur,
                  css: pr,
                  audioSources: dr,
                  audio: gr,
                  containerParams: fr,
                  fonts: hr,
                  initParams: { type: "object", optional: !0 },
                  initParamsValidationRules: { type: "object", optional: !0 },
                },
              },
              {
                type: "object",
                strict: !0,
                props: {
                  root: { type: "boolean", optional: !0 },
                  name: ir,
                  id: sr,
                  audioSources: dr,
                  audio: tr(Qi({}, gr), { enum: ["on"] }),
                },
              },
            ],
          }),
          vr = Yi({
            selector: tr(Qi({}, rr), { optional: !0, strict: !0 }),
            name: ir,
          }),
          br = Yi({
            selector: tr(Qi({}, rr), { strict: !0, optional: !0 }),
            name: ir,
            repeats: { type: "amount", integer: !0, min: 1, optional: !0 },
            hiatus: { type: "amount", integer: !0, min: 0, optional: !0 },
            delay: { type: "amount", integer: !0, min: 0, optional: !0 },
          });
        var xr = "9.12.0";
        const wr = "mc.descriptive.decisionAuthority";
        var Cr = Object.defineProperty,
          Ir = (t, e, n) => (
            ((t, e, n) => {
              e in t
                ? Cr(t, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: n,
                  })
                : (t[e] = n);
            })(t, "symbol" != typeof e ? e + "" : e, n),
            n
          );
        class Pr extends Xs {
          constructor(t = {}, e = null) {
            super(null != e ? e : t),
              Ir(this, "passiveAddition"),
              null == e
                ? ((this.attrs = {}), (this.props = t))
                : ((this.attrs = t), (this.props = e));
            const n = V(this.props, vr, this.constructor);
            if (!n.result) return n;
            (this._inheritedSelector = null),
              (this.attributesStaggers = []),
              (this.propsStaggers = []),
              this.setupDynamicValues(),
              (this.passiveAddition = !0),
              this._buildTree(),
              (this.passiveAddition = !1);
          }
          _calculateDuration(t = !1) {
            let e = 0;
            for (const n in this.children) {
              const s = this.children[n];
              if (
                (!0 === t &&
                  !0 === s.leaf.constructor.isGroup &&
                  s.leaf._calculateDuration(!0),
                "dynamic" === s.leaf.duration)
              ) {
                e = "dynamic";
                break;
              }
              s.position + s.leaf.duration > e &&
                (e = s.position + s.leaf.duration);
            }
            return (
              e !== this.calculatedDuration &&
              ((this.calculatedDuration = e), this.resetDuration(), !0)
            );
          }
          _rebuildTree() {
            for (const t in this.children) {
              const e = this.children[t];
              !0 === e.leaf.passive && this.removeIncident(e.id);
            }
            (this.passiveAddition = !0),
              this.buildTree(),
              (this.passiveAddition = !1);
          }
          _buildTree() {
            this.buildTree();
          }
          buildTree() {}
          get duration() {
            return "dynamic" === this.calculatedDuration
              ? this.calculatedDuration
              : super.duration;
          }
          set duration(t) {
            super.duration = t;
          }
          manageEditAttrProps(t, e) {
            const { parentNode: n } = this,
              s = n.getLeafPosition(this.id),
              i = w(this[e]);
            (this[e] = t), n.removeIncident(this.id), this._rebuildTree();
            const r = n.addIncident(this, s);
            return (
              r.result ||
                ((this[e] = i), this._rebuildTree(), n.addIncident(this, s)),
              this.resetDuration(),
              r
            );
          }
          detachFromParent() {
            super.detachFromParent(), (this.inheritedSelector = null);
          }
          get inheritedSelector() {
            return this._inheritedSelector;
          }
          set inheritedSelector(t) {
            this._inheritedSelector = t;
            for (const t in this.children)
              this.children[t].leaf.inheritedSelector = this.selector();
          }
          get selectorToPassToChildren() {
            return this.selector();
          }
          exportDefinition() {
            const t = {
              ClassName: this.constructor.ClassName,
              version: this.constructor.version,
              plugin:
                this.constructor.plugin || this.constructor.plugin_npm_name,
              plugin_npm_name: this.constructor.plugin_npm_name,
              attrs: this.attrs,
              props: this.props,
              incidents: {},
              duration: this.duration,
            };
            for (const e in this.children) {
              const n = this.children[e];
              !0 !== n.leaf.passive &&
                (t.incidents[e] = {
                  id: n.id,
                  position: n.position,
                  leaf: n.leaf.exportDefinition(),
                });
            }
            return t;
          }
          exportLiveDefinition(t = !0) {
            const e = w(this.props);
            t || delete e.id;
            const n = {
              Class: this.constructor,
              attrs: w(this.attrs),
              props: e,
              incidents: {},
            };
            for (const e in this.children) {
              const s = this.children[e];
              !0 !== s.leaf.passive &&
                (n.incidents[e] = {
                  position: s.position,
                  leaf: s.leaf.exportLiveDefinition(t),
                });
            }
            return n;
          }
          addIncident(t, e, n = { check: !0 }) {
            if (!(t instanceof ps))
              return (
                j.warning("addIncident rejected, invalid incident provided"),
                { result: !1, errors: "Invalid Incident provided" }
              );
            let s;
            if (
              ((t.inheritedSelector = this.selectorToPassToChildren),
              !0 === n.check)
            ) {
              const n = super.checkAddition(t, e);
              if (!n.result) return (t.inheritedSelector = null), n;
              if (
                ((s = this.putMessageOnPipe("checkForClip", {}, wr, {
                  selfExecute: !0,
                  direction: Z._UP,
                })),
                !0 === s.response)
              ) {
                const e = t.putMessageOnPipe(
                  "checkForInvalidSelectors",
                  {},
                  null,
                  { selfExecute: !0, direction: Z._DOWN }
                );
                if (e.length > 0) {
                  const t = [];
                  for (let n = 0; n < e.length; n++) t.push(e[n].response);
                  return { result: !1, errors: t };
                }
              }
              const i = this.putMessageOnPipe(
                "checkAddition",
                { incident: t, millisecond: e, parentGroupId: this.id },
                wr,
                { selfExecute: !0, direction: Z._UP }
              );
              if (!i.response.result)
                return (
                  j.error({
                    message: "addIncident rejected",
                    incident: { attrs: t.attrs, props: t.props },
                    position: e,
                    conflicts: i.response.errors,
                  }),
                  (t.inheritedSelector = null),
                  i.response
                );
            }
            !0 === this.passiveAddition && (t.passive = !0);
            const i = this.addChild(t, e);
            return (
              i.result || (t.inheritedSelector = null),
              "dynamic" === t.duration && s && this._calculateDuration(!0),
              i
            );
          }
          moveIncident(t, e) {
            const n = v(t) ? t.id : t,
              s = super.checkEditPosition(n, e);
            if (!s.result) return s;
            const i = e - this.getLeafPosition(n);
            if (0 === i) return { result: !0 };
            const r = this.putMessageOnPipe(
              "checkMove",
              {
                id: n,
                millisecond: e,
                positionDelta: i,
                parentGroupId: this.id,
              },
              wr,
              { selfExecute: !0, direction: Z._UP }
            );
            return r.response.result ? this.editPosition(n, e) : r.response;
          }
          removeIncident(t) {
            const e = v(t) ? t.id : t,
              n = super.checkRemoveChild(e);
            if (!n.result) return n;
            const s = this.putMessageOnPipe(
              "checkDeletion",
              { id: e, parentGroupId: this.id },
              wr,
              { selfExecute: !0, direction: Z._UP }
            );
            return s.response.result ? this.removeChild(e) : s.response;
          }
          handleCheckForClip(t, e) {
            return !!this.hasParent && this.bypass();
          }
          handleCheckAddition(t, e) {
            return this.hasParent ? this.bypass() : { result: !0 };
          }
          handleCheckMove(t, e) {
            return this.hasParent ? this.bypass() : { result: !0 };
          }
          handleCheckDeletion(t, e) {
            return this.hasParent ? this.bypass() : { result: !0 };
          }
          handleCheckResize(t, e) {
            return this.hasParent ? this.bypass() : { result: !0 };
          }
          handleSetDurationDynamic(t, e) {
            (this.calculatedDuration = "dynamic"),
              this.putMessageOnPipe("setDurationDynamic", {}, "Groups", {
                selfExecute: !1,
                direction: Z._UP,
              });
          }
        }
        Ir(Pr, "Incident", Us),
          Ir(Pr, "plugin_npm_name", u),
          Ir(Pr, "version", xr),
          Ir(Pr, "Channel", Y),
          Ir(Pr, "ClassName", "Group"),
          Ir(Pr, "isGroup", !0),
          Ir(Pr, "attrsValidationRules", null),
          Ir(Pr, "propsValidationRules", vr);
        var Er = Object.defineProperty;
        const kr = "-",
          Sr = {
            isCombo: function (t) {
              return t.incidentClass.isCombo;
            },
            getItem: function (t, e) {
              return In(e.join("."), "attrs", t);
            },
            getRepeatPosition: (t, e, n, s) =>
              s * (e || 0) + (s + 1) * (t || 0) + s * n,
            refersToOwnSelector(t, e, n = 0) {
              let s = e;
              !1 === Array.isArray(e) && (s = e.split("."));
              const i = this.getItem(t, s.slice(0, 2 + n));
              return (
                ("" === i.props.selector || null == i.props.selector) &&
                ("props" === s[2] ||
                  !this.isCombo(i) ||
                  this.refersToOwnSelector(t, s, n + 3))
              );
            },
            cascadeSelectors(t, e, n = "") {
              let s = [];
              for (let i = 0; i < e.length; i++) {
                const r = e[i];
                let o;
                if (
                  ((o = x(r.props, "selector")
                    ? `${t} ${r.props.selector}`
                    : t),
                  s.push({
                    path: `${n}${"" === n ? "" : "."}${i}.props.selector`,
                    value: o,
                  }),
                  this.isCombo(r))
                ) {
                  const t = this.cascadeSelectors(
                    o,
                    r.attrs.incidents,
                    `${n}${"" === n ? "" : "."}${i}.attrs.incidents`
                  );
                  s = s.concat(t);
                }
              }
              return s;
            },
            createDescriptiveIncidentLikeObject: (t, e, n, s, i) => ({
              constructor: {
                Incident: t.incidentClass.targetClass.Incident,
                plugin_npm_name: t.incidentClass.targetClass.plugin_npm_name,
                Channel: t.incidentClass.targetClass.Channel,
                isClip: !1,
              },
              attrs: s || t.attrs,
              props: i || t.props,
              selector: () => t.props.selector,
              id: t.props.id,
              audioClip: null,
              audio: "no",
              dynamicDurationValue: null,
              putMessageOnPipe: L,
              attributesStaggers: e,
              propsStaggers: n,
            }),
            parseElementsDynamics(t, e, n, s, i) {
              const r = `incidents.${i}.attrs`,
                o = `incidents.${i}.props`,
                a = wn(e),
                l = wn(n);
              for (let e = 0; e < t.length; e++)
                if (0 === t[e].path.indexOf(r)) {
                  const n = t[e].path.substring(r.length + 1);
                  a.setValue(n, t[e].values[s]);
                } else if (0 === t[e].path.indexOf(o)) {
                  const n = t[e].path.substring(o.length + 1);
                  l.setValue(n, t[e].values[s]);
                }
              return {
                incidentAttrs: a.exportFlattened(),
                incidentProps: l.exportFlattened(),
              };
            },
            getStaggersForChild(t, e, n) {
              const s = [],
                i = [];
              for (let r = 0; r < t.length; r++)
                "position" === n &&
                0 === t[r].path.indexOf(`incidents.${e}.${n}`)
                  ? i.push({ path: "position", stagger: t[r].stagger })
                  : 0 === t[r].path.indexOf(`incidents.${e}.${n}`)
                  ? i.push({
                      path: t[r].path.substring(
                        `incidents.${e}.${n}`.length + 1
                      ),
                      stagger: t[r].stagger,
                    })
                  : s.push(t[r]);
              return { identifiedDynamics: i, remainingDynamics: s };
            },
            createElementProxy(t, e, n, s, i) {
              const r = wn(t),
                o = this.cascadeSelectors(
                  e,
                  t.attrs.incidents,
                  "attrs.incidents"
                );
              for (let t = 0; t < s.length; t++)
                r.setValue(`attrs.${s[t].path}`, s[t].values[n]);
              for (let t = 0; t < i.length; t++)
                r.setValue(`props.${i[t].path}`, i[t].values[n]);
              for (let t = 0; t < o.length; t++)
                r.setValue(o[t].path, o[t].value);
              return r;
            },
          };
        class Or extends gi {
          constructor() {
            super(...arguments),
              ((t, e, n) => {
                ((t, e, n) => {
                  e in t
                    ? Er(t, e, {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: n,
                      })
                    : (t[e] = n);
                })(this, e + "", void 0);
              })(0, "childrenStaggers");
          }
          parseAttrsDynamicValues(t, e) {
            this.childrenStaggers = [];
            for (let n = 0; n < t.attributesStaggers.length; n++)
              Sr.refersToOwnSelector(t, t.attributesStaggers[n].path)
                ? this.staggerAttrs.push({
                    path: t.attributesStaggers[n].path,
                    values: t.attributesStaggers[n].stagger.calculateValues(
                      e,
                      this.initParams
                    ),
                  })
                : this.childrenStaggers.push(t.attributesStaggers[n]);
          }
          handleRecalcDuration(t, e) {
            const n = super.handleRecalcDuration(t, e);
            return (
              (this.descriptiveIncident.dynamicDurationValue =
                1 * this.duration),
              n
            );
          }
          lastWish() {
            (this.descriptiveIncident.dynamicDurationValue = null),
              this.descriptiveIncident.putMessageOnPipe(
                "setDurationDynamic",
                {},
                "Groups",
                { selfExecute: !1, direction: Z._UP }
              ),
              super.lastWish();
          }
          _createElementIncident(t, e, n, s, i, r) {
            const o = Sr.createElementProxy(
              e,
              n.context.getElementSelectorByMCID(r),
              s,
              this.staggerAttrs,
              this.staggerProps
            );
            for (let t = 0; t < this.staggerAttrs.length; t++)
              o.setValue(
                `attrs.${this.staggerAttrs[t].path}`,
                this.staggerAttrs[t].values[s]
              );
            const a = Ct({
              id: `${this.id}_element${kr}${s}`,
              attrs: {},
              props: {},
              Incident: Pr.Incident,
              plugin_npm_name: Pr.plugin_npm_name,
              Channel: Pr.Channel,
              DescriptiveIncident: new Pr(),
            });
            for (let t = 0; t < (o.props.repeats || 1); t++) {
              const e = Ct({
                id: `${this.id}_element${kr}${s}_repeat${kr}${t}`,
                attrs: {},
                props: {},
                Incident: Pr.Incident,
                plugin_npm_name: Pr.plugin_npm_name,
                Channel: Pr.Channel,
                DescriptiveIncident: new Pr(),
              });
              let r = this.childrenStaggers;
              o.attrs.incidents.forEach((a, l) => {
                const { incidentAttrs: c, incidentProps: u } =
                    Sr.parseElementsDynamics(
                      this.staggerAttrs,
                      a.attrs,
                      a.props,
                      s,
                      l
                    ),
                  p = Sr.getStaggersForChild(r, l, "attrs"),
                  h = Sr.getStaggersForChild(p.remainingDynamics, l, "props"),
                  d = Sr.getStaggersForChild(
                    p.remainingDynamics,
                    l,
                    "position"
                  );
                (r = h.remainingDynamics),
                  o.setValue(
                    `attrs.incidents.${l}.props.id`,
                    `${this.id}_element${kr}${s}_repeat${kr}${t}_incident${kr}${l}`
                  );
                const m = Mr(
                  Sr.createDescriptiveIncidentLikeObject(
                    a,
                    p.identifiedDynamics,
                    h.identifiedDynamics,
                    c,
                    u
                  ),
                  n
                );
                let f = a.position;
                1 === d.identifiedDynamics.length &&
                  (f = d.identifiedDynamics[0].stagger.calculateValues(
                    new Array(i),
                    this.initParams
                  )[s]),
                  e.addChild(m, f);
              }),
                a.addChild(
                  e,
                  Sr.getRepeatPosition(
                    o.props.delay,
                    o.props.hiatus,
                    e.duration,
                    t
                  )
                );
            }
            this.addChild(a, 0);
          }
        }
        function Mr(t, e) {
          const n = e.context.audio;
          if ((n && "off" === t.audio) || (!n && "only" === t.audio))
            return null;
          if (
            x(t.props, "selector") &&
            ((!n && t.props.selector.startsWith("~")) ||
              (n && !t.props.selector.startsWith("~") && !t.constructor.isClip))
          )
            return null;
          if (t.constructor.isClip) {
            if (!n) {
              const n = new ki(t, e);
              return (n.plugin_channel_class = Y), n;
            }
            return n ? t.audioClip : t.realClip;
          }
          if (t.constructor.isCombo) return new Or(t, e);
          if (t.constructor.isGroup) {
            const n = Ct({
              id: t.id,
              attrs: t.attrs,
              props: t.props,
              Incident: t.constructor.Incident,
              plugin_npm_name: t.constructor.plugin_npm_name,
              Channel: t.constructor.Channel,
              DescriptiveIncident: t,
            });
            for (const s in t.children) {
              const i = Mr(t.children[s].leaf, e);
              null !== i && n.addChild(i, t.children[s].position);
            }
            return n;
          }
          return new gi(t, e);
        }
        var Ar = Object.defineProperty,
          _r = (t, e, n) => (
            ((t, e, n) => {
              e in t
                ? Ar(t, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: n,
                  })
                : (t[e] = n);
            })(t, "symbol" != typeof e ? e + "" : e, n),
            n
          );
        function Tr(t) {
          return function () {
            for (let e = 0; e < t.length; e++) t[e]();
          };
        }
        class Dr extends Us {
          constructor(t, e, n) {
            super(t, e),
              _r(this, "instantiatedChannels"),
              _r(this, "isHostedClip"),
              _r(this, "durationSubs"),
              _r(this, "clipCopyId"),
              _r(this, "ownContext"),
              _r(this, "iframe"),
              _r(this, "_volume"),
              (this.attrs = t),
              (this.props = e),
              (this.DescriptiveIncident = n),
              (this.blockingWaitings = {}),
              (this.instantiatedChannels = {}),
              (this.isHostedClip = !0),
              (this.instantiatedCopiesContexts = {}),
              this.onClipInitialise(),
              (this.runTimeInfo = this.props.runTimeInfo),
              (this.durationSubs = []);
          }
          get volume() {
            return this._volume;
          }
          set volume(t) {
            this._volume = parseFloat(t);
          }
          get contextReady() {
            return this.context.contextLoaded;
          }
          onClipInitialise() {}
          contextLoading() {
            this.context.contextLoaded = !1;
          }
          contextLoaded() {
            (this.context.contextLoaded = !0),
              this.putMessageOnPipe(
                "contextLoaded",
                {},
                {},
                { selfExecute: !1, direction: Z._DOWN }
              );
            for (const t in this.instantiatedChannels)
              this.instantiatedChannels[t].recalcScratchValues();
            this.unblock(this.clipCopyId || null);
          }
          getElements(t) {
            var e, n;
            if (null !== this.props.host && void 0 !== this.props.host)
              return null == (n = (e = this.context).getElements)
                ? void 0
                : n.call(e, t);
            const s = [];
            for (const e in this.instantiatedCopiesContexts) {
              const n = this.instantiatedCopiesContexts[e].getElements(t);
              for (let t = 0; t < n.length; t++) s.push(n[t]);
            }
            return s;
          }
          addContext(t) {
            return (
              (this.instantiatedCopiesContexts[t.clipId] = t.context),
              (t.instantiatedCopiesContexts = this.instantiatedCopiesContexts),
              this.putMessageOnPipe(
                "addContext",
                t,
                {},
                { selfExecute: !1, direction: Z._DOWN }
              )
            );
          }
          exportConstructionArguments() {
            return { attrs: this.attrs, props: this.props };
          }
          _resize(t) {
            for (const e in this.instantiatedChannels)
              this.instantiatedChannels[e]._resize(t);
            this.setNewDuration(this.duration * t);
            for (let t = 0; t < this.durationSubs.length; t++)
              this.durationSubs[t](this.duration);
          }
          addIncident(t) {
            const e = this.putMessageOnPipe(
                "addIncident",
                {
                  incident: t.incident,
                  millisecond: t.millisecond,
                  incidentFromDescription: Mr,
                  contextData: {
                    clipId: this.id,
                    context: this.context,
                    instantiatedCopiesContexts: this.instantiatedCopiesContexts,
                  },
                },
                t.parentGroupId,
                { selfExecute: !0, direction: Z._DOWN }
              ),
              n = {};
            for (let s = 0; s < e.length; s++) {
              const i = e[s].response.getIncidentsByChannel(
                e[s].positionDelta + t.millisecond
              );
              for (const t in i)
                x(n, t) ? n[t].push(...i[t]) : (n[t] = [...i[t]]);
            }
            const s = this.checkAddition(n);
            return s.result
              ? {
                  result: !0,
                  execute: () => {
                    s.execute();
                    for (let n = 0; n < e.length; n++) {
                      const s = e[n];
                      s.responder.addChild(s.response, t.millisecond),
                        s.responder.putMessageOnPipe(
                          "recalcDuration",
                          { childId: s.response.id },
                          "Groups",
                          { selfExecute: !0, direction: Z._UP }
                        );
                      for (const t in this.instantiatedCopiesContexts)
                        s.response.putMessageOnPipe(
                          "addContext",
                          {
                            clipId: t,
                            context: this.instantiatedCopiesContexts[t],
                          },
                          "ContextAwareIncidents",
                          { selfExecute: !1, direction: Z._DOWN }
                        );
                    }
                  },
                }
              : s;
          }
          checkAddition(t, e = "all-or-nothing") {
            var n;
            let s = !0,
              i = [];
            const r = [];
            for (const e in t) {
              if (!x(this.instantiatedChannels, e)) {
                const s = t[e][0].incident.plugin_channel_class;
                this.instantiatedChannels[e] = new s({
                  runTimeInfo: this.runTimeInfo,
                  context: this.context,
                  subscribe:
                    null == (n = this.DescriptiveIncident)
                      ? void 0
                      : n.subscribe.bind(this.DescriptiveIncident),
                });
              }
              const o = this.instantiatedChannels[e].addIncidents(t[e]);
              (s = s && o.result),
                o.result ? r.push(o.execute) : (i = i.concat(o.errors));
            }
            return { result: s, errors: i, execute: Tr(r) };
          }
          moveIncident(t) {
            const e = this.putMessageOnPipe(
                "moveIncident",
                {
                  incidentId: t.id,
                  millisecond: t.millisecond,
                  parentGroupId: t.parentGroupId,
                  contextData: { clipId: this.id, context: this.context },
                },
                t.parentGroupId,
                { selfExecute: !0, direction: Z._DOWN }
              ),
              n = {};
            for (let s = 0; s < e.length; s++) {
              const i = e[s].response.getIncidentsByChannel(
                e[s].positionDelta + t.millisecond
              );
              for (const t in i) x(n, t) || (n[t] = []), n[t].push(...i[t]);
            }
            const s = this.checkMove(n, t.positionDelta);
            return s.result
              ? {
                  result: !0,
                  execute: function () {
                    s.execute();
                    for (let n = 0; n < e.length; n++)
                      e[n].responder.editPosition(
                        e[n].response.id,
                        t.millisecond
                      ),
                        e[n].responder.putMessageOnPipe(
                          "recalcDuration",
                          {},
                          "Groups",
                          { selfExecute: !0, direction: Z._UP }
                        );
                  },
                }
              : s;
          }
          checkMove(t, e) {
            let n = !0,
              s = [];
            const i = [];
            for (const r in t) {
              const o = this.instantiatedChannels[r].editIncidents(t[r], e);
              (n = n && o.result),
                o.result ? i.push(o.execute) : (s = s.concat(o.errors));
            }
            return { result: n, errors: s, execute: Tr(i) };
          }
          removeIncident(t) {
            const e = this.putMessageOnPipe(
                "removeIncident",
                {
                  incidentId: t.id,
                  parentGroupId: t.parentGroupId,
                  contextData: { clipId: this.id, context: this.context },
                },
                t.parentGroupId,
                { selfExecute: !0, direction: Z._DOWN }
              ),
              n = {};
            for (let t = 0; t < e.length; t++) {
              const s = e[t].response.getIncidentsByChannel();
              for (const t in s) x(n, t) || (n[t] = []), n[t].push(...s[t]);
            }
            const s = this.checkDelete(n);
            return s.result
              ? {
                  result: !0,
                  execute: () => {
                    s.execute();
                    for (let t = 0; t < e.length; t++)
                      e[t].responder.removeChild(e[t].response.id),
                        e[t].responder.putMessageOnPipe(
                          "recalcDuration",
                          {},
                          "Groups",
                          { selfExecute: !0, direction: Z._UP }
                        );
                  },
                }
              : s;
          }
          checkDelete(t) {
            let e = !0,
              n = [];
            const s = [];
            for (const i in t) {
              const r = this.instantiatedChannels[i].removeIncidents(t[i]);
              (e = e && r.result),
                r.result ? s.push(r.execute) : (n = n.concat(r.errors));
            }
            return { result: e, errors: n, execute: Tr(s) };
          }
          resizeIncident(t) {
            const e = this.putMessageOnPipe(
                "resize",
                {
                  incidentId: t.id,
                  newSize: t.newSize,
                  fraction: t.fraction,
                  contextData: { clipId: this.id, context: this.context },
                },
                t.id,
                { selfExecute: !1, direction: Z._DOWN }
              ),
              n = {};
            for (let t = 0; t < e.length; t++) {
              const s = e[t].response.getIncidentsByChannel(e[t].positionDelta);
              for (const t in s) x(n, t) || (n[t] = []), n[t].push(...s[t]);
            }
            let s = 0;
            e.length > 0 && (s = e[0].positionDelta);
            const i = this.checkResize(t.fraction, n, s);
            return i.result
              ? {
                  result: !0,
                  execute: () => {
                    i.execute();
                    for (let n = 0; n < e.length; n++)
                      e[n].responder.setNewDuration(t.newSize);
                  },
                }
              : i;
          }
          checkResize(t, e, n = 0) {
            let s = !0,
              i = [];
            const r = [];
            for (const o in e) {
              const a = $(e[o], t, n),
                l = this.instantiatedChannels[o].checkResizedIncidents(a);
              s && (s = l.result),
                l.result ? r.push(l.execute) : (i = i.concat(l.errors));
            }
            return { result: s, errors: i, execute: Tr(r) };
          }
          get context() {
            var t;
            return (
              null != (t = this.ownContext).contextLoaded ||
                (t.contextLoaded = !0),
              this.ownContext
            );
          }
          getIncidentsByChannel(t = 0) {
            return {
              "@donkeyclip/self-contained-incidents": [
                {
                  millisecond: t,
                  incident: this,
                  id: this.id,
                  parentMillisecond: void 0,
                },
              ],
            };
          }
          _onGetContextOnce(t) {}
          handleRecalcDuration(t, e) {
            if (this._calculateDuration(e))
              for (let t = 0; t < this.durationSubs.length; t++)
                this.durationSubs[t](this.duration);
            return !0;
          }
          onProgress(t, e, n, s = !1) {
            if (!1 !== this.contextReady) {
              n || (n = this.id);
              for (const t in this.instantiatedChannels)
                this.instantiatedChannels[t].moveTo(
                  this.runTimeInfo.currentMillisecond,
                  e,
                  n,
                  s
                );
            } else this.setBlock();
          }
          flash() {
            if (this.contextReady)
              for (const t in this.instantiatedChannels)
                this.instantiatedChannels[t].moveTo(
                  0,
                  this.runTimeInfo.currentMillisecond,
                  this.id,
                  !0
                );
          }
          subscribeToDurationChange(t) {
            this.durationSubs.push(t);
          }
          handleSetBlockingWaiting(t, e) {}
          handleRemoveBlockingWaiting(t, e) {}
          setCustomEntity(t, e, n = []) {
            return this.context.setCustomEntity(t, e, n);
          }
          exportLiveDefinition(t) {
            throw new Error("Method not implemented.");
          }
          manageEditAttrProps(t, e) {
            throw new Error("Method not implemented.");
          }
        }
        var Br = Object.defineProperty,
          Lr = Object.getOwnPropertySymbols,
          jr = Object.prototype.hasOwnProperty,
          Vr = Object.prototype.propertyIsEnumerable,
          Nr = (t, e, n) =>
            e in t
              ? Br(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (t[e] = n),
          $r = (t, e, n) => (Nr(t, "symbol" != typeof e ? e + "" : e, n), n);
        class Rr {
          constructor(t) {
            $r(this, "_targetHost"),
              $r(this, "context"),
              $r(this, "customEntities"),
              $r(this, "elementsByMCID"),
              $r(this, "id"),
              $r(this, "props"),
              (this.props = t),
              (this.customEntities = {}),
              (this.elementsByMCID = {}),
              this.setContext();
          }
          setContext(t = {}) {
            this.context = ((t, e) => {
              for (var n in e || (e = {})) jr.call(e, n) && Nr(t, n, e[n]);
              if (Lr) for (var n of Lr(e)) Vr.call(e, n) && Nr(t, n, e[n]);
              return t;
            })(
              {
                audio: !1,
                contextLoaded: !1,
                getElements: this._getElements.bind(this),
                getElementSelectorByMCID:
                  this._getElementSelectorByMCID.bind(this),
                getElementByMCID: this.getElementByMCID.bind(this),
                setCustomEntity: this.setCustomEntity.bind(this),
                getMCID: this._getMCID.bind(this),
                setMCID: this.setMCID.bind(this),
                unmount: this.unmount.bind(this),
              },
              t
            );
          }
          _getElements(t) {
            if (null == t || "" === t) return [];
            if (t.startsWith("!")) {
              if ((t = t.substring(1)).startsWith("#"))
                return [this.customEntities[t.substring(1)]];
              if (t.startsWith(".")) {
                const e = [];
                for (const n in this.customEntities) {
                  const s = this.customEntities[n];
                  s.classes.includes(t.substring(1)) && e.push(s);
                }
                return e;
              }
            }
            return this.getElements(t);
          }
          _getMCID(t) {
            return t.customEntity ? t.id : this.getMCID(t);
          }
          _getElementSelectorByMCID(t) {
            return x(this.customEntities, t)
              ? `!#${t}`
              : this.getElementSelectorByMCID(t);
          }
          getElementByMCID(t) {
            if (x(this.customEntities, t)) return this.customEntities[t];
            if (x(this.elementsByMCID, t)) return this.elementsByMCID[t];
            const e = this._getElements(this._getElementSelectorByMCID(t))[0];
            return (this.elementsByMCID[t] = e), e;
          }
          getElements(t) {
            return [];
          }
          getMCID(t) {}
          setMCID(t, e) {}
          getElementSelectorByMCID(t) {}
          unmount() {}
          setCustomEntity(t, e, n = []) {
            return x(this.customEntities, t)
              ? (j.error(
                  `Clip ${this.id} already has custom Entity with id: ${t}`
                ),
                !1)
              : ((this.customEntities[t] = {
                  id: t,
                  entity: e,
                  classes: n,
                  customEntity: !0,
                }),
                !0);
          }
        }
        var Fr = Object.defineProperty;
        class zr extends Rr {
          constructor() {
            super(...arguments),
              ((t, e, n) => {
                ((t, e, n) => {
                  e in t
                    ? Fr(t, e, {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: n,
                      })
                    : (t[e] = n);
                })(this, e + "", void 0);
              })(0, "rootElement");
          }
          calcClipDims(t) {
            const e = { use: !1, width: null, height: null };
            return x(t, "originalDims") &&
              null != t.originalDims.width &&
              null != t.originalDims.height
              ? {
                  use: !0,
                  width:
                    t.originalDims.width.number + t.originalDims.width.unit,
                  height:
                    t.originalDims.height.number + t.originalDims.height.unit,
                }
              : (x(t, "containerParams") &&
                  (x(t.containerParams, "width") &&
                    ((e.use = !0), (e.width = t.containerParams.width)),
                  x(t.containerParams, "height") &&
                    ((e.use = !0), (e.height = t.containerParams.height))),
                e);
          }
          scalingCalculator(t) {
            if (
              !x(t, "containerParams") ||
              !x(t, "originalDims") ||
              (null == t.originalDims.width && null == t.originalDims.height)
            )
              return { width: 1, height: 1 };
            const e = k(t.containerParams);
            let n = null,
              s = null;
            return (
              null !== e.width &&
                null !== t.originalDims.width &&
                (e.width.unit === t.originalDims.width.unit
                  ? (n = e.width.number / t.originalDims.width.number)
                  : j.warning(
                      "containerParams and originalDims width of Incident have different dimensions.\ncontainerParams.width will be ignored"
                    )),
              null != e.height &&
                null != t.originalDims.height &&
                (e.height.unit === t.originalDims.height.unit
                  ? (s = e.height.number / t.originalDims.height.number)
                  : j.warning(
                      "containerParams and originalDims height of Incident have different dimensions.\ncontainerParams.height will be ignored"
                    )),
              null == n && null == s
                ? { width: 1, height: 1 }
                : (null != n && null == s
                    ? (s = n)
                    : null != s && null == n && (n = s),
                  { width: n, height: s })
            );
          }
          getElements(t) {
            return Array.from(this.context.rootElement.querySelectorAll(t));
          }
          getMCID(t) {
            return t.getAttribute(i);
          }
          setMCID(t, e) {
            t.setAttribute(i, e);
          }
          getElementSelectorByMCID(t) {
            return `[${i}="${t}"]`;
          }
        }
        function Xr(t, e, n = !1) {
          if (b(t)) return t(e);
          const s = Vn(t, { items: { initParams: e }, keys: {} }, n);
          return y(s) ? s : s.outerHTML;
        }
        function Hr(t, e, n) {
          t.styleSheet
            ? (t.styleSheet.cssText = e)
            : t.appendChild(n.createTextNode(e));
        }
        function Yr(t, e) {
          if ("google-font" === e.type)
            return (function (t, e) {
              const n = t.createElement("link");
              return (
                n.setAttribute("rel", "stylesheet"),
                e.src.trimStart().startsWith("https://fonts.googleapis.com/css")
                  ? (n.setAttribute("href", e.src), n)
                  : (j.error(
                      `Only valid google font url are accepted on src of a google-font. ${e.src} provided. No font will loaded`
                    ),
                    n)
              );
            })(t, e);
          j.error(
            `The provided font type is not one of the supported. ${e.type} provided. Aborting loading font.`
          );
          const n = t.createElement("link");
          return n.setAttribute("rel", "stylesheet"), n;
        }
        const Ur = "@donkeyclip/motorcortex/iframeContextHandler/css";
        class Wr extends zr {
          constructor(t = {}) {
            super(t);
            const { ownerDocument: e } = t.host;
            if (!e.getElementById(Ur)) {
              const t =
                  "iframe[seamless]{background-color:transparent;border:0 none transparent;padding:0;overflow: hidden;}",
                n = e.createElement("style");
              (n.id = Ur),
                Hr(n, t, e),
                (e.head || e.getElementsByTagName("head")[0]).appendChild(n);
            }
            const n = e.createElement("iframe");
            t.host.appendChild(n);
            const s = this.scalingCalculator(t),
              i = this.calcClipDims(t);
            n.setAttribute("seamless", "seamless"),
              !0 === i.use &&
                (null !== i.width && n.setAttribute("width", i.width),
                null !== i.height && n.setAttribute("height", i.height)),
              (n.style.transform = `scale(${s.width}, ${s.height})`),
              (n.style.transformOrigin = "top left"),
              (n.style.position = "absolute"),
              (n.src = "");
            let r = n.contentWindow || n.contentDocument;
            r.document && (r = r.document),
              r.write(Xr(t.html, t.initParams, !0));
            const o = `${Xr(t.css, t.initParams)}body{padding:0;margin:0;}`,
              a = r.createElement("style");
            Hr(a, o, e);
            const l = r.head || r.getElementsByTagName("head")[0];
            if ((l.appendChild(a), x(t, "fonts")))
              for (let e = 0; e < t.fonts.length; e++) {
                const n = Yr(r, t.fonts[e]);
                l.appendChild(n);
              }
            (this.rootElement = n),
              r.close(),
              this.setContext({
                document: r,
                window: n.contentWindow || n,
                clipContainer: n,
                rootElement: r.body,
                unmount() {
                  t.host.removeChild(n);
                },
              });
          }
        }
        var qr = Object.defineProperty;
        const Gr = "data-motorcortex-container";
        class Zr extends zr {
          constructor(t = {}) {
            super(t),
              ((t, e, n) => {
                ((t, e, n) => {
                  e in t
                    ? qr(t, e, {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: n,
                      })
                    : (t[e] = n);
                })(this, e + "", void 0);
              })(0, "fontTags");
            const e = document.createElement("div");
            this.styleWrapper(e, this.props),
              (e.innerHTML = Xr(t.html, t.initParams, !0)),
              (this.rootElement = e);
            let n = this.targetHost.shadowRoot;
            n || (n = this.targetHost.attachShadow({ mode: "open" })),
              n.appendChild(e);
            const s = document.createElement("slot");
            n.appendChild(s);
            const i = document.createElement("style");
            if (
              (Hr(
                i,
                `${i.styleSheet ? "[" + Gr + "] { all: initial; }" : ""}${Xr(
                  t.css,
                  t.initParams
                )}`,
                document
              ),
              n.appendChild(i),
              (this.fontTags = []),
              x(t, "fonts"))
            )
              for (let e = 0; e < t.fonts.length; e++) {
                const n = t.fonts[e],
                  s = Yr(document, n);
                document.getElementsByTagName("head")[0].appendChild(s),
                  this.fontTags.push(s);
              }
            this.setContext({
              contextLoaded: !0,
              document,
              window,
              clipContainer: this.targetHost,
              rootElement: e,
              unmount() {
                try {
                  n.innerHTML = "";
                  for (let t = 0; t < this.fontTags.length; t++)
                    document
                      .getElementsByTagName("head")[0]
                      .removeChild(this.fontTags[t]);
                } catch (t) {
                  j.warning(
                    "The element of the Clip to be removed seems not to exist any more"
                  );
                }
              },
            });
          }
          styleWrapper(t, e) {
            const n = this.scalingCalculator(e),
              s = this.calcClipDims(e);
            t.setAttribute(Gr, "true"),
              !0 === s.use &&
                (null !== s.width && (t.style.width = s.width),
                null !== s.height && (t.style.height = s.height)),
              (t.style.transform = `scale(${n.width}, ${n.height})`),
              (t.style.transformOrigin = "top left"),
              (t.style.position = "absolute"),
              (t.style.overflow = "hidden");
          }
          unstyleWrapper(t) {
            for (; t.attributes.length > 0; )
              t.removeAttribute(t.attributes[0].name);
            t.setAttribute(Gr, !0);
          }
          get targetHost() {
            return this.props.host;
          }
        }
        var Kr = Object.defineProperty,
          Jr = Object.defineProperties,
          Qr = Object.getOwnPropertyDescriptors,
          to = Object.getOwnPropertySymbols,
          eo = Object.prototype.hasOwnProperty,
          no = Object.prototype.propertyIsEnumerable,
          so = (t, e, n) =>
            e in t
              ? Kr(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (t[e] = n),
          io = (t, e) => {
            for (var n in e || (e = {})) eo.call(e, n) && so(t, n, e[n]);
            if (to) for (var n of to(e)) no.call(e, n) && so(t, n, e[n]);
            return t;
          },
          ro = (t, e) => Jr(t, Qr(e));
        class oo extends Dr {
          constructor(t = {}, e = {}, n) {
            super(t, e, n),
              (e = ro(io({}, e), {
                html: "" !== this.html ? this.html : e.html,
                css: "" !== this.css ? this.css : e.css,
                fonts: this.fonts.length > 0 ? this.fonts : e.fonts,
              }));
            const s = new (
              document.head.createShadowRoot || document.head.attachShadow
                ? Zr
                : Wr
            )(e);
            (this.ownContext = ro(io({}, s.context), {
              initParams: e.initParams,
            })),
              (this.iframe = s.iframeElement),
              this.onAfterRender();
          }
          onAfterRender() {}
          get html() {
            return "";
          }
          get css() {
            return "";
          }
          get fonts() {
            return [];
          }
          get rootElement() {
            return this.context.rootElement;
          }
          exportConstructionArguments() {
            var t;
            return {
              attrs: this.attrs,
              props: ro(io({}, this.props), {
                host: void 0,
                html:
                  !0 ===
                  (null == (t = this.DescriptiveIncident)
                    ? void 0
                    : t.constructor
                  ).customClip
                    ? ""
                    : this.context.rootElement.innerHTML,
              }),
            };
          }
        }
        function ao() {
          return { result: !0 };
        }
        var lo = Object.defineProperty,
          co = (t, e, n) => (
            ((t, e, n) => {
              e in t
                ? lo(t, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: n,
                  })
                : (t[e] = n);
            })(t, "symbol" != typeof e ? e + "" : e, n),
            n
          );
        class uo extends Pr {
          constructor(t, e) {
            super(t, e),
              co(this, "isTheRootClip"),
              co(this, "listeners", {}),
              co(this, "previousTimeStamp"),
              co(this, "speed"),
              co(this, "pauseMoment"),
              (this.runTimeInfo = { currentMillisecond: 0, state: "idle" }),
              (this.listeners = {}),
              (this.previousTimeStamp = -1),
              (this.speed = 1);
          }
          _setState(t, e = {}) {
            if (t !== this.runTimeInfo.state) {
              (this.runTimeInfo.state = t),
                this.putMessageOnPipe(
                  "setState",
                  { newState: t, options: e },
                  "Clips",
                  { selfExecute: !1, direction: Z._DOWN }
                );
              for (const n in this.listeners)
                this.listeners[n].funct(
                  this.runTimeInfo.currentMillisecond,
                  t,
                  e
                );
            }
          }
          handleSetState(t, e) {
            this._setState(e.newState, e.options || {});
          }
          play(t = !1) {
            switch (this.runTimeInfo.state) {
              case "idle":
              case "paused":
              case "armed":
              case "transitional":
              case "blocked":
                if ("paused" === this.runTimeInfo.state) {
                  const t = new Date().getTime() - this.pauseMoment;
                  this.previousTimeStamp += t;
                }
                this._setState("playing"),
                  this.onPlay(),
                  t ||
                    window.requestAnimationFrame((t) => {
                      this.step(t);
                    });
            }
          }
          pause() {
            "playing" === this.runTimeInfo.state &&
              (this._setState("paused"),
              (this.pauseMoment = new Date().getTime()),
              this.onWait());
          }
          arm() {
            ("transitional" !== this.runTimeInfo.state &&
              "blocked" !== this.runTimeInfo.state) ||
              this._setState("armed");
          }
          complete() {
            this._setState("idle"), (this.previousTimeStamp = -1);
          }
          stop() {
            this._setState("transitional"), (this.previousTimeStamp = -1);
          }
          block(t = {}) {
            (x(t, "exception") && "playing" !== this.runTimeInfo.state) ||
              (this._setState("blocked", t), (this.previousTimeStamp = -1));
          }
          onPlay() {}
          onWait() {}
          playableProgress(t, e) {
            if (!this.isTheRootClip) return !1;
            for (const t in this.listeners) {
              const i = this.listeners[t];
              !0 !== i.onlyOnStateChange &&
                (Math.abs(
                  e + i.cavaDelta - this.runTimeInfo.currentMillisecond
                ) > i.threshold
                  ? (i.funct(
                      ((n = e), (s = i.roundTo), Math.round(n / s) * s),
                      this.runTimeInfo.state
                    ),
                    (i.cavaDelta = 0))
                  : (i.cavaDelta += Math.abs(
                      e - this.runTimeInfo.currentMillisecond
                    )));
            }
            var n, s;
            return (
              this.onProgress(t, e),
              (this.runTimeInfo.currentMillisecond = e),
              !0
            );
          }
          set executionSpeed(t) {
            this.isTheRootClip && (this.speed = parseFloat(t));
          }
          step(t, e = !1) {
            if ("playing" !== this.runTimeInfo.state) return;
            -1 === this.previousTimeStamp && (this.previousTimeStamp = t);
            const n = Math.round(
                this.runTimeInfo.currentMillisecond +
                  (t - this.previousTimeStamp) * this.speed
              ),
              s = n / this.duration;
            return s >= 1
              ? (this.playableProgress(1, this.duration), void this.complete())
              : s < 0
              ? (this.playableProgress(0, 0), void this.complete())
              : (this.playableProgress(s, n),
                (this.previousTimeStamp = t),
                void (e || window.requestAnimationFrame(this.step.bind(this))));
          }
          subscribe(t, e, n, s, i = !1) {
            n || (n = 0),
              s || (s = 1),
              (this.listeners[t] = {
                funct: e,
                threshold: n,
                roundTo: s,
                cavaDelta: 0,
                onlyOnStateChange: i,
              });
          }
          unsubscribe(t) {
            x(this.listeners, t) && delete this.listeners[t];
          }
          subscribeToDurationChange(t) {
            return (
              !!this.isTheRootClip &&
              (this.realClip.subscribeToDurationChange(t), !0)
            );
          }
        }
        var po = Object.defineProperty,
          ho = (t, e, n) => (
            ((t, e, n) => {
              e in t
                ? po(t, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: n,
                  })
                : (t[e] = n);
            })(t, "symbol" != typeof e ? e + "" : e, n),
            n
          );
        class mo {
          constructor() {
            ho(this, "gainNode"),
              ho(this, "input"),
              ho(this, "output"),
              ho(this, "pannerNode"),
              (this.output = m.createGain()),
              (this.gainNode = m.createGain()),
              m.createStereoPanner &&
                (this.pannerNode = m.createStereoPanner()),
              m.createStereoPanner
                ? (this.pannerNode.connect(this.gainNode),
                  this.gainNode.connect(this.output),
                  (this.input = this.pannerNode))
                : (this.gainNode.connect(this.output),
                  (this.input = this.gainNode));
          }
          connect(t) {
            this.output.connect(t);
          }
          disconnect() {
            this.output.disconnect();
          }
        }
        var fo = Object.defineProperty,
          go = (t, e, n) => (
            ((t, e, n) => {
              e in t
                ? fo(t, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: n,
                  })
                : (t[e] = n);
            })(t, "symbol" != typeof e ? e + "" : e, n),
            n
          );
        function yo(t) {
          const e = window.atob(t),
            n = e.length,
            s = new Uint8Array(n);
          for (let t = 0; t < n; t++) s[t] = e.charCodeAt(t);
          return s.buffer;
        }
        const vo = /\[data(-mcid="+\w+")+\]/g;
        class bo {
          constructor() {
            go(this, "subscribers"), (this.subscribers = []);
          }
          sub(t, e) {
            this.subscribers.push(e);
          }
          pub(t) {
            for (let e = 0; e < this.subscribers.length; e++)
              this.subscribers[e](t);
          }
        }
        class xo extends Rr {
          constructor(t = [], e) {
            super(),
              go(this, "totalSources"),
              go(this, "soundLoaded"),
              go(this, "audioSources"),
              (this.totalSources = t.length),
              (this.audioSources = {});
            for (let n = 0; n < t.length; n++) {
              const s = t[n],
                i = {
                  mcid: s.mcid || A(),
                  id: s.id,
                  src: s.src,
                  classes: s.classes || [],
                  base64: s.base64 || !1,
                  pubSub: new bo(),
                  soundLoaded: !1,
                  startValues: s.startValues || {},
                };
              if (
                ((this.audioSources[i.id] = i),
                (this.elementsByMCID[i.mcid] = i),
                s.base64)
              )
                m.decodeAudioData(yo(s.src), (t) => {
                  this._setBuffer(i, t, e);
                });
              else {
                const t = new XMLHttpRequest();
                t.open("GET", i.src, !0),
                  (t.responseType = "arraybuffer"),
                  (this.soundLoaded = !1),
                  (t.onload = () => {
                    m.decodeAudioData(
                      t.response,
                      (t) => {
                        this._setBuffer(i, t, e);
                      },
                      this.onError
                    );
                  }),
                  t.send();
              }
            }
            this.setContext({
              contextLoaded: !0,
              audio: !0,
              document,
              window,
              rootElement: document.body,
              unmount: L,
              masterNode: e,
              audioContext: m,
            });
          }
          _setBuffer(t, e, n) {
            var s;
            (t.soundLoaded = !0),
              (t.buffer = e),
              (t.audioNodeSet = new mo()),
              t.audioNodeSet.connect(n.input),
              null == (s = t.pubSub) || s.pub();
          }
          getElementByMCID(t) {
            return x(this.elementsByMCID, t) ? this.elementsByMCID[t] : null;
          }
          getElements(t) {
            if (!t.startsWith("~")) {
              if (vo.exec(t)) {
                const e = t.split('"')[1];
                return [this.elementsByMCID[e]];
              }
              return [];
            }
            if ((t = t.substring(1)).startsWith("#"))
              return x(this.audioSources, t.substring(1))
                ? [this.audioSources[t.substring(1)]]
                : [];
            if (!t.startsWith(".")) return [];
            const e = t.substring(1),
              n = [];
            for (const t in this.audioSources)
              t.classes.indexOf(e) >= 0 && n.push(t);
            return n;
          }
          getMCID(t) {
            return t.mcid;
          }
          setMCID(t, e) {
            t.mcid = e;
          }
          getElementSelectorByMCID(t) {
            return `[data-mcid="${t}"]`;
          }
        }
        var wo = Object.defineProperty,
          Co = (t, e, n) => (
            ((t, e, n) => {
              e in t
                ? wo(t, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: n,
                  })
                : (t[e] = n);
            })(t, "symbol" != typeof e ? e + "" : e, n),
            n
          );
        class Io extends Dr {
          constructor(t, e) {
            super(t, e),
              Co(this, "audioNodeSet"),
              Co(this, "parentClipContext"),
              (this.audioNodeSet = new mo()),
              this.audioNodeSet.connect(m.destination);
            const n = new xo(this.props.audioSources, this.audioNodeSet)
              .context;
            (n.initParams = e.initParams), (this.ownContext = n);
          }
          handleRecalcDuration(t, e) {
            return (
              !!super.handleRecalcDuration(t, e) &&
              !!this.putMessageOnPipe(
                "recalcDuration",
                e.childId ? { childId: this.id } : {},
                "Groups",
                { selfExecute: !1, direction: Z._UP }
              ).response
            );
          }
          onProgress(t, e, n, s = !1) {
            if (e > this.duration)
              return super.onProgress(1, this.duration, this.id, s);
            const i = this.delay + this.calculatedDuration + this.hiatus;
            let r = 0 === i ? 0 : e % i;
            0 !== e && 0 === r && (r = this.delay + this.calculatedDuration);
            let o = r - this.delay;
            if (o < 0) return;
            o > this.calculatedDuration && (o = this.calculatedDuration);
            const a =
              0 === this.calculatedDuration ? 0 : o / this.calculatedDuration;
            super.onProgress(a, o, this.id, s);
          }
          _onGetContextOnce(t) {
            var e;
            this.audioNodeSet.disconnect(),
              (this.parentClipContext = t),
              this.audioNodeSet.connect(
                null == (e = t.masterNode) ? void 0 : e.input
              );
          }
          lastWish() {
            this.audioNodeSet.output.disconnect(),
              this.audioNodeSet.output.connect(m.destination);
          }
          get volume() {
            return this.audioNodeSet.output.gain.value;
          }
          set volume(t) {
            this.audioNodeSet.output.gain.value = t;
          }
        }
        var Po = Object.defineProperty,
          Eo = (t, e, n) => (
            ((t, e, n) => {
              e in t
                ? Po(t, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: n,
                  })
                : (t[e] = n);
            })(t, "symbol" != typeof e ? e + "" : e, n),
            n
          );
        class ko extends Zr {
          constructor(t = {}) {
            super(t),
              Eo(this, "removeDOMTimeout"),
              Eo(this, "rendered"),
              (this.context.fragment = !0),
              (this.rendered = !1),
              (this.removeDOMTimeout = null);
          }
          get targetHost() {
            return (
              this._targetHost ||
                ((this._targetHost = document.createElement("div")),
                (this._targetHost.style.zIndex = "-1"),
                (this._targetHost.style.width = "0px"),
                (this._targetHost.style.height = "0px"),
                (this._targetHost.style.overflow = "hidden"),
                (this._targetHost.style.position = "relative")),
              this._targetHost
            );
          }
          checkProps() {
            return v(this.props)
              ? (x(this.props, "html") || (this.props.html = ""),
                x(this.props, "css") || (this.props.css = ""),
                !0)
              : (j.error(
                  `HTMLFragmentContextHandler expects an object on its constructor. ${typeof this
                    .props} passed`
                ),
                !1);
          }
          renderOnDOM() {
            this.removeDOMTimeout && clearTimeout(this.removeDOMTimeout),
              this.rendered ||
                (document.body.append(this._targetHost), (this.rendered = !0));
          }
          removeFromDOM() {
            this.removeDOMTimeout && clearTimeout(this.removeDOMTimeout),
              (this.removeDOMTimeout = setTimeout(() => {
                try {
                  document.body.removeChild(this._targetHost),
                    (this.rendered = !1);
                } catch (t) {
                  j.info(
                    "Clip's DOM element was not found and thus not removed from DOM"
                  );
                }
              }, 50));
          }
        }
        var So = Object.defineProperty,
          Oo = Object.defineProperties,
          Mo = Object.getOwnPropertyDescriptors,
          Ao = Object.getOwnPropertySymbols,
          _o = Object.prototype.hasOwnProperty,
          To = Object.prototype.propertyIsEnumerable,
          Do = (t, e, n) =>
            e in t
              ? So(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (t[e] = n),
          Bo = (t, e) => {
            for (var n in e || (e = {})) _o.call(e, n) && Do(t, n, e[n]);
            if (Ao) for (var n of Ao(e)) To.call(e, n) && Do(t, n, e[n]);
            return t;
          },
          Lo = (t, e) => Oo(t, Mo(e)),
          jo = (t, e, n) => (Do(t, "symbol" != typeof e ? e + "" : e, n), n);
        class Vo extends Dr {
          constructor(t = {}, e = null, n) {
            let s = t,
              i = e;
            null == i && ((s = {}), (i = t)),
              super(s, i, n),
              jo(this, "contextHandler"),
              jo(this, "html"),
              jo(this, "css"),
              jo(this, "fonts"),
              (i.html = x(i, "html") ? i.html : this.html),
              (i.css = x(i, "css") ? i.css : this.css),
              (i.fonts = x(i, "fonts") ? i.fonts : this.fonts);
            const r = new ko(i);
            (this.ownContext = Lo(Bo({}, r.context), { isHostedClip: !1 })),
              (this.iframe = r.iframeElement),
              (this.contextHandler = r),
              this.onDOMCLipInitialise();
          }
          exportConstructionArguments() {
            return {
              attrs: this.attrs,
              props: Lo(Bo({}, this.props), {
                html: this.context.rootElement.innerHTML,
              }),
            };
          }
          onDOMCLipInitialise() {}
          get rootElement() {
            return this.context.rootElement;
          }
          renderOnDOM() {
            this.contextHandler.renderOnDOM();
          }
          removeFromDOM() {
            this.contextHandler.removeFromDOM();
          }
        }
        var No = Object.defineProperty,
          $o = (t, e, n) => (
            ((t, e, n) => {
              e in t
                ? No(t, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: n,
                  })
                : (t[e] = n);
            })(t, "symbol" != typeof e ? e + "" : e, n),
            n
          );
        class Ro {
          constructor() {
            $o(this, "isNullClip"),
              $o(this, "context", {}),
              (this.isNullClip = !0);
          }
          get duration() {
            return 0;
          }
          set duration(t) {}
          addIncident() {
            return H;
          }
          moveIncident() {
            return H;
          }
          removeIncident() {
            return H;
          }
          resizeIncident() {
            return H;
          }
          getIncidentsByChannel() {
            return {};
          }
          flash() {}
          _resize() {}
          onProgress() {}
          renderOnDOM() {}
          removeFromDOM() {}
          get volume() {
            return 0;
          }
          set volume(t) {}
          setVolume() {}
        }
        var Fo = Object.defineProperty,
          zo = Object.defineProperties,
          Xo = Object.getOwnPropertyDescriptors,
          Ho = Object.getOwnPropertySymbols,
          Yo = Object.prototype.hasOwnProperty,
          Uo = Object.prototype.propertyIsEnumerable,
          Wo = (t, e, n) =>
            e in t
              ? Fo(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (t[e] = n),
          qo = (t, e, n) => (Wo(t, "symbol" != typeof e ? e + "" : e, n), n);
        class Go {
          constructor(t) {
            qo(this, "id"),
              qo(this, "ownClip"),
              qo(this, "realClip"),
              qo(this, "runTimeInfo"),
              (this.runTimeInfo = {
                currentMillisecond: 0,
                state: "transitional",
              }),
              (this.id = A()),
              (this.realClip = t.descriptiveIncident.realClip);
            const e =
                t.descriptiveIncident.realClip.exportConstructionArguments(),
              n =
                ((s = ((t, e) => {
                  for (var n in e || (e = {})) Yo.call(e, n) && Wo(t, n, e[n]);
                  if (Ho) for (var n of Ho(e)) Uo.call(e, n) && Wo(t, n, e[n]);
                  return t;
                })({}, e.props)),
                (i = { selector: void 0, host: t.host, id: this.id }),
                zo(s, Xo(i)));
            var s, i;
            (this.ownClip = new t.descriptiveIncident.constructor.Incident(
              e.attrs,
              n
            )),
              t.descriptiveIncident.realClip.addContext(
                {
                  clipId: this.id,
                  context: this.ownClip.context,
                  synchronize: t.synchronize,
                  runTimeInfo: this.runTimeInfo,
                },
                !0
              );
          }
          onProgress(t, e, n = !1) {
            for (const t in this.realClip.instantiatedChannels)
              this.realClip.instantiatedChannels[t].moveTo(
                this.runTimeInfo.currentMillisecond,
                e,
                this.id,
                !0
              );
            this.runTimeInfo.currentMillisecond = e;
          }
        }
        var Zo = Object.defineProperty,
          Ko = Object.defineProperties,
          Jo = Object.getOwnPropertyDescriptors,
          Qo = Object.getOwnPropertySymbols,
          ta = Object.prototype.hasOwnProperty,
          ea = Object.prototype.propertyIsEnumerable,
          na = (t, e, n) =>
            e in t
              ? Zo(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (t[e] = n),
          sa = (t, e) => {
            for (var n in e || (e = {})) ta.call(e, n) && na(t, n, e[n]);
            if (Qo) for (var n of Qo(e)) ea.call(e, n) && na(t, n, e[n]);
            return t;
          },
          ia = (t, e, n) => (na(t, "symbol" != typeof e ? e + "" : e, n), n);
        function ra(t, e, n) {
          const s = t.realClip[e](n),
            i = t.audioClip[e](n);
          return s.result && i.result
            ? (s.execute(),
              i.execute(),
              t.putMsgOnPipeWithResult("flash", {}, "RootClip", {
                selfExecute: !0,
                direction: Z._UP,
              }))
            : s;
        }
        class oa extends uo {
          constructor(t, e = null) {
            let n = t,
              s = e;
            if (
              (null === s && ((n = {}), (s = t)),
              super(n, s),
              ia(this, "mustHaveNullClip"),
              ia(this, "initParams"),
              ia(this, "volumeChangeSubsribers", {}),
              ia(this, "audio"),
              ia(this, "audioClip"),
              ia(this, "statusBeforeBlock"),
              ia(this, "nonBlockingErrorClip"),
              (this.mustHaveNullClip = !1),
              (this.initParams = s.initParams || {}),
              x(s, "initParamsValidationRules"))
            ) {
              const t = (function (t, e, n = "Error on validation") {
                try {
                  const s = Yi(t)(e);
                  if (!0 === s) return { result: !0 };
                  let i = `${n}:`;
                  for (let t = 0; t < s.length; t++) {
                    const e = s[t];
                    i += `\n - ${e.message}. ${e.actual} provided`;
                  }
                  return j.error(i), { result: !1, errors: s };
                } catch (t) {
                  const e = `${n}. Invalid schema provided`;
                  return j.error(e), { result: !1, errors: [e] };
                }
              })(
                s.initParamsValidationRules,
                this.initParams,
                "Error on initParams validation"
              );
              if (!t.result)
                return (
                  j.error(
                    "Clip initParams validation failed. Switching to non-blocking blank Clip"
                  ),
                  (i = t.errors),
                  new Proxy(this, {
                    get: function (t, e) {
                      return b(t[e])
                        ? ao
                        : "nonBlockingErrorClip" === e ||
                            ("errors" === e ? i : t[e]);
                    },
                  })
                );
            }
            var i;
            const r = V({ props: this.props }, yr, this.constructor);
            if (!r.result) return r;
            (this.attributesStaggers = []), (this.propsStaggers = []);
            const o = this.setupDynamicValues();
            (this.isTheRootClip = !1), (this.volumeChangeSubsribers = {});
            const a = {
              id: this.id,
              attrs: n,
              props:
                ((l = sa({}, s)),
                (c = {
                  html: x(s, "html") ? s.html : this.html,
                  css: x(s, "css") ? s.css : this.css,
                  fonts: x(s, "fonts") ? s.fonts : this.fonts,
                  runTimeInfo: this.runTimeInfo,
                  subscribe: this.subscribe.bind(this),
                  repeats: 1,
                  delay: 0,
                  hiatus: 0,
                }),
                Ko(l, Jo(c))),
              plugin_npm_name: this.constructor.plugin_npm_name,
              Channel: this.constructor.Channel,
              DescriptiveIncident: this,
            };
            var l, c;
            if (
              ((this.audio = "on"),
              x(sa({}, this.constructor), "audio") &&
                (this.audio = this.constructor.audio),
              x(s, "audio") && (this.audio = s.audio),
              x(s, "selector") &&
                void 0 !== s.selector &&
                !0 !== this.constructor.customClip)
            )
              a.Incident = Vo;
            else if (
              x(s, "selector") &&
              void 0 !== s.selector &&
              !0 === this.constructor.customClip
            ) {
              delete a.props.selector;
              const t = new Vo({
                html: '<div id="clip-container"></div>',
                css: "",
                fonts: [],
              });
              (a.props.host = t.rootElement),
                (a.Incident = this.constructor.Incident);
            } else
              "only" === this.audio && !0 !== this.props.root
                ? (this.isTheRootClip = !1)
                : ((this.isTheRootClip = !0),
                  (this.blockingWaitings = {}),
                  (a.Incident = this.constructor.Incident));
            if ("on" === this.audio || "only" === this.audio) {
              const t = {
                id: this.id,
                attrs: {},
                props: {
                  audioSources: x(s, "audioSources")
                    ? s.audioSources
                    : this.audioSources,
                  runTimeInfo: this.runTimeInfo,
                  subscribe: this.subscribe.bind(this),
                  hiatus: this.hiatus,
                  delay: this.delay,
                  repeats: this.repeats,
                  initParams: this.initParams,
                },
                plugin_npm_name: this.constructor.plugin_npm_name,
                Channel: this.constructor.Channel,
                Incident: Io,
                DescriptiveIncident: this,
              };
              x(s, "audioSources") &&
                (t.props.audioSources = this.resolveAudioSources(
                  s.audioSources
                )),
                (this.audioClip = Ct(t));
            } else (this.audio = "off"), (this.audioClip = new Ro());
            "only" === this.audio
              ? (this.realClip = new Ro())
              : !this.isTheRootClip &&
                (x(o.attrs, "expression") ||
                  x(o.props, "expression") ||
                  x(o.attrs, "initParams") ||
                  x(o.props, "initParams"))
              ? ((this.mustHaveNullClip = !0), (this.realClip = new Ro()))
              : (this.realClip = Ct(a, !0)),
              (this.dynamicDurationValue = null),
              (this.passiveAddition = !0),
              this._buildTree(),
              (this.passiveAddition = !1),
              this.constructor.isAnimation &&
                x(this.props, "duration") &&
                this.resize(this.duration);
          }
          get selectorToPassToChildren() {
            return null;
          }
          get inheritedSelector() {
            return this._inheritedSelector;
          }
          set inheritedSelector(t) {
            this._inheritedSelector = t;
          }
          get html() {
            return "";
          }
          get css() {
            return "";
          }
          get fonts() {
            return [];
          }
          get audioSources() {
            return [];
          }
          resolveAudioSources(t) {
            const e = w(t);
            for (let t = 0; t < this.propsStaggers.length; t++) {
              const n = this.propsStaggers[t];
              0 === n.path.indexOf("audioSources") &&
                B(
                  e,
                  n.path.replace("audioSources.", ""),
                  n.stagger.calculateValues([0], this.initParams)[0]
                );
            }
            return e;
          }
          detachFromParent() {
            super.detachFromParent(),
              this.mustHaveNullClip && (this.realClip = new Ro());
          }
          get duration() {
            return null !== this.dynamicDurationValue
              ? this.dynamicDurationValue
              : this.propsStaggers.length > 0 && !this.isTheRootClip
              ? "dynamic"
              : x(this.props, "duration")
              ? this.repeats * (this.delay + this.props.duration + this.hiatus)
              : super.duration;
          }
          set duration(t) {
            if (0 != this.propsStaggers.length) {
              for (let e = 0; e < this.propsStaggers.length; e++) {
                if ("repeats" === this.propsStaggers[e].path) continue;
                const n = this.propsStaggers[e].stagger.resize(
                  t / this.duration
                );
                B(this.props, this.propsStaggers[e].path, n);
              }
              this.dynamicDurationValue = t;
            } else super.duration = t;
          }
          systoleDiastole(t) {
            this.constructor.isAnimation &&
              (this.props.duration
                ? (this.props.duration *= t)
                : (this.props.duration = t * this.calculatedDuration)),
              this.realClip._resize(t),
              super.systoleDiastole(t);
          }
          exportLiveDefinition(t = !0) {
            const e = super.exportLiveDefinition(t);
            return (
              this.constructor.isAnimation &&
                (e.props.duration = this.props.duration
                  ? this.props.duration
                  : this.calculatedDuration),
              b(this.props.html) && (e.props.html = this.props.html),
              b(this.props.css) && (e.props.css = this.props.css),
              e
            );
          }
          _buildTree() {
            null != this.realClip && this.buildTree();
          }
          resize(t) {
            if ("dynamic" === this.duration) return { result: !1, reason: It };
            const e = t / this.duration;
            return (
              this.realClip._resize(e),
              this.audioClip._resize(e),
              (this.duration = t),
              this.constructor.isAnimation &&
                (this.props.duration
                  ? (this.props.duration *= e)
                  : (this.props.duration = this.calculatedDuration)),
              this.putMessageOnPipe("recalcDuration", {}, "Groups", {
                selfExecute: !1,
                direction: Z._UP,
              }),
              this.putMsgOnPipeWithResult("flash", {}, "RootClip", {
                selfExecute: !0,
                direction: Z._UP,
              })
            );
          }
          manageEditAttrProps(t, e) {
            return {
              result: !1,
              errors: ["Clips attributes and properties can not be edited"],
            };
          }
          handleCheckForClip(t, e) {
            return !0;
          }
          handleGetElements(t, e) {
            return this.realClip.getElements(e.selector);
          }
          handleCheckAddition(t, e) {
            var n;
            this.isTheRootClip ||
              "only" === this.audio ||
              !0 === this.constructor.customClip ||
              this.realClip.renderOnDOM();
            let s = this.realClip.addIncident(e);
            const i = this.audioClip.addIncident(e);
            return (
              s.result &&
                i.result &&
                (s.execute(),
                null == (n = i.execute) || n.call(i),
                (s = this.putMsgOnPipeWithResult("flash", {}, "RootClip", {
                  selfExecute: !0,
                  direction: Z._UP,
                }))),
              this.isTheRootClip ||
                "only" === this.audio ||
                !0 === this.constructor.customClip ||
                this.realClip.removeFromDOM(),
              s
            );
          }
          handleCheckMove(t, e) {
            return ra(this, "moveIncident", e);
          }
          handleCheckDeletion(t, e) {
            return ra(this, "removeIncident", e);
          }
          handleCheckResize(t, e) {
            return ra(this, "resizeIncident", e);
          }
          handleFlash(t, e) {
            return this.isTheRootClip ? this.flash() : this.bypass();
          }
          exportDefinition() {
            const t = super.exportDefinition();
            return (
              this.constructor.isAnimation &&
                (t.props.duration = this.props.duration
                  ? this.props.duration
                  : this.calculatedDuration),
              t
            );
          }
          handleSetBlock(t, e) {
            if (!this.isTheRootClip) return this.bypass();
            if ("transitional" === this.runTimeInfo.state) return;
            "blocked" !== this.runTimeInfo.state &&
              (this.statusBeforeBlock = this.runTimeInfo.state),
              (this.blockingWaitings[e.id] = e);
            const n = {};
            e.options.exceptional && (n.exception = e.incidentId);
            const s = this;
            setTimeout(() => {
              s.block(n);
            }, 0);
          }
          handleUnBlock(t, e) {
            if (!this.isTheRootClip) return this.bypass();
            x(this.blockingWaitings, e.id) &&
              (delete this.blockingWaitings[e.id],
              0 === Object.keys(this.blockingWaitings).length &&
                ("playing" === this.statusBeforeBlock
                  ? ((this.previousTimeStamp = -1), this.play())
                  : this.arm()));
          }
          stop() {
            super.stop(), (this.blockingWaitings = {});
          }
          onProgress(t, e) {
            this.realClip.onProgress(t, e), this.audioClip.onProgress(t, e);
          }
          paste(t) {
            return this.isTheRootClip
              ? new Go({ host: t, descriptiveIncident: this })
              : null;
          }
          flash() {
            this.realClip.flash(), this.audioClip.flash();
          }
          get volume() {
            return "off" === this.audio ? 0 : this.audioClip.volume;
          }
          setVolume(t) {
            if ("off" === this.audio)
              return {
                result: !1,
                errors: [{ type: "can not set volume of Clip with audio off" }],
              };
            if (t < 0 || t > 1)
              return {
                result: !1,
                errors: [{ type: "invalid volume number" }],
              };
            this.audioClip.volume = t;
            for (const e in this.volumeChangeSubsribers)
              this.volumeChangeSubsribers[e](t);
            return { result: !0 };
          }
          attachMediaElementSource(t) {
            var e, n;
            "off" !== this.audio &&
              (null == (n = this.audioClip.context.audioContext) ||
                n
                  .createMediaElementSource(t)
                  .connect(
                    null == (e = this.audioClip.context.masterNode)
                      ? void 0
                      : e.input
                  ));
          }
          volumeChangeSubscribe(t, e) {
            return this.putMessageOnPipe(
              "volumeChangeSubscribe",
              { type: "subscribe", id: t, funct: e },
              "RootClip",
              { selfExecute: !0, direction: Z._UP }
            ).response;
          }
          volumeChangeUnsubscribe(t) {
            return (
              this.putMessageOnPipe(
                "volumeChangeSubscribe",
                { type: "unsubscribe", id: t },
                "RootClip",
                { selfExecute: !0, direction: Z._UP }
              ),
              0
            );
          }
          handleVolumeChangeSubscribe(t, e) {
            if (!this.isTheRootClip) return this.bypass();
            switch (e.type) {
              case "subscribe":
                return (
                  (this.volumeChangeSubsribers[e.id] = e.funct), this.volume
                );
              case "unsubscribe":
                return delete this.volumeChangeSubsribers[e.id], 0;
            }
            return !1;
          }
        }
        ia(oa, "isClip", !0),
          ia(oa, "Incident", oo),
          ia(oa, "plugin_npm_name", "@donkeyclip/self-contained-incidents"),
          ia(oa, "version", xr),
          ia(oa, "Channel", q),
          ia(oa, "ClassName", "HTMLClip"),
          ia(oa, "propsValidationRules", yr);
        class aa extends oa {
          constructor(t, e = null) {
            let n = t,
              s = e;
            null === e && x(t, "audioSources")
              ? ((n = {}), (s = t))
              : null === e && (s = {}),
              (s.audio = "only"),
              super(n, s);
          }
        }
        var la = Object.defineProperty,
          ca = (t, e, n) => (
            ((t, e, n) => {
              e in t
                ? la(t, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: n,
                  })
                : (t[e] = n);
            })(t, "symbol" != typeof e ? e + "" : e, n),
            n
          );
        class ua extends q {
          constructor(t) {
            super(t),
              ca(this, "playingIncidentsIds"),
              ca(this, "transitioned"),
              (this.playingIncidentsIds = []),
              (this.transitioned = !1),
              t.subscribe(A(), this._stateChange.bind(this), 0, 1, !0);
          }
          _stateChange(t, e, n = {}) {
            ("paused" !== e && "idle" !== e && "blocked" !== e) ||
              (this._stopPlayingIncidents(n), (this.transitioned = !0));
          }
          _stopPlayingIncidents(t = {}) {
            for (let e = 0; e < this.playingIncidentsIds.length; e++) {
              const n = this.playingIncidentsIds[e].split("|||");
              n[0].startsWith(t.exception) ||
                this._incidentById(n[0]).stop(n[1]);
            }
            this.playingIncidentsIds = [];
          }
          moveTo(t, e, n, s = !1) {
            const i = this.incidents;
            if ("transitional" === this.runTimeInfo.state || s) {
              (this.transitioned = !0), this._stopPlayingIncidents();
              for (let t = 0; t < i.length; t++) {
                const { id: s, millisecond: r } = i[t],
                  o = this._incidentById(s);
                let a;
                (a = e < r ? 0 : e > r + o.duration ? o.duration : e - r),
                  o.onProgress(a, n, !0);
              }
              return;
            }
            this.transitioned && ((t = 0), (this.transitioned = !1));
            const r = t > e;
            for (let s = 0; s < i.length; s++) {
              const o = i[s],
                a = o.millisecond,
                l = this._incidentById(o.id),
                c = l.duration,
                u = a + c,
                p = `${o.id}|||${n}`;
              if ((u > t && u <= e) || r) {
                l.stop(n);
                const t = this.playingIncidentsIds.indexOf(p);
                t > -1 && this.playingIncidentsIds.splice(t, 1);
              }
              if (a >= (r ? 0 : t) && a < e && u > e) {
                const t = (e - a) / c >= 1,
                  s = t ? c : e - a,
                  i = t ? 1 : s / c;
                l.play(i, s, n) && this.playingIncidentsIds.push(p);
              }
            }
            this.runTimeInfo.currentMillisecond = e;
          }
        }
        var pa = Object.defineProperty,
          ha = (t, e, n) => (
            ((t, e, n) => {
              e in t
                ? pa(t, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: n,
                  })
                : (t[e] = n);
            })(t, "symbol" != typeof e ? e + "" : e, n),
            n
          );
        class da extends et {
          constructor(t = {}, e = {}, n) {
            super(),
              ha(this, "attrs"),
              ha(this, "autoGenerated"),
              ha(this, "context"),
              ha(this, "dna"),
              ha(this, "gotContext"),
              ha(this, "hasIncidents"),
              ha(this, "mcid"),
              ha(this, "modelId"),
              ha(this, "plugin_channel_class"),
              ha(this, "props"),
              (this.attrs = t),
              (this.props = e),
              (this.dna = n),
              (this.context = n.context),
              (this.mcid = n.mcid),
              (this.id = e.id || A()),
              (this.modelId = e.modelId),
              (this.gotContext = !1),
              (this.plugin_channel_class = ua),
              (this.mc_plugin_npm_name = "motor-cortex-js-media-playback"),
              x(e, "plugin_channel_class") &&
                (this.plugin_channel_class = e.plugin_channel_class),
              x(e, "mc_plugin_npm_name") &&
                (this.mc_plugin_npm_name = e.mc_plugin_npm_name),
              (this.hasIncidents = !1),
              (this.autoGenerated = !1),
              this.onInitialise(t, e);
          }
          get selector() {
            return this.props.selector;
          }
          get element() {
            return this.context.getElementByMCID(this.mcid);
          }
          _onGetContextOnce() {
            if (!this.context.fragment)
              try {
                this.gotContext ||
                  (this.onGetContext(), (this.gotContext = !0));
              } catch (t) {
                j.error(t, this.mcid);
              }
          }
          onGetContext() {
            j.info(
              'Overwrite the "onGetContext" method with the code you want to get executed',
              "info"
            );
          }
          lastWish() {}
          onInitialise(t, e) {
            j.info(
              'Overwrite the "onInialise" method with the code you want to get executed',
              "info"
            );
          }
          onProgress(t) {}
          play(t) {
            return !0;
          }
          stop() {}
        }
        var ma = Object.defineProperty;
        const fa = {
            npm_name: "@donkeyclip/motorcortex-soundsystem",
            name: "Internal MotorCortex Soundsystem",
            incidents: [
              {
                exportable: class extends da {
                  constructor() {
                    super(...arguments),
                      ((t, e, n) => {
                        ((t, e, n) => {
                          e in t
                            ? ma(t, e, {
                                enumerable: !0,
                                configurable: !0,
                                writable: !0,
                                value: n,
                              })
                            : (t[e] = n);
                        })(this, e + "", void 0);
                      })(0, "audioNode");
                  }
                  play(t) {
                    if (!this.element.soundLoaded)
                      return (
                        this.setBlock("loading sound"),
                        this.element.pubSub.sub(this.id, () => {
                          this.unblock();
                        }),
                        !1
                      );
                    let e = 0;
                    return (
                      x(this.props, "startFrom") && (e = this.props.startFrom),
                      (this.audioNode = m.createBufferSource()),
                      (this.audioNode.buffer = this.element.buffer),
                      this.audioNode.connect(this.element.audioNodeSet.input),
                      this.audioNode.start(0, (t + e) / 1e3),
                      !0
                    );
                  }
                  stop() {
                    this.audioNode && this.audioNode.stop();
                  }
                },
                name: "AudioPlayback",
              },
              {
                exportable: class extends it {
                  onProgress(t) {
                    const e = this.getFraction(t);
                    if (!this.element.soundLoaded)
                      return (
                        this.setBlock("loading sound"),
                        this.element.pubSub.sub(this.id, () => {
                          this.unblock();
                        }),
                        !1
                      );
                    const n =
                      (this.targetValue - this.initialValue) * e +
                      this.initialValue;
                    switch (this.attributeKey) {
                      case "gain":
                        this.element.audioNodeSet.gainNode.gain.value = n;
                        break;
                      case "pan":
                        this.element.audioNodeSet.pannerNode.pan.value = n;
                    }
                    return !0;
                  }
                  getScratchValue() {
                    return "pan" === this.attributeKey
                      ? x(this.element.startValues, "pan")
                        ? this.element.startValues.pan
                        : 0
                      : "gain" === this.attributeKey
                      ? x(this.element.startValues, "gain")
                        ? this.element.startValues.gain
                        : 1
                      : void 0;
                  }
                },
                name: "AudioEffect",
              },
            ],
            Clip: { exportable: Io },
            audio: "only",
          },
          ga = "forwards",
          ya = "backwards";
        var va = Object.defineProperty,
          ba = Object.getOwnPropertySymbols,
          xa = Object.prototype.hasOwnProperty,
          wa = Object.prototype.propertyIsEnumerable,
          Ca = (t, e, n) =>
            e in t
              ? va(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (t[e] = n),
          Ia = (t, e, n) => (Ca(t, "symbol" != typeof e ? e + "" : e, n), n);
        class Pa {
          constructor() {
            Ia(this, "_bwExecutionSubscribers"),
              Ia(this, "_currentPeriod"),
              Ia(this, "_executionSubscribers"),
              Ia(this, "_nextIterationLanes"),
              Ia(this, "subPeriod"),
              (this._executionSubscribers = {}),
              (this._bwExecutionSubscribers = {}),
              (this.subPeriod = 10),
              (this._currentPeriod = {}),
              (this._nextIterationLanes = {});
          }
          reset() {
            (this._executionSubscribers = {}),
              (this._bwExecutionSubscribers = {}),
              (this._nextIterationLanes = {});
          }
          executionSubscribers(t, e) {
            const n =
              e === ga
                ? this._executionSubscribers
                : this._bwExecutionSubscribers;
            return null != n[t] || (n[t] = {}), n[t];
          }
          subscribe(t, e, n, s, i) {
            const r = this.executionSubscribers(t, e);
            null != r[n] || (r[n] = {}),
              (r[n][s] = () => {
                var e;
                null != (e = this._nextIterationLanes)[t] || (e[t] = {}),
                  (this._nextIterationLanes[t][s] = i);
              });
          }
          nextIterationLanes(t, e) {
            var n;
            return (
              null != (n = this._nextIterationLanes)[t] ||
                (n[t] = ((t, e) => {
                  for (var n in e || (e = {})) xa.call(e, n) && Ca(t, n, e[n]);
                  if (ba) for (var n of ba(e)) wa.call(e, n) && Ca(t, n, e[n]);
                  return t;
                })({}, e)),
              this._nextIterationLanes[t]
            );
          }
          setNextIterationLanes(t, e) {
            this._nextIterationLanes[t] = e;
          }
          currentPeriod(t) {
            var e;
            return (
              null != (e = this._currentPeriod)[t] || (e[t] = 0),
              this._currentPeriod[t]
            );
          }
          setCurrentPeriod(t, e) {
            this._currentPeriod[t] = e;
          }
        }
        function Ea(t, e, n, s, i = !1) {
          const r = e[t[s].id];
          r.setInitialValue(n, i);
          const o = (function (t, e, n, s) {
            let i = !1;
            const r = Object.keys(e);
            for (let t = 0; t < r.length; t++) {
              const o = r[t];
              x(n, o) || ((i = !0), (s[o] = e[o]));
            }
            return (t.animatedAttributeValue = s), i;
          })(
            r,
            r.initialValue,
            r.originalAnimatedAttributeValue,
            r.animatedAttributeValue
          );
          o && (r.lastWish(), r.onGetContext()),
            o &&
              s < t.length - 1 &&
              Ea(t, e, r.animatedAttributeValue, s + 1, !1);
        }
        var ka = Object.defineProperty,
          Sa = Object.getOwnPropertySymbols,
          Oa = Object.prototype.hasOwnProperty,
          Ma = Object.prototype.propertyIsEnumerable,
          Aa = (t, e, n) =>
            e in t
              ? ka(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (t[e] = n),
          _a = (t, e) => {
            for (var n in e || (e = {})) Oa.call(e, n) && Aa(t, n, e[n]);
            if (Sa) for (var n of Sa(e)) Ma.call(e, n) && Aa(t, n, e[n]);
            return t;
          },
          Ta = (t, e, n) => (Aa(t, "symbol" != typeof e ? e + "" : e, n), n);
        class Da {
          constructor(t = {}) {
            var e;
            Ta(this, "belongingLaneKeysByAnimationId"),
              Ta(this, "comboAttributes"),
              Ta(this, "incidentsById"),
              Ta(this, "lanes"),
              Ta(this, "lastAnimatedItemPerLane"),
              (this.lanes = t.lanes || {}),
              (this.lastAnimatedItemPerLane = {}),
              (this.comboAttributes = null != (e = t.comboAttributes) ? e : {}),
              (this.belongingLaneKeysByAnimationId =
                t.belongingLaneKeysByAnimationId || {}),
              (this.incidentsById = t.incidentsById || {});
          }
          _resize(t) {
            const e = Object.keys(this.lanes);
            for (let n = 0; n < e.length; n++) {
              const s = e[n],
                i = this.lanes[s];
              for (let e = 0; e < i.length; e++)
                i[e].millisecond = i[e].millisecond * t;
            }
          }
          createTestLanesSanbox() {
            const t = {
              lanes: wn(this.lanes),
              belongingLaneKeysByAnimationId: wn(
                this.belongingLaneKeysByAnimationId
              ),
              incidentsById: _a({}, this.incidentsById),
            };
            return (
              this.comboAttributes &&
                (t.comboAttributes = this.comboAttributes),
              new Da(t)
            );
          }
          getLane(t, e) {
            return this.lanes[_(t, e)];
          }
          applySandboxChanges(t) {
            (this.lanes = t.lanes.exportFlattened()),
              (this.belongingLaneKeysByAnimationId =
                t.belongingLaneKeysByAnimationId.exportFlattened()),
              (this.incidentsById = _a({}, t.incidentsById));
          }
          laneExists(t, e, n = !1) {
            const s = _(t, e);
            return (
              !!this.lanes.hasOwnProperty(s) ||
              (n && this.lanes.setValue(s, []), !1)
            );
          }
          getOverlappingAnims(
            { millisecond: t, incident: e },
            n,
            s,
            i = [],
            r = void 0
          ) {
            const o = this.lanes[_(n, s)];
            if (!o) return [];
            const a = [];
            for (let n = 0; n < o.length; n++) {
              const s = o[n],
                l = null != r ? r : e.duration,
                c = this.incidentsById[s.id].duration;
              s.id !== e.id &&
                !i.includes(s.id) &&
                ((s.millisecond >= t && s.millisecond < l + t) ||
                  (s.millisecond + c > t && s.millisecond + c <= l + t) ||
                  (s.millisecond < t && s.millisecond + c > l + t)) &&
                a.push(s);
            }
            return a;
          }
          addElementToLane(t, e, n, s) {
            const i = [],
              r = _(t, e);
            this.incidentsById[s.id] = s;
            const o = { millisecond: n, id: s.id };
            this.laneExists(t, e, !0),
              this.lanes.pushValue(r, o),
              this.lanes[r].sortBy("millisecond");
            const a = Array.from(this.lanes[r]),
              l = a.findIndex((t) => t.id === s.id);
            if (
              (x(s.id)
                ? this.belongingLaneKeysByAnimationId.pushValue(s.id, r)
                : this.belongingLaneKeysByAnimationId.setValue(s.id, [r]),
              0 === l)
            )
              if (a.length > 1) {
                const t = this.incidentsById[a[1].id].pureInitialValues;
                i.push(() => {
                  s.setInitialValue(t);
                });
              } else
                i.push(() => {
                  s.setInitialValue();
                });
            else
              i.push(() => {
                const t =
                  this.incidentsById[a[l - 1].id].animatedAttributeValue;
                s.setInitialValue(t);
              });
            if (
              (x(this.comboAttributes, e) &&
                i.push(() => {
                  Ea(a, this.incidentsById, s.initialValue, l);
                }),
              l + 1 < a.length)
            ) {
              const t = a[l + 1].id;
              i.push(() => {
                this.incidentsById[t].setInitialValue(s.animatedAttributeValue),
                  this.incidentsById[t].gotContext &&
                    (this.incidentsById[t].lastWish(),
                    this.incidentsById[t].onGetContext());
              });
            }
            return i;
          }
          updateLane(t, e) {
            const n = {},
              s = this;
            for (let e = 0; e < t.length; e++) {
              const i = this.belongingLaneKeysByAnimationId[t[e]];
              for (let r = 0; r < i.length; r++) {
                const o = i[r];
                x(n, o) ||
                  (n[o] = {
                    animations: [],
                    lane: s.lanes[o],
                    laneData: O(i[r]),
                  }),
                  n[o].animations.push(t[e]);
              }
            }
            for (const t in n) {
              const { laneData: s, lane: i, animations: r } = n[t],
                o = [...i];
              o.sort((t, e) => t.millisecond - e.millisecond);
              const a = x(this.comboAttributes, s.attribute);
              for (let t = 0; t < i.length; t++)
                r.includes(i[t].id) && (i[t].millisecond += e);
              i.sort((t, e) => t.millisecond - e.millisecond),
                (this.lanes[t] = i);
              for (let t = 0; t < r.length; t++) {
                const e = r[t],
                  n = o.findIndex((t) => t.id === e),
                  s = i.findIndex((t) => t.id === e);
                if (n === s && s <= 1) continue;
                const l = this.incidentsById[i[s].id];
                if (n + 1 < i.length)
                  if (0 === n)
                    if (a)
                      Ea(i, this.incidentsById, l.pureInitialValues, 0, !0);
                    else {
                      const t = this.incidentsById[o[1].id];
                      t.setInitialValue(l.pureInitialValues), t.onGetContext();
                    }
                  else if (a) {
                    const t = s > n ? n : s;
                    Ea(
                      i,
                      this.incidentsById,
                      this.incidentsById[o[n - 1].id].animatedAttributeValue,
                      t,
                      !0
                    );
                  } else
                    this.incidentsById[o[n + 1].id].setInitialValue(
                      this.incidentsById[o[n - 1].id].animatedAttributeValue
                    ),
                      this.incidentsById[o[n + 1].id].onGetContext();
                if (
                  (0 === s
                    ? a
                      ? Ea(
                          i,
                          this.incidentsById,
                          this.incidentsById[o[0].id].pureInitialValues,
                          s,
                          !0
                        )
                      : (l.setInitialValue(
                          this.incidentsById[o[0].id].pureInitialValues
                        ),
                        l.onGetContext())
                    : a
                    ? Ea(
                        i,
                        this.incidentsById,
                        this.incidentsById[i[s - 1].id].animatedAttributeValue,
                        s,
                        !0
                      )
                    : (l.setInitialValue(
                        this.incidentsById[i[s - 1].id].animatedAttributeValue
                      ),
                      l.onGetContext()),
                  s + 1 >= i.length)
                )
                  continue;
                if (a) {
                  Ea(
                    i,
                    this.incidentsById,
                    l.animatedAttributeValue,
                    s + 1,
                    !0
                  );
                  continue;
                }
                const c = this.incidentsById[i[s + 1].id];
                c.setInitialValue(l.animatedAttributeValue), c.onGetContext();
              }
            }
          }
          deleteAnimations(t) {
            const e = {};
            for (let n = 0; n < t.length; n++) {
              const s = t[n],
                i = this.belongingLaneKeysByAnimationId[s];
              for (let t = 0; t < i.length; t++) {
                let n = this.lanes[i[t]],
                  r = -1;
                for (let t = 0; t < n.length; t++)
                  if (n[t].id === s) {
                    r = t;
                    break;
                  }
                const o = _a({}, n[r]),
                  a = this.incidentsById[o.id],
                  l = O(i[t]),
                  c = [];
                for (let t = 0; t < n.length; t++)
                  n[t].id !== s && c.push(n[t]);
                if (
                  ((this.lanes[i[t]] = c),
                  (n = this.lanes[i[t]]),
                  0 === n.length)
                ) {
                  a.onProgress(0),
                    delete this.lanes[i[t]],
                    x(e, i[t]) && delete e[i[t]];
                  continue;
                }
                e[i[t]] = O(i[t]);
                const u = this.incidentsById[o.id].pureInitialValues;
                if (r >= n.length || !1 === u) continue;
                if (x(this.comboAttributes, l.attribute)) {
                  Ea(n, this.incidentsById, u, r, !0);
                  continue;
                }
                const p = this.incidentsById[n[r].id];
                p.setInitialValue(u), p.onGetContext();
              }
              delete this.belongingLaneKeysByAnimationId[t[n]];
            }
            return e;
          }
          recalcScratchValues(t) {
            const e = Object.keys(this.lanes);
            for (let n = 0; n < e.length; n++) {
              const s = e[n],
                i = this.lanes[s];
              if (i.length > 0) {
                const e = this.incidentsById[i[0].id],
                  n = e.getScratchValue(t),
                  r = O(s);
                x(this.comboAttributes, r.attribute)
                  ? Ea(i, this.incidentsById, n, 0, !0)
                  : e.setInitialValue(n),
                  e.lastWish(),
                  e.onGetContext();
              }
            }
          }
          getLastAffectedIndex(t, e, n) {
            return (
              this.lastAnimatedItemPerLane[t]
                ? (this.lastAnimatedItemPerLane[t][e] && !n) ||
                  (this.lastAnimatedItemPerLane[t][e] = [
                    0,
                    this.incidentsById[this.lanes[e][0].id].duration +
                      this.lanes[e][0].millisecond,
                  ])
                : (this.lastAnimatedItemPerLane[t] = {
                    [e]: [
                      0,
                      this.incidentsById[this.lanes[e][0].id].duration +
                        this.lanes[e][0].millisecond,
                    ],
                  }),
              this.lastAnimatedItemPerLane[t][e]
            );
          }
          setLastAffectedIndex(t, e, n) {
            this.lastAnimatedItemPerLane[t] ||
              (this.lastAnimatedItemPerLane[t] = {}),
              (this.lastAnimatedItemPerLane[t][e] = [
                n,
                this.incidentsById[this.lanes[e][n].id].duration +
                  this.lanes[e][n].millisecond,
              ]);
          }
        }
        var Ba = Object.defineProperty,
          La = Object.getOwnPropertySymbols,
          ja = Object.prototype.hasOwnProperty,
          Va = Object.prototype.propertyIsEnumerable,
          Na = (t, e, n) =>
            e in t
              ? Ba(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (t[e] = n),
          $a = (t, e) => {
            for (var n in e || (e = {})) ja.call(e, n) && Na(t, n, e[n]);
            if (La) for (var n of La(e)) Va.call(e, n) && Na(t, n, e[n]);
            return t;
          },
          Ra = (t, e, n) => (Na(t, "symbol" != typeof e ? e + "" : e, n), n);
        function Fa(t) {
          if (t) {
            const e = Object.keys(t);
            for (let n = 0; n < e.length; n++) t[e[n]]();
          }
        }
        class za extends Y {
          constructor(t) {
            var e;
            super(t),
              Ra(this, "LanesHandler"),
              Ra(this, "comboAttributes"),
              Ra(this, "direction"),
              Ra(this, "fixedAttributeName"),
              Ra(this, "irema"),
              (this.comboAttributes = null != (e = t.comboAttributes) ? e : {}),
              (this.fixedAttributeName = "_"),
              (this.LanesHandler = new Da({
                comboAttributes: this.comboAttributes,
              })),
              (this.irema = new Pa()),
              (this.direction = ga);
          }
          get lanes() {
            return this.LanesHandler.lanes;
          }
          get incidentsById() {
            return this.LanesHandler.incidentsById;
          }
          _resize(t) {
            this.LanesHandler._resize(t);
          }
          checkAddition(t, e = "all-or-nothing") {
            const n = this.LanesHandler.createTestLanesSanbox(),
              s = [],
              i = [],
              r = [];
            for (let e = 0; e < t.length; e++) {
              let o = !1;
              const a = t[e],
                { incident: l } = a;
              let { mcid: c, attribute: u } = l;
              u || (u = this.fixedAttributeName),
                n.laneExists(c, u),
                s.push({ mcid: c, attribute: u });
              const p = n.getOverlappingAnims(a, c, u);
              if (p.length > 0) {
                const t = this.incidentsById[p[0].id];
                (o = !0),
                  r.push({
                    type: "unauthorised, overlapping incidents on the same element",
                    element_mcid: c,
                    attribute: u,
                    millisecond: p[0].millisecond,
                    incident: t
                      ? {
                          attrs: t.DescriptiveIncident.attrs,
                          props: t.DescriptiveIncident.props,
                          duration: t.duration,
                        }
                      : void 0,
                  });
              }
              if (!o) {
                const t = n.addElementToLane(c, u, a.millisecond, l);
                i.push(() => {
                  for (let e = 0; e < t.length; e++) t[e]();
                  l._onGetContextOnce();
                });
              }
            }
            if (r.length > 0 && "all-or-nothing" === e)
              return { result: !1, errors: r };
            const o = this.LanesHandler;
            return {
              result: !0,
              errors: r,
              execute: function () {
                for (let t = 0; t < s.length; t++) {
                  const e = _(s[t].mcid, s[t].attribute),
                    i = n.lanes[e].exportFlattened();
                  i.sort((t, e) => t.millisecond - e.millisecond),
                    n.lanes.setValue(e, i);
                }
                for (let t = 0; t < i.length; t++) i[t]();
                o.applySandboxChanges(n);
              },
            };
          }
          checkEdit(t, e) {
            const n = [];
            for (let e = 0; e < t.length; e++) n.push(t[e].id);
            const s = this.LanesHandler.createTestLanesSanbox(),
              i = [];
            for (let r = 0; r < t.length; r++) {
              let {
                incident: { id: o, mcid: a, attribute: l },
              } = t[r];
              l || (l = this.fixedAttributeName);
              const c = s.getLane(a, l);
              for (let t = 0; t < c.length; t++)
                if (c[t].id === o) {
                  const r = c[t],
                    o = $a({}, r);
                  (o.millisecond += e), (o.incident = s.incidentsById[o.id]);
                  const u = s.getOverlappingAnims(o, a, l, n);
                  u.length > 0 &&
                    i.push({
                      type: "unauthorised, overlapping animations on the same element",
                      meta: {
                        element_mcid: a,
                        attribute: l,
                        newAnimation: o,
                        overlappingAnims: u,
                      },
                    });
                  break;
                }
            }
            if (i.length > 0) return { result: !1, errors: i };
            const r = this;
            return {
              result: !0,
              execute: function () {
                r.LanesHandler.updateLane(n, e), r.irema.reset();
              },
            };
          }
          checkResizedIncidents(t, e = !1) {
            const n = [];
            for (let e = 0; e < t.length; e++) n.push(t[e].id);
            const s = this.LanesHandler.createTestLanesSanbox(),
              i = [];
            for (let r = 0; r < t.length; r++) {
              let { mcid: o, attribute: a } =
                this.LanesHandler.incidentsById[t[r].id];
              a || (a = this.fixedAttributeName);
              const l = s.getLane(o, a),
                c = t[r].end - t[r].start;
              for (let u = 0; u < l.length; u++) {
                if (l[u].id !== t[r].id) continue;
                if (e) break;
                const p = $a({}, l[u]);
                (p.millisecond += t[r].startDelta),
                  (p.incident = s.incidentsById[p.id]);
                const h = s.getOverlappingAnims(p, o, a, n, c);
                h.length > 0 &&
                  i.push({
                    type: "unauthorized overlapping animations on the same element",
                    meta: {
                      element_mcid: o,
                      attribute: a,
                      newAnimation: p,
                      overlappingAnims: h,
                    },
                  });
              }
            }
            if (i.length > 0) return { result: !1, errors: i };
            const r = this;
            return {
              execute: function () {
                for (let e = 0; e < t.length; e++)
                  r.LanesHandler.updateLane([t[e].id], t[e].startDelta);
                r.irema.reset();
              },
              result: !0,
            };
          }
          checkDelete(t) {
            const e = [];
            for (let n = 0; n < t.length; n++) e.push(t[n].id);
            const n = this;
            return {
              result: !0,
              execute: function () {
                n.LanesHandler.deleteAnimations(e), n.irema.reset();
              },
            };
          }
          recalcScratchValues(t) {
            this.LanesHandler.recalcScratchValues(t);
          }
          slipIntoLaneForwards(t, e, n, s, i, r = !1) {
            if (0 === s && !r) return !0;
            let o = !0;
            const a = [],
              l = this.LanesHandler.getLastAffectedIndex(i, t, r);
            let c = l[0],
              u = l[1],
              p = !1;
            for (let h = l[0]; h < e.length; h++) {
              const l = e[h];
              if (l.millisecond >= s) {
                if (!r || 0 === h) {
                  const n = Math.floor(l.millisecond / this.irema.subPeriod);
                  this.irema.subscribe(i, ga, n, t, e);
                }
                o = !1;
                break;
              }
              if (u <= n)
                h < e.length - 1
                  ? e[h + 1].millisecond < s &&
                    (u =
                      this.incidentsById[e[h + 1].id].duration +
                      e[h + 1].millisecond)
                  : (o = !1);
              else {
                if (!(u >= n && u <= s)) {
                  a.push(l), (c = h), (p = !1);
                  break;
                }
                a.push(l),
                  (c = h),
                  (p = !0),
                  h < e.length - 1
                    ? (u =
                        this.incidentsById[e[h + 1].id].duration +
                        e[h + 1].millisecond)
                    : (o = !1);
              }
            }
            if (
              (c !== l[0] && this.LanesHandler.setLastAffectedIndex(i, t, c),
              0 === a.length)
            )
              return r && 0 === n
                ? (this.incidentsById[e[0].id].onProgress(0, i), !0)
                : o;
            const h = a.length - 1,
              d = this.incidentsById[a[h].id],
              m = a[h].millisecond,
              f = p ? d._duration : s - m;
            return d.onProgress(f, i), o;
          }
          slipToLaneBackwards(t, e, n, s, i) {
            let r = !0;
            const o = [],
              a = this.LanesHandler.getLastAffectedIndex(i, t);
            let l = a[0],
              c = a[1],
              u = !1;
            for (let p = a[0]; p >= 0; p--) {
              const a = e[p];
              if (c < s) {
                const n = Math.floor(c / this.irema.subPeriod);
                this.irema.subscribe(i, ya, n, t, e), (r = !1);
                break;
              }
              if (a.millisecond > n)
                p > 0
                  ? e[p - 1].millisecond +
                      this.incidentsById[e[p - 1].id].duration <
                      s &&
                    (c =
                      this.incidentsById[e[p - 1].id].duration +
                      e[p - 1].millisecond)
                  : (r = !0);
              else {
                if (!(a.millisecond <= n && a.millisecond > s)) {
                  o.push(a), (l = p), (u = !1);
                  break;
                }
                o.push(a),
                  (l = p),
                  (u = !0),
                  p > 0
                    ? (c =
                        this.incidentsById[e[p - 1].id].duration +
                        e[p - 1].millisecond)
                    : (r = !1);
              }
            }
            if (
              (l !== a[0] && this.LanesHandler.setLastAffectedIndex(i, t, l),
              0 === o.length)
            )
              return !0;
            const p = o.length - 1,
              h = this.incidentsById[o[p].id],
              d = o[p].millisecond,
              m = u ? 0 : s - d;
            return h.onProgress(m, i), r;
          }
          moveTo(t, e, n, s = !1) {
            const i = e >= t ? ga : ya,
              r = this.irema.executionSubscribers(n, i);
            (s || i !== this.direction) &&
              (this.irema._nextIterationLanes = {});
            const o = this.irema.nextIterationLanes(n, this.lanes),
              a = this.irema.currentPeriod(n),
              l = Math.floor(e / this.irema.subPeriod);
            if (i === ga) for (let t = a; t <= l; t++) Fa(r[t]);
            else for (let t = a; t >= l; t--) Fa(r[t]);
            const c = {},
              u = Object.keys(o),
              p =
                i === ga
                  ? this.slipIntoLaneForwards.bind(this)
                  : this.slipToLaneBackwards.bind(this);
            for (let i = 0; i < u.length; i++) {
              const r = this.lanes[u[i]];
              p(u[i], r, t, e, n, s) && (c[u[i]] = r);
            }
            this.irema.setCurrentPeriod(n, l),
              this.irema.setNextIterationLanes(n, c),
              (this.direction = i);
          }
        }
        Ra(za, "type", "attributes");
        var Xa = Object.defineProperty,
          Ha = (t, e, n) => (
            ((t, e, n) => {
              e in t
                ? Xa(t, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: n,
                  })
                : (t[e] = n);
            })(t, "symbol" != typeof e ? e + "" : e, n),
            n
          );
        class Ya extends ps {
          constructor(t, e) {
            super(null != e ? e : t), void 0 === e && ((e = t || {}), (t = {}));
            const n = V(e, mr, this.constructor);
            if (!n.result) return n;
            (this.inheritedSelector = null),
              (this.attrs = t),
              x(e, "duration") || (e.duration = 0),
              (this.props = e),
              (this.attributesStaggers = []),
              (this.propsStaggers = []),
              this.setupDynamicValues(),
              (this.dynamicDurationValue = null),
              (this.passive = !1);
          }
          get duration() {
            return null !== this.dynamicDurationValue
              ? this.dynamicDurationValue
              : this.propsStaggers.length > 0
              ? "dynamic"
              : super.duration;
          }
          set duration(t) {
            if (this.propsStaggers.length > 0) {
              for (let e = 0; e < this.propsStaggers.length; e++) {
                if ("repeats" === this.propsStaggers[e].path) continue;
                const n = this.propsStaggers[e].stagger.resize(
                  t / this.duration
                );
                B(this.props, this.propsStaggers[e].path, n);
              }
              this.dynamicDurationValue = t;
            } else super.duration = t;
          }
          manageEditAttrProps(t, e) {
            const { parentNode: n, id: s } = this,
              i = n.getLeafPosition(s);
            n.removeIncident(s);
            const r = w(this[e]);
            this[e] = t;
            const o = n.addIncident(this, i);
            return (
              this.resetDuration(!0),
              o.result ||
                (n.removeIncident(s),
                (this[e] = r),
                this.resetDuration(),
                n.addIncident(this, i)),
              o
            );
          }
          detachFromParent() {
            super.detachFromParent(), (this.inheritedSelector = null);
          }
          handleCheckForInvalidSelectors() {
            const t = this.selector();
            return null === t
              ? {
                  id: this.id,
                  ClassName: this.constructor.ClassName,
                  plugin_npm_name: this.constructor.plugin_npm_name,
                  error: "null selector",
                }
              : (null == t ? void 0 : t.startsWith("&"))
              ? {
                  id: this.id,
                  ClassName: this.constructor.ClassName,
                  plugin_npm_name: this.constructor.plugin_npm_name,
                  error: "relative selector with no inherited selector",
                  selector: t,
                }
              : this.bypass();
          }
          exportDefinition() {
            return {
              ClassName: this.constructor.ClassName,
              version: this.constructor.version,
              plugin:
                this.constructor.plugin || this.constructor.plugin_npm_name,
              plugin_npm_name: this.constructor.plugin_npm_name,
              attrs: this.attrs,
              props: this.props,
            };
          }
          exportLiveDefinition(t = !0) {
            const e = w(this.props);
            return (
              t || delete e.id,
              { Class: this.constructor, attrs: w(this.attrs), props: e }
            );
          }
        }
        Ha(Ya, "Incident", it),
          Ha(Ya, "plugin_npm_name", p),
          Ha(Ya, "version", xr),
          Ha(Ya, "Channel", za),
          Ha(Ya, "ClassName", "Incident"),
          Ha(Ya, "attrsValidationRules", null),
          Ha(Ya, "propsValidationRules", mr);
        var Ua = Object.defineProperty,
          Wa = (t, e, n) => (
            ((t, e, n) => {
              e in t
                ? Ua(t, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: n,
                  })
                : (t[e] = n);
            })(t, "symbol" != typeof e ? e + "" : e, n),
            n
          );
        function qa(t) {
          if (
            ((null == t ? void 0 : t.default) && (t = t.default),
            (null == t ? void 0 : t.npm_name) ||
              (t.npm_name = `plugin_${new Date().getTime()}`),
            !(function (t) {
              x(t, "default") && (t = t.default);
              const e = t.npm_name;
              if (
                (x(t, "name") ||
                  j.notice(
                    `Notice on plugin ${e}. A plugin should have its name under the key "name". It's missing from this plugin`
                  ),
                x(t, "version") ||
                  j.notice(
                    `Notice on ${e}. Plugin should always expose its version number.\n      Plugin version is missing`
                  ),
                !x(t, "incidents"))
              )
                return (
                  !!x(t, "Clip") ||
                  (j.error(
                    `Error on plugin ${e}. A plugin must expose at least one Incident or a Clip.\n        Exposed plugin Incidents should be defined on the "incidents" key of the index.js file while Clips on the "Clip".`
                  ),
                  !1)
                );
              if (!Array.isArray(t.incidents))
                return (
                  j.error(
                    `Error on plugin ${e}. thePlugin exposed Incidents are defined on the "incidents" key of the index.js file in array format.\n    Please refer to the documentation`
                  ),
                  !1
                );
              let n = !0;
              for (let s = 0; s < t.incidents.length; s++) {
                const i = t.incidents[s];
                v(i.exportable) &&
                  x(i.exportable, "default") &&
                  (i.exportable = i.exportable.default);
                const r = i.exportable.prototype;
                if (
                  r instanceof Pr ||
                  r instanceof oa ||
                  r instanceof it ||
                  r instanceof da
                ) {
                  if (r instanceof oa) {
                    if (!x(i, "originalDims")) {
                      j.log(
                        `Warning on plugin ${e}. It's best practice to provide originalDims\nwhen exposing Incidents extending DOMClip. By defining their original dims the users\nof your plugin will be able to define the desired dimensions of your Incident by\nthe "containerParams object"`
                      );
                      continue;
                    }
                    E(i.originalDims).result ||
                      (j.error(
                        `Error on plugin ${e}. Invalid originalDims value passed on ${i.name}`
                      ),
                      (n = !1));
                  }
                  x(i, "name") ||
                    (j.error(
                      `Error on plugin ${e}. Exportable Incidents by any plugin must have the "name" key which defines the name of the exported Incident.\nPlease refer to documentation`
                    ),
                    (n = !1));
                } else
                  j.error(
                    `Error on plugin ${e}. Exportable Incidents by any plugin must extend one of the base classes provided by MotorCortex. ${i.exportable.constructor.name} doesn't.\nPlease refer to documentation`
                  ),
                    (n = !1);
              }
              return n;
            })(t))
          )
            throw `loadPlugin failed for plugin '${t.npm_name}'. Please check error log.`;
          const e = (function (t) {
              return !!t.Clip;
            })(t)
              ? (function (t) {
                  var e, n;
                  if (!x(t.Clip, "exportable")) {
                    const n =
                      (Wa((e = class extends oa {}), "Incident", t.Clip),
                      Wa(e, "version", t.version || "*"),
                      Wa(e, "plugin", t.npm_name),
                      Wa(e, "audio", t.audio || "off"),
                      Wa(e, "customClip", !0),
                      e);
                    return (
                      j.warning(
                        `It's best practice to provide attributesValidationRules to the exported incidents. ${t.npm_name}.Clip doesn't provide it`
                      ),
                      n
                    );
                  }
                  const s =
                    ((n = class extends oa {
                      constructor() {
                        super(...arguments),
                          Wa(this, "attrsValidationRules", null),
                          Wa(this, "attrsValidationMethod");
                      }
                    }),
                    Wa(n, "Incident", t.Clip.exportable),
                    Wa(n, "version", t.version || "*"),
                    Wa(n, "plugin", t.npm_name),
                    Wa(n, "audio", t.audio || "off"),
                    Wa(n, "customClip", !0),
                    n);
                  let i;
                  return (
                    t.Clip.attributesValidationRules &&
                      (i = Yi(t.Clip.attributesValidationRules)),
                    class {
                      constructor(e, n) {
                        let r = e,
                          o = n;
                        if (
                          (null == n && ((o = r), (r = {})),
                          !x(t.Clip, "attributesValidationRules") ||
                            !t.Clip.attributesValidationRules)
                        ) {
                          j.log("instantiating");
                          const e = new s(r, o);
                          return (
                            j.warning(
                              `It's best practice to provide attributesValidationRules to the exported incidents. ${t.npm_name}.${e.constructor.name} doesn't provide it`
                            ),
                            e
                          );
                        }
                        const a = i(r);
                        if (a.length > 0) {
                          let e = `Error on plugin's "${t.npm_name}" Clip instantiation. Errors:`;
                          for (let t = 0; t < a.length; t++)
                            e += `\n - ${a[t].message}. ${a[t].actual} provided`;
                          return (
                            j.error(e),
                            j.log("breaking"),
                            { result: !1, errors: a }
                          );
                        }
                        j.log("instantiating");
                        const l = new s(r, o);
                        return (
                          (l.attrsValidationRules =
                            t.Clip.attributesValidationRules),
                          (l.attrsValidationMethod = i),
                          l
                        );
                      }
                    }
                  );
                })(t)
              : void 0,
            n = { Clip: e };
          if (
            !(function (t) {
              return !!t.incidents;
            })(t)
          )
            return n;
          let s = za;
          t.compositeAttributes &&
            (s = class extends za {
              constructor(e) {
                (e.comboAttributes = t.compositeAttributes), super(e);
              }
            });
          for (let e = 0; e < t.incidents.length; e++)
            Object.defineProperty(n, t.incidents[e].name, Ga(t, e, s));
          return n;
        }
        function Ga(t, e, n) {
          var s, i, r;
          const o = t.incidents[e],
            a = o.exportable;
          let l = null,
            c = null,
            u = !1;
          if (x(o, "attributesValidationRules")) {
            u = !0;
            const t = w(o.attributesValidationRules);
            x(o.attributesValidationRules, "animatedAttrs") &&
              (t.initialValues = (function (t) {
                const e = w(t);
                return (
                  (function t(e) {
                    if (
                      (y(e) && (e = { type: e }),
                      (e.optional = !0),
                      "object" === e.type)
                    )
                      for (const n in e.props) t(e.props[n]);
                  })(e),
                  e
                );
              })(t.animatedAttrs)),
              (c = t),
              (l = Yi(t));
          }
          const p = a.prototype;
          let h;
          p instanceof it
            ? (Wa((s = class extends Ya {}), "Incident", a),
              Wa(s, "version", t.version || "*"),
              Wa(s, "plugin_npm_name", t.npm_name),
              Wa(s, "ClassName", o.name),
              Wa(s, "Channel", n),
              Wa(s, "plugin", t.npm_name),
              Wa(s, "audio", t.audio || "off"),
              (h = s))
            : p instanceof da
            ? (Wa((i = class extends Ya {}), "Incident", a),
              Wa(i, "plugin_npm_name", "@donkeyclip/media-playback"),
              Wa(i, "version", t.version || "*"),
              Wa(i, "ClassName", o.name),
              Wa(i, "Channel", ua),
              Wa(i, "audio", t.audio || "off"),
              Wa(i, "plugin", t.npm_name),
              (h = i))
            : p instanceof oa
            ? (Wa((r = class extends a {}), "audio", t.audio || "on"),
              Wa(r, "originalDims", E(o.originalDims).analysis),
              Wa(r, "isAnimation", !0),
              (h = r))
            : p instanceof Pr && (h = a),
            (h.plugin = t.npm_name),
            (h.version = t.version || "*"),
            (h.ClassName = o.name),
            (h.attrsValidationRules = c),
            (h.attrsValidationMethod = l);
          class d {
            constructor(e, n) {
              if (u) {
                const n = l(e);
                if (n.length > 0) {
                  let e = `Error on plugin's "${t.npm_name}" "${o.name}" instantiation. Errors:`;
                  for (let t = 0; t < n.length; t++)
                    e += `\n - ${n[t].message}. ${n[t].actual} provided`;
                  return j.error(e), { result: !1, errors: n };
                }
              }
              const s = new h(e, n);
              return (
                s.result &&
                  !u &&
                  j.warning(
                    `It's best practice to provide attributesValidationRules to the exported incidents. ${t.npm_name} doesn't provide it`
                  ),
                s
              );
            }
          }
          return Wa(d, "targetClass", h), { enumerable: !0, get: () => d };
        }
        const Za = Math.PI / 180,
          Ka = [
            "translateX",
            "translateY",
            "translateZ",
            "rotate",
            "rotateX",
            "rotateY",
            "rotateZ",
            "scale",
            "scaleX",
            "scaleY",
            "scaleZ",
            "skewX",
            "skewY",
          ];
        var Ja = Object.defineProperty;
        class Qa extends it {
          constructor(t = {}, e = {}, n) {
            super(t, e, n),
              ((t, e, n) => {
                ((t, e, n) => {
                  e in t
                    ? Ja(t, e, {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: n,
                      })
                    : (t[e] = n);
                })(this, e + "", void 0);
              })(0, "compoAttributes"),
              (this.compoAttributes = { transform: Ka });
          }
          getScratchValue() {
            let t = this.attributeKey;
            if (("cssOffset" === t && (t = "offset"), "transform" !== t)) {
              const e = this.context.window.getComputedStyle(this.element)[t];
              return void 0 !== e && "" !== e ? e : 0;
            }
            const e = this.compoAttributes[t],
              n = (function (t, e) {
                const n = t.getComputedStyle(e).transform;
                return "" === n || "none" === n
                  ? {
                      rotate: "0deg",
                      rotateX: "0deg",
                      rotateY: "0deg",
                      scaleX: 1,
                      scaleY: 1,
                      scale: 1,
                      skewX: "0deg",
                      skewY: "0deg",
                      translateX: "0px",
                      translateY: "0px",
                    }
                  : (function (t) {
                      const e = Math.atan2(t[1], t[0]),
                        n = Math.pow(t[0], 2) + Math.pow(t[1], 2),
                        s = Math.pow(t[2], 2) + Math.pow(t[3], 2),
                        i = Math.round(100 * Math.sqrt(n)) / 100,
                        r =
                          Math.round(
                            ((t[0] * t[3] - t[2] * t[1]) / i) * 100 || 0
                          ) / 100,
                        o = Math.atan2(t[0] * t[2] + t[1] * t[3], n),
                        a = Math.atan2(t[1] * t[3] + t[0] * t[2], s);
                      return {
                        rotate: `${e / Za || 0}deg`,
                        scaleX: i === r ? 1 : null != i ? i : 1,
                        scaleY: i === r ? 1 : null != r ? r : 1,
                        scale: i === r && null != i ? r : 1,
                        skewX: (1 === n ? o / Za : 0) + "deg",
                        skewY: (1 === s ? a / Za : 0) + "deg",
                        translateX: `${t[4].trim()}px`,
                        translateY: `${t[5].trim()}px`,
                      };
                    })(n.split("(")[1].split(")")[0].split(","));
              })(this.context.window, this.element),
              s = this.context.window.getComputedStyle(this.element),
              i = {};
            let r;
            for (let t = 0; t < e.length; t++)
              (r = e[t]), (i[r] = x(n, r) ? n[r] : s[r]);
            return i;
          }
        }
        var tl = Object.defineProperty,
          el = (t, e, n) => (
            ((t, e, n) => {
              e in t
                ? tl(t, e, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: n,
                  })
                : (t[e] = n);
            })(t, "symbol" != typeof e ? e + "" : e, n),
            n
          );
        const nl = ["deg", "rad", "grad", "turn"],
          sl = "measurement",
          il = "color",
          rl = {
            type: "object",
            props: {
              background: { optional: !0, type: il },
              backgroundColor: { optional: !0, type: il },
              backgroundPosition: { optional: !0, type: "string" },
              backgroundSize: { optional: !0, type: "string" },
              border: { optional: !0, type: "string" },
              borderBottom: { optional: !0, type: "string" },
              borderBottomColor: { optional: !0, type: il },
              borderBottomLeftRadius: { optional: !0, type: sl, units: er },
              borderBottomRightRadius: { optional: !0, type: sl, units: er },
              borderBottomWidth: { optional: !0, type: sl, units: er },
              borderColor: { optional: !0, type: il },
              borderEndEndRadius: { optional: !0, type: sl, units: er },
              borderEndStartRadius: { optional: !0, type: sl, units: er },
              borderImageOutset: { optional: !0, type: sl, units: er, min: 0 },
              borderImageSlice: { optional: !0, type: sl, units: er, min: 0 },
              borderImageWidth: { optional: !0, type: sl, units: er, min: 0 },
              borderLeft: { optional: !0, type: "string" },
              borderLeftColor: { optional: !0, type: il },
              borderLeftWidth: { optional: !0, type: sl, units: er },
              borderRadius: { optional: !0, type: sl, units: er },
              borderRight: { optional: !0, type: "string" },
              borderRightColor: { optional: !0, type: il },
              borderRightWidth: { optional: !0, type: sl, units: er },
              borderStartEndRadius: { optional: !0, type: sl, units: er },
              borderStartStartRadius: { optional: !0, type: sl, units: er },
              borderTop: { optional: !0, type: "string" },
              borderTopColor: { optional: !0, type: il },
              borderTopLeftRadius: { optional: !0, type: sl, units: er },
              borderTopRightRadius: { optional: !0, type: sl, units: er },
              borderTopWidth: { optional: !0, type: sl, units: er },
              borderWidth: { optional: !0, type: sl, units: er },
              bottom: { optional: !0, type: sl, units: er },
              boxShadow: { optional: !0, type: "string" },
              caretColor: { optional: !0, type: il },
              color: { optional: !0, type: il },
              columnCount: {
                optional: !0,
                type: "number",
                min: 0,
                integer: !0,
              },
              columnGap: { optional: !0, type: sl, units: er },
              columnRule: { optional: !0, type: "string" },
              columnRuleColor: { optional: !0, type: il },
              columnRuleWidth: { optional: !0, type: sl, units: er },
              columns: { optional: !0, type: "number", min: 0, integer: !0 },
              columnWidth: { optional: !0, type: sl, units: er },
              flex: { optional: !0, type: "number", min: 0, integer: !0 },
              flexBasis: { optional: !0, type: sl, units: er },
              flexGrow: { optional: !0, type: "number", min: 0, integer: !0 },
              flexShrink: { optional: !0, type: "number", min: 0, integer: !0 },
              font: { optional: !0, type: "string" },
              fontSize: { optional: !0, type: sl, units: er },
              fontSizeAdjust: { optional: !0, type: sl, units: er, min: 0 },
              fontStretch: { optional: !0, type: sl, units: ["%"] },
              fontWeight: { optional: !0, type: "string" },
              gap: { optional: !0, type: sl, units: er },
              gridColumnGap: { optional: !0, type: sl, units: er },
              gridGap: { optional: !0, type: sl, units: er },
              gridRowGap: { optional: !0, type: sl, units: er },
              gridTemplateColumns: { optional: !0, type: sl, units: er },
              gridTemplateRows: { optional: !0, type: sl, units: er },
              height: { optional: !0, type: sl, units: er, min: 0 },
              inset: { optional: !0, type: sl, units: er, min: 0 },
              insetBlock: { optional: !0, type: sl, units: er },
              insetBlockEnd: { optional: !0, type: sl, units: er },
              insetBlockStart: { optional: !0, type: sl, units: er },
              insetInline: { optional: !0, type: sl, units: er },
              insetInlineEnd: { optional: !0, type: sl, units: er },
              insetInlineStart: { optional: !0, type: sl, units: er },
              left: { optional: !0, type: sl, units: er },
              letterSpacing: { optional: !0, type: sl, units: er },
              lineClamp: { optional: !0, type: "number", min: 0, integer: !0 },
              lineHeight: { optional: !0, type: sl, units: er, min: 0 },
              margin: { optional: !0, type: "string" },
              marginBottom: { optional: !0, type: sl, units: er },
              marginLeft: { optional: !0, type: sl, units: er },
              marginRight: { optional: !0, type: sl, units: er },
              marginTop: { optional: !0, type: sl, units: er },
              maskBorder: { optional: !0, type: sl, units: er, min: 0 },
              maskPosition: { optional: !0, type: "string" },
              maskSize: { optional: !0, type: "string" },
              maxHeight: { optional: !0, type: sl, units: er, min: 0 },
              maxWidth: { optional: !0, type: sl, units: er, min: 0 },
              objectPosition: { optional: !0, type: "string" },
              cssOffset: { optional: !0, type: "any" },
              offsetAnchor: { optional: !0, type: "string" },
              offsetDistance: { optional: !0, type: sl, units: er },
              offsetPath: { optional: !0, type: "string" },
              offsetPosition: { optional: !0, type: "string" },
              offsetRotate: { optional: !0, type: sl, units: nl },
              opacity: { optional: !0, type: "number", min: 0, max: 1 },
              order: { optional: !0, type: "number", integer: !0 },
              outline: { optional: !0, type: "string" },
              outlineColor: { optional: !0, type: il },
              outlineOffset: { optional: !0, type: sl, units: er },
              outlineRadius: { optional: !0, type: sl, units: er },
              outlineRadiusBottomleft: { optional: !0, type: sl, units: er },
              outlineRadiusBottomright: { optional: !0, type: sl, units: er },
              outlineRadiusTopleft: { optional: !0, type: sl, units: er },
              outlineRadiusTopright: { optional: !0, type: sl, units: er },
              outlineWidth: { optional: !0, type: sl, units: er },
              padding: { optional: !0, type: sl, units: er },
              paddingBottom: { optional: !0, type: sl, units: er },
              paddingLeft: { optional: !0, type: sl, units: er },
              paddingRight: { optional: !0, type: sl, units: er },
              paddingTop: { optional: !0, type: sl, units: er },
              perspective: { optional: !0, type: sl, units: er },
              perspectiveOrigin: { optional: !0, type: "string" },
              r: { optional: !0, type: "string" },
              right: { optional: !0, type: sl, units: er },
              rotate: { optional: !0, type: sl, units: nl },
              rowGap: { optional: !0, type: sl, units: er },
              scale: { optional: !0, type: "number", min: 0 },
              scrollbarColor: { optional: !0, type: il },
              scrollMargin: { optional: !0, type: sl, units: er },
              scrollMarginBlock: { optional: !0, type: sl, units: er },
              scrollMarginBlockEnd: { optional: !0, type: sl, units: er },
              scrollMarginBlockStart: { optional: !0, type: sl, units: er },
              scrollMarginBottom: { optional: !0, type: sl, units: er },
              scrollMarginInline: { optional: !0, type: sl, units: er },
              scrollMarginInlineEnd: { optional: !0, type: sl, units: er },
              scrollMarginInlineStart: { optional: !0, type: sl, units: er },
              scrollMarginLeft: { optional: !0, type: sl, units: er },
              scrollMarginRight: { optional: !0, type: sl, units: er },
              scrollMarginTop: { optional: !0, type: sl, units: er },
              scrollPadding: { optional: !0, type: sl, units: er },
              scrollPaddingBlock: { optional: !0, type: sl, units: er },
              scrollPaddingBlockEnd: { optional: !0, type: sl, units: er },
              scrollPaddingBlockStart: { optional: !0, type: sl, units: er },
              scrollPaddingBottom: { optional: !0, type: sl, units: er },
              scrollPaddingInline: { optional: !0, type: sl, units: er },
              scrollPaddingInlineEnd: { optional: !0, type: sl, units: er },
              scrollPaddingInlineStart: { optional: !0, type: sl, units: er },
              scrollPaddingLeft: { optional: !0, type: sl, units: er },
              scrollPaddingRight: { optional: !0, type: sl, units: er },
              scrollPaddingTop: { optional: !0, type: sl, units: er },
              scrollSnapCoordinate: { optional: !0, type: "string" },
              scrollSnapDestination: { optional: !0, type: sl, units: er },
              shapeImageThreshold: { optional: !0, type: "string" },
              shapeMargin: { optional: !0, type: sl, units: er },
              shapeOutside: { optional: !0, type: "string" },
              tabSize: { optional: !0, type: "string" },
              textDecoration: { optional: !0, type: "string" },
              textDecorationColor: { optional: !0, type: il },
              textDecorationThickness: { optional: !0, type: sl, units: er },
              textEmphasis: { optional: !0, type: "string" },
              textEmphasisColor: { optional: !0, type: il },
              textFillColor: { optional: !0, type: il },
              textIndent: { optional: !0, type: sl, units: er },
              textShadow: { optional: !0, type: "string" },
              textStroke: { optional: !0, type: "string" },
              textStrokeColor: { optional: !0, type: il },
              textUnderlineOffset: { optional: !0, type: sl, units: er },
              top: { optional: !0, type: sl, units: er },
              transform: {
                optional: !0,
                type: "object",
                props: {
                  translateX: { type: sl, units: er, optional: !0 },
                  translateY: { type: sl, units: er, optional: !0 },
                  translateZ: { type: sl, units: er, optional: !0 },
                  rotate: { type: sl, units: nl, optional: !0 },
                  rotateX: { type: sl, units: nl, optional: !0 },
                  rotateY: { type: sl, units: nl, optional: !0 },
                  rotateZ: { type: sl, units: nl, optional: !0 },
                  scale: { type: "number", min: 0, optional: !0 },
                  scaleX: { type: "number", min: 0, optional: !0 },
                  scaleY: { type: "number", min: 0, optional: !0 },
                  scaleZ: { type: "number", min: 0, optional: !0 },
                  skewX: { type: sl, units: nl, optional: !0 },
                  skewY: { type: sl, units: nl, optional: !0 },
                  perspective: { type: sl, units: er, optional: !0 },
                },
              },
              transformOrigin: { optional: !0, type: "string" },
              verticalAlign: { optional: !0, type: "string" },
              visibility: { optional: !0, type: "string" },
              width: { optional: !0, type: sl, units: er },
              wordSpacing: { optional: !0, type: sl, units: er },
              zIndex: { optional: !0, type: "number", integer: !0 },
              zoom: { optional: !0, type: sl, units: ["%"], min: 0 },
            },
            transformOrigin: { type: "string" },
            verticalAlign: { type: "string" },
            visibility: { type: "string" },
            width: { type: sl, units: er },
            wordSpacing: { type: sl, units: er },
            zIndex: { type: "number", integer: !0 },
            zoom: { type: sl, units: ["%"], min: 0 },
          },
          ol = {
            npm_name: "@donkeyclip/css-layer",
            incidents: [
              {
                exportable: class extends Qa {
                  constructor() {
                    super(...arguments),
                      el(this, "CSSAnimationLayerElement"),
                      el(this, "options"),
                      el(this, "animation");
                  }
                  onGetContext() {
                    var t, e, n, s, i;
                    if (
                      (null != (t = this.context).CSSAnimationLayer ||
                        (t.CSSAnimationLayer = {}),
                      null !=
                        (e = this.context.CSSAnimationLayer)[
                          (n = this.element.dataset.motorcortex2Id)
                        ] || (e[n] = {}),
                      null !=
                        (s =
                          this.context.CSSAnimationLayer[
                            this.element.dataset.motorcortex2Id
                          ])[(i = this.attributeKey)] ||
                        (s[i] = { id: null, animation: { cancel: L } }),
                      (this.CSSAnimationLayerElement =
                        this.context.CSSAnimationLayer[
                          this.element.dataset.motorcortex2Id
                        ][this.attributeKey]),
                      x(this.compoAttributes, this.attributeKey))
                    ) {
                      this.options = { transform: ["", ""] };
                      for (const t of this.compoAttributes[this.attributeKey])
                        x(this.targetValue, t) &&
                          ((this.options.transform[0] += `${[t]}(${
                            this.initialValue[t] || 0
                          })`),
                          (this.options.transform[1] += `${[t]}(${
                            this.targetValue[t]
                          })`));
                    } else
                      this.options = {
                        [this.attributeKey]: [
                          this.initialValue,
                          this.targetValue,
                        ],
                      };
                  }
                  createAnimation() {
                    (this.animation = new Animation(
                      new KeyframeEffect(
                        this.element,
                        [
                          {
                            [this.attributeKey]:
                              this.options[this.attributeKey][0],
                          },
                          {
                            [this.attributeKey]:
                              this.options[this.attributeKey][1],
                          },
                        ],
                        {
                          duration: this.props.duration,
                          fill: "forwards",
                          easing: "linear",
                        }
                      )
                    )),
                      (this.CSSAnimationLayerElement.id = this.id),
                      (this.CSSAnimationLayerElement.animation =
                        this.animation);
                  }
                  onProgress(t) {
                    this.CSSAnimationLayerElement.id !== this.id &&
                      this.createAnimation(),
                      (this.animation.currentTime = t);
                  }
                },
                name: "CSSEffect",
                attributesValidationRules: { animatedAttrs: rl },
              },
            ],
            compositeAttributes: { transform: Ka },
          };
        var al = Object.defineProperty;
        const ll = qa(ol);
        if (!ll) throw new Error("failed to create css layer");
        const cl = ll;
        let ul = null;
        function pl(t) {
          ul = t;
        }
        class hl {
          constructor(t, e) {
            const n = new cl.CSSEffect(t, e);
            return (
              !1 === n.result || (null != ul && (n.constructor.Incident = ul)),
              n
            );
          }
        }
        ((t, e, n) => {
          e in t
            ? al(t, e, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: n,
              })
            : (t[e] = n);
        })(hl, "targetClass", cl.CSSEffect.targetClass);
        var dl = Object.defineProperty,
          ml = Object.defineProperties,
          fl = Object.getOwnPropertyDescriptors,
          gl = Object.getOwnPropertySymbols,
          yl = Object.prototype.hasOwnProperty,
          vl = Object.prototype.propertyIsEnumerable,
          bl = (t, e, n) =>
            e in t
              ? dl(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (t[e] = n),
          xl = (t, e) => {
            for (var n in e || (e = {})) yl.call(e, n) && bl(t, n, e[n]);
            if (gl) for (var n of gl(e)) vl.call(e, n) && bl(t, n, e[n]);
            return t;
          },
          wl = (t, e) => ml(t, fl(e)),
          Cl = (t, e, n) => (bl(t, "symbol" != typeof e ? e + "" : e, n), n);
        const Il = Yi({
            incidents: {
              type: "array",
              items: {
                type: "object",
                props: {
                  position: {
                    type: "amount",
                    integer: !0,
                    min: 0,
                    optional: !1,
                  },
                  attrs: { type: "object", optional: !1 },
                  props: { type: "object", optional: !1 },
                  incidentClass: { type: "any", optional: !1 },
                },
              },
            },
          }),
          Pl =
            "Combos don't allow external addition or manipulation to their Incidents";
        function El() {
          return j.error(Pl), { result: !1, errors: [Pl] };
        }
        class kl extends Pr {
          constructor(t, e) {
            super(t, e),
              Cl(this, "addIncident", El),
              Cl(this, "moveIncident", El),
              Cl(this, "removeIncident", El),
              Cl(this, "handleCheckAddition", D),
              Cl(this, "handleCheckMove", D),
              Cl(this, "handleCheckDeletion", D),
              Cl(this, "handleCheckResize", D),
              null !== this.incidents &&
                ((this.attrs.incidents = this.incidents),
                (this.attributesStaggers = []),
                (this.propsStaggers = []),
                this.setupDynamicValues());
            const n = V(this.props, br, this.constructor);
            if (!n.result) return n;
            const s = Il(this.attrs);
            if (s.length > 0)
              return (
                j.error(
                  "The provided attributes for Combo Incident are invalid"
                ),
                { result: !1, errors: s }
              );
            let i = [];
            for (let t = 0; t < this.attrs.length; t++) {
              const e = this.attrs[t];
              if (null !== e.incidentClass.attrsValidationRules) {
                const t = e.incidentClass.attrsValidationMethod(e.attrs);
                t.length > 0 && (i = i.concat(t.errors));
              }
              const n = V(
                e.props,
                e.incidentClass.propsValidationRules,
                e.incidentClass
              );
              n.result || (i = i.concat(n.errors));
            }
            if (i.length > 0) return { result: !1, errors: i };
            this.dynamicDurationValue = null;
          }
          get incidents() {
            return null;
          }
          get duration() {
            return null !== this.dynamicDurationValue
              ? this.dynamicDurationValue
              : "dynamic";
          }
          set duration(t) {
            super.duration = t;
          }
          exportDefinition() {
            const t = wl(xl({}, this.attrs), {
              incidents: (function t(e) {
                const n = [];
                for (let s = 0; s < e.length; s++) {
                  const i = e[s];
                  let r = i.attrs;
                  "Combo" === i.incidentClass.ClassName &&
                    (r = wl(xl({}, r), { incidents: t(r.incidents) })),
                    n.push({
                      ClassName:
                        i.incidentClass.ClassName ||
                        i.incidentClass.targetClass.ClassName,
                      plugin_npm_name:
                        i.incidentClass.plugin_npm_name ||
                        i.incidentClass.targetClass.plugin_npm_name,
                      version:
                        i.incidentClass.version ||
                        i.incidentClass.targetClass.version,
                      attrs: r,
                      props: w(i.props),
                      position: i.position,
                    });
                }
                return n;
              })(this.attrs.incidents),
            });
            return {
              ClassName: this.constructor.ClassName,
              version: this.constructor.version,
              plugin:
                this.constructor.plugin || this.constructor.plugin_npm_name,
              plugin_npm_name: this.constructor.plugin_npm_name,
              attrs: t,
              props: w(this.props),
              incidents: {},
              duration: this.duration,
            };
          }
          exportLiveDefinition(t = !0) {
            let e = this.attrs;
            null !== this.incidents &&
              (e = wl(xl({}, e), { incidents: void 0 }));
            const n = w(this.props);
            return (
              t || delete n.id,
              { Class: this.constructor, attrs: e, props: n, incidents: {} }
            );
          }
        }
        Cl(kl, "ClassName", "Combo"),
          Cl(kl, "attrsValidationRules", null),
          Cl(kl, "propsValidationRules", br),
          Cl(kl, "isCombo", !0);
        var Sl = Object.defineProperty;
        class Ol {
          constructor() {
            ((t, e, n) => {
              ((t, e, n) => {
                e in t
                  ? Sl(t, e, {
                      enumerable: !0,
                      configurable: !0,
                      writable: !0,
                      value: n,
                    })
                  : (t[e] = n);
              })(this, e + "", void 0);
            })(0, "memory"),
              (this.memory = []);
          }
          startJourney(t) {
            return t
              ? (function (t, e) {
                  const n = [],
                    s = 1 * t.runTimeInfo.currentMillisecond,
                    i = t.runTimeInfo.state;
                  return (
                    t.stop(),
                    {
                      station(e) {
                        n.push(e), t.playableProgress(e / t.duration, e);
                      },
                      exportLog: () => ({
                        startMillisecond: s,
                        startState: i,
                        stations: n,
                      }),
                      destination(s) {
                        null != s ? this.station(s) : (s = n[n.length - 1]),
                          t.playableProgress(s / t.duration, s),
                          "playing" === i ||
                          ("blocked" === i && "playing" === t.statusBeforeBlock)
                            ? t.play()
                            : s >= t.duration
                            ? t.complete()
                            : t.arm(),
                          e.push(this.exportLog);
                      },
                    }
                  );
                })(t, this.memory)
              : (j.error("startJourney expects an Incident as an argument"),
                !1);
          }
        }
        const Ml = { easings: Jn, clipFromDefinition: G },
          Al = qa(fa);
        if (!Al) throw new Error("failed to create audio plugin");
        const { AudioEffect: _l, AudioPlayback: Tl, Clip: Dl } = Al;
      },
    },
    n = {};
  function s(t) {
    var i = n[t];
    if (void 0 !== i) {
      if (void 0 !== i.error) throw i.error;
      return i.exports;
    }
    var r = (n[t] = { exports: {} });
    try {
      var o = { id: t, module: r, factory: e[t], require: s };
      s.i.forEach(function (t) {
        t(o);
      }),
        (r = o.module),
        o.factory.call(r.exports, r, r.exports, o.require);
    } catch (t) {
      throw ((r.error = t), t);
    }
    return r.exports;
  }
  (s.m = e),
    (s.c = n),
    (s.i = []),
    (s.n = (t) => {
      var e = t && t.__esModule ? () => t.default : () => t;
      return s.d(e, { a: e }), e;
    }),
    (s.d = (t, e) => {
      for (var n in e)
        s.o(e, n) &&
          !s.o(t, n) &&
          Object.defineProperty(t, n, { enumerable: !0, get: e[n] });
    }),
    (s.hu = (t) => t + "." + s.h() + ".hot-update.js"),
    (s.hmrF = () => "main." + s.h() + ".hot-update.json"),
    (s.h = () => "bbf6e40c783337b8eac0"),
    (s.g = (function () {
      if ("object" == typeof globalThis) return globalThis;
      try {
        return this || new Function("return this")();
      } catch (t) {
        if ("object" == typeof window) return window;
      }
    })()),
    (s.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e)),
    (t = {}),
    (s.l = (e, n, i, r) => {
      if (t[e]) t[e].push(n);
      else {
        var o, a;
        if (void 0 !== i)
          for (
            var l = document.getElementsByTagName("script"), c = 0;
            c < l.length;
            c++
          ) {
            var u = l[c];
            if (u.getAttribute("src") == e) {
              o = u;
              break;
            }
          }
        o ||
          ((a = !0),
          ((o = document.createElement("script")).charset = "utf-8"),
          (o.timeout = 120),
          s.nc && o.setAttribute("nonce", s.nc),
          (o.src = e)),
          (t[e] = [n]);
        var p = (n, s) => {
            (o.onerror = o.onload = null), clearTimeout(h);
            var i = t[e];
            if (
              (delete t[e],
              o.parentNode && o.parentNode.removeChild(o),
              i && i.forEach((t) => t(s)),
              n)
            )
              return n(s);
          },
          h = setTimeout(
            p.bind(null, void 0, { type: "timeout", target: o }),
            12e4
          );
        (o.onerror = p.bind(null, o.onerror)),
          (o.onload = p.bind(null, o.onload)),
          a && document.head.appendChild(o);
      }
    }),
    (s.r = (t) => {
      "undefined" != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }),
        Object.defineProperty(t, "__esModule", { value: !0 });
    }),
    (() => {
      var t,
        e,
        n,
        i = {},
        r = s.c,
        o = [],
        a = [],
        l = "idle",
        c = 0,
        u = [];
      function p(t) {
        l = t;
        for (var e = [], n = 0; n < a.length; n++) e[n] = a[n].call(null, t);
        return Promise.all(e);
      }
      function h() {
        0 == --c &&
          p("ready").then(function () {
            if (0 === c) {
              var t = u;
              u = [];
              for (var e = 0; e < t.length; e++) t[e]();
            }
          });
      }
      function d(t) {
        if ("idle" !== l)
          throw new Error("check() is only allowed in idle status");
        return p("check")
          .then(s.hmrM)
          .then(function (n) {
            return n
              ? p("prepare").then(function () {
                  var i = [];
                  return (
                    (e = []),
                    Promise.all(
                      Object.keys(s.hmrC).reduce(function (t, r) {
                        return s.hmrC[r](n.c, n.r, n.m, t, e, i), t;
                      }, [])
                    ).then(function () {
                      return (
                        (e = function () {
                          return t
                            ? f(t)
                            : p("ready").then(function () {
                                return i;
                              });
                        }),
                        0 === c
                          ? e()
                          : new Promise(function (t) {
                              u.push(function () {
                                t(e());
                              });
                            })
                      );
                      var e;
                    })
                  );
                })
              : p(g() ? "ready" : "idle").then(function () {
                  return null;
                });
          });
      }
      function m(t) {
        return "ready" !== l
          ? Promise.resolve().then(function () {
              throw new Error(
                "apply() is only allowed in ready status (state: " + l + ")"
              );
            })
          : f(t);
      }
      function f(t) {
        (t = t || {}), g();
        var s = e.map(function (e) {
          return e(t);
        });
        e = void 0;
        var i = s
          .map(function (t) {
            return t.error;
          })
          .filter(Boolean);
        if (i.length > 0)
          return p("abort").then(function () {
            throw i[0];
          });
        var r = p("dispose");
        s.forEach(function (t) {
          t.dispose && t.dispose();
        });
        var o,
          a = p("apply"),
          l = function (t) {
            o || (o = t);
          },
          c = [];
        return (
          s.forEach(function (t) {
            if (t.apply) {
              var e = t.apply(l);
              if (e) for (var n = 0; n < e.length; n++) c.push(e[n]);
            }
          }),
          Promise.all([r, a]).then(function () {
            return o
              ? p("fail").then(function () {
                  throw o;
                })
              : n
              ? f(t).then(function (t) {
                  return (
                    c.forEach(function (e) {
                      t.indexOf(e) < 0 && t.push(e);
                    }),
                    t
                  );
                })
              : p("idle").then(function () {
                  return c;
                });
          })
        );
      }
      function g() {
        if (n)
          return (
            e || (e = []),
            Object.keys(s.hmrI).forEach(function (t) {
              n.forEach(function (n) {
                s.hmrI[t](n, e);
              });
            }),
            (n = void 0),
            !0
          );
      }
      (s.hmrD = i),
        s.i.push(function (u) {
          var f,
            g,
            y,
            v,
            b = u.module,
            x = (function (e, n) {
              var s = r[n];
              if (!s) return e;
              var i = function (i) {
                  if (s.hot.active) {
                    if (r[i]) {
                      var a = r[i].parents;
                      -1 === a.indexOf(n) && a.push(n);
                    } else (o = [n]), (t = i);
                    -1 === s.children.indexOf(i) && s.children.push(i);
                  } else
                    console.warn(
                      "[HMR] unexpected require(" +
                        i +
                        ") from disposed module " +
                        n
                    ),
                      (o = []);
                  return e(i);
                },
                a = function (t) {
                  return {
                    configurable: !0,
                    enumerable: !0,
                    get: function () {
                      return e[t];
                    },
                    set: function (n) {
                      e[t] = n;
                    },
                  };
                };
              for (var u in e)
                Object.prototype.hasOwnProperty.call(e, u) &&
                  "e" !== u &&
                  Object.defineProperty(i, u, a(u));
              return (
                (i.e = function (t) {
                  return (function (t) {
                    switch (l) {
                      case "ready":
                        p("prepare");
                      case "prepare":
                        return c++, t.then(h, h), t;
                      default:
                        return t;
                    }
                  })(e.e(t));
                }),
                i
              );
            })(u.require, u.id);
          (b.hot =
            ((f = u.id),
            (g = b),
            (v = {
              _acceptedDependencies: {},
              _acceptedErrorHandlers: {},
              _declinedDependencies: {},
              _selfAccepted: !1,
              _selfDeclined: !1,
              _selfInvalidated: !1,
              _disposeHandlers: [],
              _main: (y = t !== f),
              _requireSelf: function () {
                (o = g.parents.slice()), (t = y ? void 0 : f), s(f);
              },
              active: !0,
              accept: function (t, e, n) {
                if (void 0 === t) v._selfAccepted = !0;
                else if ("function" == typeof t) v._selfAccepted = t;
                else if ("object" == typeof t && null !== t)
                  for (var s = 0; s < t.length; s++)
                    (v._acceptedDependencies[t[s]] = e || function () {}),
                      (v._acceptedErrorHandlers[t[s]] = n);
                else
                  (v._acceptedDependencies[t] = e || function () {}),
                    (v._acceptedErrorHandlers[t] = n);
              },
              decline: function (t) {
                if (void 0 === t) v._selfDeclined = !0;
                else if ("object" == typeof t && null !== t)
                  for (var e = 0; e < t.length; e++)
                    v._declinedDependencies[t[e]] = !0;
                else v._declinedDependencies[t] = !0;
              },
              dispose: function (t) {
                v._disposeHandlers.push(t);
              },
              addDisposeHandler: function (t) {
                v._disposeHandlers.push(t);
              },
              removeDisposeHandler: function (t) {
                var e = v._disposeHandlers.indexOf(t);
                e >= 0 && v._disposeHandlers.splice(e, 1);
              },
              invalidate: function () {
                switch (((this._selfInvalidated = !0), l)) {
                  case "idle":
                    (e = []),
                      Object.keys(s.hmrI).forEach(function (t) {
                        s.hmrI[t](f, e);
                      }),
                      p("ready");
                    break;
                  case "ready":
                    Object.keys(s.hmrI).forEach(function (t) {
                      s.hmrI[t](f, e);
                    });
                    break;
                  case "prepare":
                  case "check":
                  case "dispose":
                  case "apply":
                    (n = n || []).push(f);
                }
              },
              check: d,
              apply: m,
              status: function (t) {
                if (!t) return l;
                a.push(t);
              },
              addStatusHandler: function (t) {
                a.push(t);
              },
              removeStatusHandler: function (t) {
                var e = a.indexOf(t);
                e >= 0 && a.splice(e, 1);
              },
              data: i[f],
            }),
            (t = void 0),
            v)),
            (b.parents = o),
            (b.children = []),
            (o = []),
            (u.require = x);
        }),
        (s.hmrC = {}),
        (s.hmrI = {});
    })(),
    (() => {
      var t;
      s.g.importScripts && (t = s.g.location + "");
      var e = s.g.document;
      if (!t && e && (e.currentScript && (t = e.currentScript.src), !t)) {
        var n = e.getElementsByTagName("script");
        if (n.length) for (var i = n.length - 1; i > -1 && !t; ) t = n[i--].src;
      }
      if (!t)
        throw new Error(
          "Automatic publicPath is not supported in this browser"
        );
      (t = t
        .replace(/#.*$/, "")
        .replace(/\?.*$/, "")
        .replace(/\/[^\/]+$/, "/")),
        (s.p = t);
    })(),
    (() => {
      var t,
        e,
        n,
        i,
        r,
        o = (s.hmrS_jsonp = s.hmrS_jsonp || { 179: 0 }),
        a = {};
      function l(e, n) {
        return (
          (t = n),
          new Promise((t, n) => {
            a[e] = t;
            var i = s.p + s.hu(e),
              r = new Error();
            s.l(i, (t) => {
              if (a[e]) {
                a[e] = void 0;
                var s = t && ("load" === t.type ? "missing" : t.type),
                  i = t && t.target && t.target.src;
                (r.message =
                  "Loading hot update chunk " +
                  e +
                  " failed.\n(" +
                  s +
                  ": " +
                  i +
                  ")"),
                  (r.name = "ChunkLoadError"),
                  (r.type = s),
                  (r.request = i),
                  n(r);
              }
            });
          })
        );
      }
      function c(t) {
        function a(t) {
          for (
            var e = [t],
              n = {},
              i = e.map(function (t) {
                return { chain: [t], id: t };
              });
            i.length > 0;

          ) {
            var r = i.pop(),
              o = r.id,
              a = r.chain,
              c = s.c[o];
            if (c && (!c.hot._selfAccepted || c.hot._selfInvalidated)) {
              if (c.hot._selfDeclined)
                return { type: "self-declined", chain: a, moduleId: o };
              if (c.hot._main)
                return { type: "unaccepted", chain: a, moduleId: o };
              for (var u = 0; u < c.parents.length; u++) {
                var p = c.parents[u],
                  h = s.c[p];
                if (h) {
                  if (h.hot._declinedDependencies[o])
                    return {
                      type: "declined",
                      chain: a.concat([p]),
                      moduleId: o,
                      parentId: p,
                    };
                  -1 === e.indexOf(p) &&
                    (h.hot._acceptedDependencies[o]
                      ? (n[p] || (n[p] = []), l(n[p], [o]))
                      : (delete n[p],
                        e.push(p),
                        i.push({ chain: a.concat([p]), id: p })));
                }
              }
            }
          }
          return {
            type: "accepted",
            moduleId: t,
            outdatedModules: e,
            outdatedDependencies: n,
          };
        }
        function l(t, e) {
          for (var n = 0; n < e.length; n++) {
            var s = e[n];
            -1 === t.indexOf(s) && t.push(s);
          }
        }
        s.f && delete s.f.jsonpHmr, (e = void 0);
        var c = {},
          u = [],
          p = {},
          h = function (t) {
            console.warn(
              "[HMR] unexpected require(" + t.id + ") to disposed module"
            );
          };
        for (var d in n)
          if (s.o(n, d)) {
            var m,
              f = n[d],
              g = !1,
              y = !1,
              v = !1,
              b = "";
            switch (
              ((m = f ? a(d) : { type: "disposed", moduleId: d }).chain &&
                (b = "\nUpdate propagation: " + m.chain.join(" -> ")),
              m.type)
            ) {
              case "self-declined":
                t.onDeclined && t.onDeclined(m),
                  t.ignoreDeclined ||
                    (g = new Error(
                      "Aborted because of self decline: " + m.moduleId + b
                    ));
                break;
              case "declined":
                t.onDeclined && t.onDeclined(m),
                  t.ignoreDeclined ||
                    (g = new Error(
                      "Aborted because of declined dependency: " +
                        m.moduleId +
                        " in " +
                        m.parentId +
                        b
                    ));
                break;
              case "unaccepted":
                t.onUnaccepted && t.onUnaccepted(m),
                  t.ignoreUnaccepted ||
                    (g = new Error(
                      "Aborted because " + d + " is not accepted" + b
                    ));
                break;
              case "accepted":
                t.onAccepted && t.onAccepted(m), (y = !0);
                break;
              case "disposed":
                t.onDisposed && t.onDisposed(m), (v = !0);
                break;
              default:
                throw new Error("Unexception type " + m.type);
            }
            if (g) return { error: g };
            if (y)
              for (d in ((p[d] = f),
              l(u, m.outdatedModules),
              m.outdatedDependencies))
                s.o(m.outdatedDependencies, d) &&
                  (c[d] || (c[d] = []), l(c[d], m.outdatedDependencies[d]));
            v && (l(u, [m.moduleId]), (p[d] = h));
          }
        n = void 0;
        for (var x, w = [], C = 0; C < u.length; C++) {
          var I = u[C],
            P = s.c[I];
          P &&
            (P.hot._selfAccepted || P.hot._main) &&
            p[I] !== h &&
            !P.hot._selfInvalidated &&
            w.push({
              module: I,
              require: P.hot._requireSelf,
              errorHandler: P.hot._selfAccepted,
            });
        }
        return {
          dispose: function () {
            var t;
            i.forEach(function (t) {
              delete o[t];
            }),
              (i = void 0);
            for (var e, n = u.slice(); n.length > 0; ) {
              var r = n.pop(),
                a = s.c[r];
              if (a) {
                var l = {},
                  p = a.hot._disposeHandlers;
                for (C = 0; C < p.length; C++) p[C].call(null, l);
                for (
                  s.hmrD[r] = l,
                    a.hot.active = !1,
                    delete s.c[r],
                    delete c[r],
                    C = 0;
                  C < a.children.length;
                  C++
                ) {
                  var h = s.c[a.children[C]];
                  h &&
                    (t = h.parents.indexOf(r)) >= 0 &&
                    h.parents.splice(t, 1);
                }
              }
            }
            for (var d in c)
              if (s.o(c, d) && (a = s.c[d]))
                for (x = c[d], C = 0; C < x.length; C++)
                  (e = x[C]),
                    (t = a.children.indexOf(e)) >= 0 && a.children.splice(t, 1);
          },
          apply: function (e) {
            for (var n in p) s.o(p, n) && (s.m[n] = p[n]);
            for (var i = 0; i < r.length; i++) r[i](s);
            for (var o in c)
              if (s.o(c, o)) {
                var a = s.c[o];
                if (a) {
                  x = c[o];
                  for (var l = [], h = [], d = [], m = 0; m < x.length; m++) {
                    var f = x[m],
                      g = a.hot._acceptedDependencies[f],
                      y = a.hot._acceptedErrorHandlers[f];
                    if (g) {
                      if (-1 !== l.indexOf(g)) continue;
                      l.push(g), h.push(y), d.push(f);
                    }
                  }
                  for (var v = 0; v < l.length; v++)
                    try {
                      l[v].call(null, x);
                    } catch (n) {
                      if ("function" == typeof h[v])
                        try {
                          h[v](n, { moduleId: o, dependencyId: d[v] });
                        } catch (s) {
                          t.onErrored &&
                            t.onErrored({
                              type: "accept-error-handler-errored",
                              moduleId: o,
                              dependencyId: d[v],
                              error: s,
                              originalError: n,
                            }),
                            t.ignoreErrored || (e(s), e(n));
                        }
                      else
                        t.onErrored &&
                          t.onErrored({
                            type: "accept-errored",
                            moduleId: o,
                            dependencyId: d[v],
                            error: n,
                          }),
                          t.ignoreErrored || e(n);
                    }
                }
              }
            for (var b = 0; b < w.length; b++) {
              var C = w[b],
                I = C.module;
              try {
                C.require(I);
              } catch (n) {
                if ("function" == typeof C.errorHandler)
                  try {
                    C.errorHandler(n, { moduleId: I, module: s.c[I] });
                  } catch (s) {
                    t.onErrored &&
                      t.onErrored({
                        type: "self-accept-error-handler-errored",
                        moduleId: I,
                        error: s,
                        originalError: n,
                      }),
                      t.ignoreErrored || (e(s), e(n));
                  }
                else
                  t.onErrored &&
                    t.onErrored({
                      type: "self-accept-errored",
                      moduleId: I,
                      error: n,
                    }),
                    t.ignoreErrored || e(n);
              }
            }
            return u;
          },
        };
      }
      (self.webpackHotUpdate = (e, i, o) => {
        for (var l in i) s.o(i, l) && ((n[l] = i[l]), t && t.push(l));
        o && r.push(o), a[e] && (a[e](), (a[e] = void 0));
      }),
        (s.hmrI.jsonp = function (t, e) {
          n || ((n = {}), (r = []), (i = []), e.push(c)),
            s.o(n, t) || (n[t] = s.m[t]);
        }),
        (s.hmrC.jsonp = function (t, a, u, p, h, d) {
          h.push(c),
            (e = {}),
            (i = a),
            (n = u.reduce(function (t, e) {
              return (t[e] = !1), t;
            }, {})),
            (r = []),
            t.forEach(function (t) {
              s.o(o, t) && void 0 !== o[t]
                ? (p.push(l(t, d)), (e[t] = !0))
                : (e[t] = !1);
            }),
            s.f &&
              (s.f.jsonpHmr = function (t, n) {
                e && s.o(e, t) && !e[t] && (n.push(l(t)), (e[t] = !0));
              });
        }),
        (s.hmrM = () => {
          if ("undefined" == typeof fetch)
            throw new Error("No browser support: need fetch API");
          return fetch(s.p + s.hmrF()).then((t) => {
            if (404 !== t.status) {
              if (!t.ok)
                throw new Error(
                  "Failed to fetch update manifest " + t.statusText
                );
              return t.json();
            }
          });
        });
    })(),
    s(604);
})();
